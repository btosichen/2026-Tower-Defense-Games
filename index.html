<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ä¸‰åœ‹ç­–ç•¥æ”»é˜²æˆ° (é›™å‘å°æˆ°ç‰ˆ - 10é—œå¡åˆ¶)</title>
    <style>
        :root {
            --primary-color: #f39c12; /* ä¸‰åœ‹é‡‘ */
            --secondary-color: #c0392b; /* æˆ°æ——ç´… */
            --player-color: #2980b9;  /* æˆ‘è»è— */
            --enemy-color: #c0392b;   /* æ•µè»ç´… */
            --bg-color: #fcf3cf;
            --ui-bg: rgba(255, 255, 255, 0.95);
        }

        body {
            margin: 0;
            padding: 0;
            font-family: "Microsoft JhengHei", "Heiti TC", sans-serif;
            background-color: #2c3e50;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            overflow: hidden;
            user-select: none;
        }

        #game-container {
            position: relative;
            width: 1200px;
            height: 800px;
            background-color: var(--bg-color);
            box-shadow: 0 0 30px rgba(0,0,0,0.6);
            border-radius: 12px;
            overflow: hidden;
            display: none;
            transform-origin: center;
        }
        
        @media (max-width: 1220px), (max-height: 820px) {
            #game-container { transform: scale(0.8); }
        }
        @media (max-width: 980px) {
            #game-container { transform: scale(0.6); }
        }

        canvas {
            display: block;
            background: #a9dfbf;
            background-image: 
                radial-gradient(#88d498 15%, transparent 16%),
                radial-gradient(#88d498 15%, transparent 16%);
            background-size: 20px 20px;
            background-position: 0 0, 10px 10px;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .hud-panel {
            position: absolute;
            background: var(--ui-bg);
            border: 3px solid var(--primary-color);
            border-radius: 10px;
            padding: 10px;
            pointer-events: auto;
            color: #2c3e50;
            font-weight: bold;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        /* Top Bar */
        #top-bar {
            top: 15px;
            left: 15px;
            right: 15px;
            height: 60px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 20px;
        }

        .hp-bar-container {
            width: 300px;
            height: 20px;
            background: #555;
            border-radius: 10px;
            overflow: hidden;
            border: 2px solid #fff;
            position: relative;
        }

        .hp-bar-fill {
            height: 100%;
            transition: width 0.2s;
        }

        /* Bottom Bar (Unit Selection) */
        #bottom-bar {
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            padding: 10px 20px;
            width: 90%;
            justify-content: center;
        }

        .unit-btn {
            width: 100px;
            height: 110px;
            border: 3px solid #ccc;
            border-radius: 10px;
            background: linear-gradient(to bottom, #fff, #ecf0f1);
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: all 0.1s;
            position: relative;
            box-shadow: 0 4px 0 #95a5a6;
        }

        .unit-btn:active {
            transform: translateY(4px);
            box-shadow: 0 0 0 #95a5a6;
        }
        
        .unit-btn.disabled {
            filter: grayscale(100%);
            opacity: 0.6;
            cursor: not-allowed;
        }

        .unit-icon { font-size: 36px; margin-bottom: 5px; }
        .unit-name { font-size: 14px; margin-bottom: 2px; }
        .unit-cost { 
            background: gold; color: #d35400; padding: 2px 8px; 
            border-radius: 4px; font-size: 14px; border: 1px solid #e67e22;
        }
        .hotkey {
            position: absolute; top: 2px; right: 5px; font-size: 10px; color: #7f8c8d;
        }

        /* Login & Result */
        #login-screen, #result-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(44, 62, 80, 0.95);
            display: flex; flex-direction: column;
            justify-content: center; align-items: center;
            color: white; z-index: 100;
        }

        .panel-box {
            background: white; padding: 40px; border-radius: 20px;
            text-align: center; color: #2c3e50;
            border: 5px solid var(--primary-color);
            width: 400px;
        }

        input {
            padding: 10px; font-size: 18px; width: 80%;
            margin: 20px 0; text-align: center;
        }

        button.start-btn {
            background: var(--secondary-color); color: white; border: none;
            padding: 15px 40px; font-size: 20px; border-radius: 30px;
            cursor: pointer; transition: 0.3s;
        }
        button.start-btn:hover { transform: scale(1.05); }

        /* Message */
        #message-area {
            position: absolute; top: 30%; left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.8); color: #fff;
            padding: 20px 40px; border-radius: 10px;
            font-size: 32px; font-weight: bold;
            display: none; pointer-events: none;
            z-index: 50; border: 2px solid gold;
        }
    </style>
</head>
<body>

    <!-- 1. ç™»å…¥ç•«é¢ -->
    <div id="login-screen">
        <div class="panel-box">
            <h1>âš”ï¸ ä¸‰åœ‹ç­–ç•¥æ”»é˜²æˆ°</h1>
            <p>æŒ‘æˆ° 10 å¤§é—œå¡ï¼Œæ”»ç ´æ•µæ–¹å¤§ç‡Ÿï¼</p>
            <input type="text" id="player-name" placeholder="è¼¸å…¥å°‡è»å¤§å" maxlength="10">
            <button class="start-btn" onclick="Game.initLogin()">å‡ºå¾</button>
            <p style="font-size:12px; color:#7f8c8d; margin-top:10px;">(è¨˜å¾—ç¢ºèª GAS å·²éƒ¨ç½²)</p>
        </div>
    </div>

    <!-- 2. éŠæˆ²ä¸»ç•«é¢ -->
    <div id="game-container">
        <canvas id="gameCanvas" width="1200" height="800"></canvas>
        
        <div id="ui-layer">
            <div id="top-bar" class="hud-panel">
                <div style="display:flex; flex-direction:column; align-items:flex-start;">
                    <span style="color:var(--enemy-color); font-size:14px;">æ•µè»å¤§ç‡Ÿ (é­) <span id="enemy-stats-hint" style="font-size:10px;color:#888;"></span></span>
                    <div class="hp-bar-container">
                        <div id="enemy-hp-bar" class="hp-bar-fill" style="width: 100%; background: #c0392b;"></div>
                    </div>
                </div>

                <div style="text-align:center;">
                    <div id="wave-info" style="font-size:24px; color:var(--primary-color);">ç¬¬ 1 é—œ</div>
                    <div style="font-size:16px;">ğŸ’° è»è²»: <span id="gold" style="color:gold; text-shadow:1px 1px 0 #000;">0</span></div>
                </div>

                <div style="display:flex; flex-direction:column; align-items:flex-end;">
                    <span style="color:var(--player-color); font-size:14px;">æˆ‘è»åŸæ±  (èœ€)</span>
                    <div class="hp-bar-container">
                        <div id="player-hp-bar" class="hp-bar-fill" style="width: 100%; background: #2980b9;"></div>
                    </div>
                </div>
            </div>

            <div id="message-area">æˆ°é¬¥é–‹å§‹ï¼</div>

            <div id="bottom-bar" class="hud-panel">
                <!-- å…µç¨®æŒ‰éˆ•ç”± JS å‹•æ…‹ç”Ÿæˆ -->
            </div>
        </div>
    </div>

    <!-- 3. çµç®—ç•«é¢ -->
    <div id="result-screen" style="display: none;">
        <div class="panel-box">
            <h1 id="end-title">æˆ°å½¹çµæŸ</h1>
            <p id="end-reason">...</p>
            <div style="text-align:left; margin: 20px 0;">
                <div>ç¸½åˆ†ï¼š<span id="final-score">0</span></div>
                <div>è€—æ™‚ï¼š<span id="final-time">0s</span></div>
            </div>
            <button class="start-btn" onclick="location.reload()">å†æˆ°ä¸€å ´</button>
        </div>
    </div>

<script>
/**
 * ç¹ªåœ–è¼”åŠ©: ç•«åœ“æŸ±é«”
 */
function drawCylinder(ctx, x, y, radius, height, color, sideColor) {
    ctx.fillStyle = sideColor;
    ctx.beginPath();
    ctx.moveTo(x - radius, y - height);
    ctx.lineTo(x + radius, y - height);
    ctx.lineTo(x + radius, y);
    ctx.lineTo(x - radius, y);
    ctx.closePath();
    ctx.fill();

    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.ellipse(x, y - height, radius, radius * 0.4, 0, 0, Math.PI * 2);
    ctx.fill();
}

/**
 * éŠæˆ²è¨­å®š
 */
const CONFIG = {
    gridSize: 80, 
    width: 15,
    height: 10,
    gasUrl: 'https://script.google.com/macros/s/AKfycbwqZFv8Jzk4A1ERYbzljRudebPBTlBn4OcSsFWfWBGLTIKGSMDEd3focinsGovte4c9/exec'
};

// å…µç¨®å®šç¾©
const UNIT_TYPES = {
    sword:    { name: 'åˆ€å…µ',   cost: 50,  hp: 120, atk: 15, range: 40,  speed: 2.5, type: 'melee',  icon: 'ğŸ—¡ï¸', color: '#f1c40f', cd: 60 },
    bow:      { name: 'å¼“å…µ',   cost: 120, hp: 80,  atk: 25, range: 250, speed: 2.5, type: 'ranged', icon: 'ğŸ¹', color: '#2ecc71', cd: 80 },
    spear:    { name: 'æ§å…µ',   cost: 200, hp: 180, atk: 40, range: 70,  speed: 2.0, type: 'melee',  icon: 'ğŸ”±', color: '#3498db', cd: 100 },
    vanguard: { name: 'å‰é‹’',   cost: 300, hp: 250, atk: 50, range: 40,  speed: 4.0, type: 'melee',  icon: 'ğŸ‡', color: '#e67e22', cd: 150 },
    vice:     { name: 'å‰¯å°‡è»', cost: 500, hp: 600, atk: 70, range: 50,  speed: 1.5, type: 'melee',  icon: 'ğŸ›¡ï¸', color: '#9b59b6', cd: 300 },
    general:  { name: 'å¤§å°‡è»', cost: 900, hp: 1200,atk: 120,range: 60,  speed: 1.2, type: 'melee',  icon: 'ğŸ‘‘', color: '#c0392b', cd: 500 }
};

// 10 å€‹ä¸åŒçš„åœ°åœ–è·¯å¾‘ (Start: index 0 -> End: Last)
const MAPS = [
    // 1. Så‹ (ç°¡å–®)
    [{x:0,y:2}, {x:3,y:2}, {x:3,y:7}, {x:8,y:7}, {x:8,y:2}, {x:12,y:2}, {x:12,y:6}, {x:14,y:6}],
    // 2. Uå‹ (ä¸­è·¯ç©ºæ› )
    [{x:0,y:1}, {x:2,y:1}, {x:2,y:8}, {x:12,y:8}, {x:12,y:1}, {x:14,y:1}],
    // 3. é‹¸é½’å‹ (è·¯å¾‘é•·)
    [{x:0,y:8}, {x:2,y:8}, {x:2,y:2}, {x:5,y:2}, {x:5,y:8}, {x:8,y:8}, {x:8,y:2}, {x:11,y:2}, {x:11,y:8}, {x:14,y:8}],
    // 4. ä¸­å¤®çªç ´ (ç›´ç·šå¾®å½)
    [{x:0,y:5}, {x:4,y:5}, {x:4,y:3}, {x:10,y:3}, {x:10,y:6}, {x:14,y:6}],
    // 5. è¿´æ—‹ (èºæ—‹æ„Ÿ)
    [{x:0,y:0}, {x:13,y:0}, {x:13,y:8}, {x:2,y:8}, {x:2,y:3}, {x:10,y:3}, {x:10,y:5}, {x:14,y:5}],
    // 6. é›™éšæ¢¯
    [{x:0,y:9}, {x:3,y:9}, {x:3,y:6}, {x:6,y:6}, {x:6,y:3}, {x:9,y:3}, {x:9,y:0}, {x:14,y:0}],
    // 7. é•·åŸé˜²ç·š (æ©«å‘ä¾†å›)
    [{x:0,y:2}, {x:14,y:2}, {x:14,y:5}, {x:0,y:5}, {x:0,y:8}, {x:14,y:8}],
    // 8. çª„å£ (åªæœ‰ä¸­é–“å¯é)
    [{x:0,y:1}, {x:6,y:1}, {x:6,y:5}, {x:8,y:5}, {x:8,y:9}, {x:14,y:9}],
    // 9. å¤§å¤–åœˆ
    [{x:0,y:4}, {x:1,y:4}, {x:1,y:9}, {x:13,y:9}, {x:13,y:1}, {x:1,y:1}, {x:1,y:4}, {x:14,y:4}],
    // 10. çµ‚æ¥µè¿·å®®
    [{x:0,y:0}, {x:0,y:9}, {x:3,y:9}, {x:3,y:2}, {x:6,y:2}, {x:6,y:7}, {x:9,y:7}, {x:9,y:1}, {x:12,y:1}, {x:12,y:8}, {x:14,y:8}]
];

// 10 é—œè¨­å®š (æ•µäººéš¨é—œå¡è®Šå¼·)
const LEVELS = Array.from({length: 10}, (_, i) => ({
    // é›£åº¦åƒæ•¸
    enemySpawnRate: Math.max(60, 180 - i * 12), // å‡ºå…µé€Ÿåº¦è¶Šä¾†è¶Šå¿«
    goldRate: 1 + i * 0.5,                      // é‡‘éŒ¢ç²å–æå‡
    // æ•µäººé¡å‹æ±  (éš¨é—œå¡è§£é–æ›´å¼·å–®ä½)
    enemyTypes: i < 2 ? ['sword', 'sword', 'spear'] :
                i < 4 ? ['sword', 'bow', 'spear', 'vanguard'] :
                i < 7 ? ['spear', 'bow', 'vanguard', 'vice'] :
                        ['vanguard', 'vice', 'general'],
    // æ•µäººå±¬æ€§åŠ æˆ (æ¯é—œ +100% æ”»æ“Šèˆ‡è¡€é‡, é€Ÿåº¦å¾®èª¿)
    statsMultiplier: 1 + i,       // Lv1=1x, Lv2=2x, Lv3=3x...
    speedMultiplier: 1 + (i * 0.1)// Lv1=1.0x, Lv10=1.9x
}));

class GameEngine {
    constructor() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.player = { name: '', id: '', score: 0 };
        
        this.gameState = {
            level: 0,
            gold: 0,
            baseHpPlayer: 1000,
            baseHpEnemy: 1000,
            maxBaseHp: 1000,
            isGameOver: false,
            enemySpawnTimer: 0
        };

        this.units = []; 
        this.projectiles = [];
        this.particles = [];
        this.pathPixels = [];
        
        this.lastTime = 0;
        this.cooldowns = {}; 
        this.createUnitButtons();
    }

    createUnitButtons() {
        const bar = document.getElementById('bottom-bar');
        bar.innerHTML = '';
        const keys = Object.keys(UNIT_TYPES);
        keys.forEach((key, index) => {
            const u = UNIT_TYPES[key];
            const div = document.createElement('div');
            div.className = 'unit-btn';
            div.id = `btn-${key}`;
            div.onclick = () => this.spawnPlayerUnit(key);
            div.innerHTML = `
                <span class="hotkey">${index+1}</span>
                <div class="unit-icon">${u.icon}</div>
                <div class="unit-name">${u.name}</div>
                <div class="unit-cost">$${u.cost}</div>
                <div class="cooldown-overlay" style="position:absolute;bottom:0;left:0;width:100%;height:0%;background:rgba(0,0,0,0.5);transition:height 0.1s;"></div>
            `;
            bar.appendChild(div);
            this.cooldowns[key] = 0;
        });

        document.addEventListener('keydown', (e) => {
            const idx = parseInt(e.key) - 1;
            if (idx >= 0 && idx < keys.length) {
                this.spawnPlayerUnit(keys[idx]);
            }
        });
    }

    initLogin() {
        const name = document.getElementById('player-name').value.trim();
        if (!name) return alert("è«‹è¼¸å…¥å¤§åï¼");
        this.player.name = name;
        this.player.id = 'ID_' + Date.now();
        this.player.startTime = Date.now();
        
        document.getElementById('login-screen').style.display = 'none';
        document.getElementById('game-container').style.display = 'block';
        
        this.startLevel(0);
        this.gameLoop(0);
    }

    startLevel(lvl) {
        if (lvl >= LEVELS.length) return this.endGame(true, "å¤©ä¸‹çµ±ä¸€ï¼ä¸‰åœ‹æ­¸ä¸€ï¼");
        
        this.gameState.level = lvl;
        
        // è¼‰å…¥è©²é—œå¡åœ°åœ–
        const mapPoints = MAPS[lvl % MAPS.length];
        this.pathPixels = mapPoints.map(p => ({
            x: p.x * CONFIG.gridSize + CONFIG.gridSize/2,
            y: p.y * CONFIG.gridSize + CONFIG.gridSize/2
        }));

        // é›£åº¦è¨­å®š
        const lvlConfig = LEVELS[lvl];
        // ç©å®¶è¡€é‡å¾®å¹…æˆé•·ï¼Œä½†æ•µäººæˆé•·æ›´å¿«
        this.gameState.maxBaseHp = 1000 + (lvl * 1000); 
        this.gameState.baseHpEnemy = this.gameState.maxBaseHp * lvlConfig.statsMultiplier; 
        this.gameState.baseHpPlayer = 1000 + (lvl * 200);
        
        // å¦‚æœæ˜¯ç¬¬ä¸€é—œï¼Œçµ¦åˆå§‹é‡‘ï¼›å¦å‰‡ä¿ç•™ä¸Šä¸€é—œé‡‘éŒ¢ä¸¦çµ¦äºˆéé—œçå‹µ
        if (lvl === 0) {
            this.gameState.gold = 500;
        } else {
            // éé—œçå‹µï¼šåŸºç¤ 1000 + é—œå¡åŠ æˆ
            const bonus = 1000 + (lvl * 500);
            this.gameState.gold += bonus;
            this.showMessage(`ç²å¾—å‡±æ—‹çé‡‘ $${bonus}ï¼`, false);
        }

        this.units = [];
        this.projectiles = [];
        this.particles = [];
        
        this.updateUI();
        
        // é¡¯ç¤ºæ•µäººå¼·åº¦æç¤º
        const enemyStatsText = `(æ•µè»å¼·åº¦: ${Math.round(lvlConfig.statsMultiplier * 100)}%)`;
        document.getElementById('enemy-stats-hint').innerText = enemyStatsText;
        
        setTimeout(() => {
            this.showMessage(`ç¬¬ ${lvl+1} é—œ - é€²æ”»ï¼`);
        }, 500);
    }

    spawnPlayerUnit(typeKey) {
        const data = UNIT_TYPES[typeKey];
        if (this.gameState.gold < data.cost) {
            this.showMessage("è»è²»ä¸è¶³", true);
            return;
        }
        if (this.cooldowns[typeKey] > 0) return;

        this.gameState.gold -= data.cost;
        this.cooldowns[typeKey] = data.cd; 

        const startNode = this.pathPixels[this.pathPixels.length - 1];
        // ç©å®¶å–®ä½ä¸äº«å—é—œå¡åŠ æˆ (é™¤éåšå‡ç´šç³»çµ±ï¼Œé€™è£¡æš«æ™‚ä¿æŒåŸæ¨£ï¼Œé æ•¸é‡èˆ‡ç­–ç•¥å–å‹)
        const unit = new Unit(startNode.x, startNode.y, 'player', typeKey, this.pathPixels.length - 1, 1, 1);
        this.units.push(unit);
        this.updateUI();
    }

    spawnEnemyUnit() {
        const lvlData = LEVELS[this.gameState.level];
        const types = lvlData.enemyTypes;
        const randType = types[Math.floor(Math.random() * types.length)];
        
        const startNode = this.pathPixels[0];
        // å‚³å…¥é—œå¡å€ç‡
        const unit = new Unit(startNode.x, startNode.y, 'enemy', randType, 0, lvlData.statsMultiplier, lvlData.speedMultiplier);
        this.units.push(unit);
    }

    gameLoop(timestamp) {
        if (this.gameState.isGameOver) return;
        if (!this.lastTime) this.lastTime = timestamp;
        const dt = timestamp - this.lastTime;

        if (dt > 16) {
            this.update();
            this.draw();
            this.lastTime = timestamp;
        }
        requestAnimationFrame((t) => this.gameLoop(t));
    }

    update() {
        const lvlData = LEVELS[this.gameState.level];

        // 1. è³‡æºèˆ‡ç”Ÿæˆ
        this.gameState.gold += lvlData.goldRate * 0.5; 
        if (this.gameState.gold > 20000) this.gameState.gold = 20000; // ä¸Šé™æé«˜

        // æ•µè»ç”Ÿæˆ
        this.gameState.enemySpawnTimer++;
        if (this.gameState.enemySpawnTimer > lvlData.enemySpawnRate) {
            this.spawnEnemyUnit();
            this.gameState.enemySpawnTimer = 0;
        }

        // å†·å»æ›´æ–°
        for (let key in this.cooldowns) {
            if (this.cooldowns[key] > 0) this.cooldowns[key]--;
            const btn = document.getElementById(`btn-${key}`);
            if(btn) {
                const overlay = btn.querySelector('.cooldown-overlay');
                const percent = (this.cooldowns[key] / UNIT_TYPES[key].cd) * 100;
                overlay.style.height = `${percent}%`;
                if(percent <= 0 && this.gameState.gold < UNIT_TYPES[key].cost) {
                     btn.classList.add('disabled');
                } else {
                     btn.classList.remove('disabled');
                }
            }
        }

        // 2. å–®ä½é‚è¼¯
        this.units.sort((a, b) => a.y - b.y);

        for (let i = this.units.length - 1; i >= 0; i--) {
            const u = this.units[i];
            u.update(this);
            if (u.dead) {
                this.units.splice(i, 1);
                if (u.team === 'enemy') {
                    // æ“Šæ®ºçé‡‘ä¹Ÿéš¨é—œå¡æå‡
                    this.gameState.gold += UNIT_TYPES[u.typeKey].cost * 0.3 * lvlData.statsMultiplier;
                    this.player.score += 10 * (this.gameState.level + 1);
                }
            }
        }

        // 3. å­å½ˆ
        for (let i = this.projectiles.length - 1; i >= 0; i--) {
            const p = this.projectiles[i];
            p.update();
            if (p.hit) this.projectiles.splice(i, 1);
        }

        // 4. ç²’å­
        this.particles = this.particles.filter(p => p.life > 0);
        this.particles.forEach(p => p.update());

        this.updateUI();

        // å‹è² åˆ¤å®š
        if (this.gameState.baseHpPlayer <= 0) this.endGame(false, "åŸæ± é™·è½ï¼Œå‹æ•—ä¹ƒå…µå®¶å¸¸äº‹...");
        if (this.gameState.baseHpEnemy <= 0) {
            this.gameState.baseHpEnemy = 0;
            this.showMessage("æ•µç‡Ÿæ”»ç ´ï¼å…¨è»æ•´å‚™ï¼Œå‰å¾€ä¸‹ä¸€æˆ°å ´...", false);
            // å»¶é²é€²å…¥ä¸‹ä¸€é—œ
            this.gameState.enemySpawnTimer = -999; // åœæ­¢å‡ºå…µ
            setTimeout(() => {
                 this.startLevel(this.gameState.level + 1);
            }, 3000);
        }
    }

    draw() {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        
        this.drawPath();

        const start = this.pathPixels[0];
        const end = this.pathPixels[this.pathPixels.length-1];
        
        // æ•µæ–¹åŸºåœ° (æ ¹æ“šå¼·åº¦è®Šå¤§)
        const enemyScale = 1 + (this.gameState.level * 0.1);
        drawCylinder(this.ctx, start.x, start.y, 50 * enemyScale, 60 * enemyScale, '#c0392b', '#922b21');
        this.drawText(start.x, start.y - 80 * enemyScale, `æ•µç‡Ÿ Lv.${this.gameState.level+1}`, "20px Arial", "#fff");
        
        // æˆ‘æ–¹åŸºåœ°
        drawCylinder(this.ctx, end.x, end.y, 50, 60, '#2980b9', '#1a5276');
        this.drawText(end.x, end.y - 80, "æˆ‘åŸ", "20px Arial", "#fff");

        this.units.forEach(u => u.draw(this.ctx));
        this.projectiles.forEach(p => p.draw(this.ctx));
        this.particles.forEach(p => p.draw(this.ctx));
    }

    drawPath() {
        this.ctx.lineCap = 'round';
        this.ctx.lineJoin = 'round';
        this.ctx.lineWidth = 60;
        this.ctx.strokeStyle = '#d7bde2'; 
        this.ctx.beginPath();
        if (this.pathPixels.length > 0) {
            this.ctx.moveTo(this.pathPixels[0].x, this.pathPixels[0].y + 5);
            for (let i = 1; i < this.pathPixels.length; i++) {
                this.ctx.lineTo(this.pathPixels[i].x, this.pathPixels[i].y + 5);
            }
        }
        this.ctx.stroke();

        this.ctx.strokeStyle = '#f5eef8';
        this.ctx.beginPath();
        if (this.pathPixels.length > 0) {
            this.ctx.moveTo(this.pathPixels[0].x, this.pathPixels[0].y);
            for (let i = 1; i < this.pathPixels.length; i++) {
                this.ctx.lineTo(this.pathPixels[i].x, this.pathPixels[i].y);
            }
        }
        this.ctx.stroke();
    }

    drawText(x, y, text, font, color) {
        this.ctx.font = font;
        this.ctx.fillStyle = color;
        this.ctx.textAlign = "center";
        this.ctx.fillText(text, x, y);
    }

    updateUI() {
        document.getElementById('gold').innerText = Math.floor(this.gameState.gold);
        document.getElementById('wave-info').innerText = `ç¬¬ ${this.gameState.level + 1} é—œ`;
        
        // è¡€æ¢æ›´æ–° (è€ƒæ…® maxHp è®Šå‹•)
        const pPct = Math.max(0, (this.gameState.baseHpPlayer / (1000 + this.gameState.level * 200)) * 100);
        document.getElementById('player-hp-bar').style.width = `${pPct}%`;
        
        const enemyMaxHp = (1000 + (this.gameState.level * 1000)) * LEVELS[this.gameState.level].statsMultiplier;
        const ePct = Math.max(0, (this.gameState.baseHpEnemy / enemyMaxHp) * 100);
        document.getElementById('enemy-hp-bar').style.width = `${ePct}%`;
    }

    showMessage(msg, isWarning = false) {
        const el = document.getElementById('message-area');
        el.innerText = msg;
        el.style.color = isWarning ? '#e74c3c' : '#fff';
        el.style.borderColor = isWarning ? '#e74c3c' : 'gold';
        el.style.display = 'block';
        el.style.opacity = 1;
        
        if(this.msgTimeout) clearTimeout(this.msgTimeout);
        this.msgTimeout = setTimeout(() => {
            el.style.display = 'none';
        }, 1500);
    }

    createEffect(x, y, type) {
        let color = 'white';
        if (type === 'hit') color = 'orange';
        if (type === 'blood') color = 'red';
        for(let i=0; i<5; i++) {
            this.particles.push(new Particle(x, y, color));
        }
    }

    endGame(isWin, reason) {
        this.gameState.isGameOver = true;
        document.getElementById('result-screen').style.display = 'flex';
        document.getElementById('end-title').innerText = isWin ? "ğŸ† å¤§ç²å…¨å‹" : "ğŸ’€ æˆ°æ•—";
        document.getElementById('end-title').style.color = isWin ? "gold" : "#e74c3c";
        document.getElementById('end-reason').innerText = reason;
        
        const duration = Math.floor((Date.now() - this.player.startTime)/1000);
        document.getElementById('final-score').innerText = this.player.score;
        document.getElementById('final-time').innerText = duration + "s";

        this.sendToGas(duration);
    }

    sendToGas(duration) {
        if(CONFIG.gasUrl.includes("exec")) {
            const data = {
                name: this.player.name,
                id: this.player.id,
                score: this.player.score,
                duration: duration,
                date: new Date().toISOString()
            };
            fetch(CONFIG.gasUrl, {
                method: 'POST',
                mode: 'no-cors',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify(data)
            }).then(() => console.log("Sent to GAS")).catch(e => console.error(e));
        }
    }
}

class Unit {
    constructor(x, y, team, typeKey, pathIdx, statsMult = 1, speedMult = 1) {
        this.x = x;
        this.y = y;
        this.team = team; 
        this.typeKey = typeKey;
        
        const data = UNIT_TYPES[typeKey];
        this.name = data.name;
        // å¥—ç”¨é—œå¡å€ç‡
        this.maxHp = data.hp * statsMult;
        this.hp = this.maxHp;
        this.atk = data.atk * statsMult;
        this.range = data.range;
        this.speed = data.speed * speedMult;
        
        this.attackType = data.type; 
        this.icon = data.icon;
        this.color = data.color;

        this.pathIndex = pathIdx;
        this.targetNode = null;
        this.state = 'move'; 
        this.attackCooldown = 0;
        this.dead = false;
        
        this.visualHeight = (typeKey === 'general') ? 50 : 30;
        this.bounce = 0;
    }

    update(game) {
        if (this.dead) return;

        if (this.attackCooldown > 0) this.attackCooldown--;

        let target = this.findTarget(game);
        
        if (target) {
            this.state = 'attack';
            if (this.attackCooldown <= 0) {
                this.attack(target, game);
                this.attackCooldown = 60; 
            }
        } else {
            this.state = 'move';
            this.move(game);
        }

        if (this.state === 'move') {
            this.bounce = Math.sin(Date.now() / 100) * 3;
        } else {
            this.bounce = 0;
        }
    }

    findTarget(game) {
        for (let u of game.units) {
            if (u.team !== this.team && !u.dead) {
                const dist = Math.hypot(u.x - this.x, u.y - this.y);
                if (dist <= this.range) return u;
            }
        }
        let baseDist = 9999;
        if (this.team === 'player') {
            const base = game.pathPixels[0];
            baseDist = Math.hypot(base.x - this.x, base.y - this.y);
            if (baseDist <= this.range) return { type: 'base', team: 'enemy' };
        } else {
            const base = game.pathPixels[game.pathPixels.length-1];
            baseDist = Math.hypot(base.x - this.x, base.y - this.y);
            if (baseDist <= this.range) return { type: 'base', team: 'player' };
        }
        return null;
    }

    attack(target, game) {
        if (this.attackType === 'ranged') {
            game.projectiles.push(new Projectile(this.x, this.y - this.visualHeight, target, this.atk, this.team));
        } else {
            game.createEffect(target.x || this.x, target.y || this.y, 'hit');
            if (target.type === 'base') {
                if (target.team === 'player') game.gameState.baseHpPlayer -= this.atk;
                else game.gameState.baseHpEnemy -= this.atk;
                game.createEffect(this.x, this.y, 'hit'); 
            } else {
                target.takeDamage(this.atk, game);
            }
        }
    }

    move(game) {
        let nextIdx = (this.team === 'player') ? this.pathIndex - 1 : this.pathIndex + 1;
        
        if (nextIdx < 0 || nextIdx >= game.pathPixels.length) {
            return; 
        }

        const targetNode = game.pathPixels[nextIdx];
        const dx = targetNode.x - this.x;
        const dy = targetNode.y - this.y;
        const dist = Math.hypot(dx, dy);

        if (dist <= this.speed) {
            this.x = targetNode.x;
            this.y = targetNode.y;
            this.pathIndex = nextIdx;
        } else {
            this.x += (dx / dist) * this.speed;
            this.y += (dy / dist) * this.speed;
        }
    }

    takeDamage(amount, game) {
        this.hp -= amount;
        game.createEffect(this.x, this.y - this.visualHeight, 'blood');
        if (this.hp <= 0) {
            this.dead = true;
        }
    }

    draw(ctx) {
        const drawY = this.y - this.visualHeight + this.bounce;

        ctx.fillStyle = "rgba(0,0,0,0.3)";
        ctx.beginPath();
        ctx.ellipse(this.x, this.y, 15, 8, 0, 0, Math.PI*2);
        ctx.fill();

        ctx.lineWidth = 3;
        ctx.strokeStyle = this.team === 'player' ? '#2980b9' : '#c0392b';
        ctx.fillStyle = this.color;
        
        ctx.beginPath();
        ctx.arc(this.x, drawY, 20, 0, Math.PI*2);
        ctx.fill();
        ctx.stroke();

        ctx.font = "20px Arial";
        ctx.fillStyle = "#fff";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(this.icon, this.x, drawY);

        const hpPct = this.hp / this.maxHp;
        ctx.fillStyle = "red";
        ctx.fillRect(this.x - 15, drawY - 30, 30, 5);
        ctx.fillStyle = "#2ecc71";
        ctx.fillRect(this.x - 15, drawY - 30, 30 * hpPct, 5);
    }
}

class Projectile {
    constructor(x, y, target, dmg, team) {
        this.x = x; this.y = y;
        this.target = target;
        this.damage = dmg;
        this.team = team;
        this.speed = 10;
        this.hit = false;
        
        this.tx = target.x || (team === 'player' ? Game.pathPixels[0].x : Game.pathPixels[Game.pathPixels.length-1].x);
        this.ty = target.y || (team === 'player' ? Game.pathPixels[0].y : Game.pathPixels[Game.pathPixels.length-1].y);
        if(target.visualHeight) this.ty -= target.visualHeight;
    }

    update() {
        if (this.target && !this.target.dead) {
            this.tx = this.target.x || this.tx;
            this.ty = (this.target.y || this.ty) - (this.target.visualHeight || 30);
        }

        const dx = this.tx - this.x;
        const dy = this.ty - this.y;
        const dist = Math.hypot(dx, dy);

        if (dist <= this.speed) {
            this.hit = true;
            Game.createEffect(this.tx, this.ty, 'hit');
            if (this.target.type === 'base') {
                if (this.target.team === 'player') Game.gameState.baseHpPlayer -= this.damage;
                else Game.gameState.baseHpEnemy -= this.damage;
            } else if (this.target.takeDamage) {
                this.target.takeDamage(this.damage, Game);
            }
        } else {
            this.x += (dx/dist) * this.speed;
            this.y += (dy/dist) * this.speed;
        }
    }

    draw(ctx) {
        ctx.fillStyle = this.team === 'player' ? '#3498db' : '#e74c3c';
        ctx.beginPath();
        ctx.arc(this.x, this.y, 5, 0, Math.PI*2);
        ctx.fill();
    }
}

class Particle {
    constructor(x, y, color) {
        this.x = x; this.y = y; this.color = color;
        this.vx = (Math.random()-0.5)*5;
        this.vy = (Math.random()-0.5)*5;
        this.life = 1.0;
    }
    update() {
        this.x += this.vx; this.y += this.vy; this.life -= 0.1;
    }
    draw(ctx) {
        ctx.globalAlpha = Math.max(0, this.life);
        ctx.fillStyle = this.color;
        ctx.beginPath(); ctx.arc(this.x, this.y, 3, 0, Math.PI*2); ctx.fill();
        ctx.globalAlpha = 1;
    }
}

const Game = new GameEngine();

</script>
</body>
</html>
