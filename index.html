<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Qç‰ˆä¸‰åœ‹ç­–ç•¥å¡”é˜²</title>
    <style>
        :root {
            --primary-color: #f39c12; /* ä¸‰åœ‹é‡‘ */
            --secondary-color: #e74c3c; /* æˆ°æ——ç´… */
            --bg-color: #fcf3cf; /* å®£ç´™/ç¾Šçš®ç´™è‰² */
            --text-color: #2c3e50;
        }

        body {
            margin: 0;
            padding: 0;
            font-family: "Microsoft JhengHei", "Heiti TC", sans-serif;
            background-color: #2c3e50;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            overflow: hidden;
            user-select: none;
        }

        #game-container {
            position: relative;
            width: 960px;
            height: 640px;
            background-color: var(--bg-color);
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            border-radius: 10px;
            overflow: hidden;
            display: none; /* ç™»å…¥å¾Œé¡¯ç¤º */
        }

        /* Canvas */
        canvas {
            display: block;
            background: #a9dfbf; /* è‰åœ°ç¶  */
        }

        /* UI Overlay */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .hud-panel {
            position: absolute;
            background: rgba(255, 255, 255, 0.9);
            border: 2px solid var(--primary-color);
            border-radius: 8px;
            padding: 10px;
            pointer-events: auto;
            color: var(--text-color);
            font-weight: bold;
        }

        /* Top Bar */
        #top-bar {
            top: 10px;
            left: 10px;
            right: 10px;
            height: 40px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #fff;
        }

        /* Bottom Bar (Tower Selection) */
        #bottom-bar {
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 15px;
            padding: 10px 20px;
        }

        .tower-btn {
            width: 70px;
            height: 80px;
            border: 3px solid #ccc;
            border-radius: 10px;
            background: #fff;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: 0.2s;
            font-size: 12px;
            position: relative;
        }

        .tower-btn.selected {
            border-color: var(--secondary-color);
            background: #fadbd8;
            transform: translateY(-5px);
        }

        .tower-btn:hover {
            background: #fdf2e9;
        }
        
        .tower-icon {
            font-size: 24px;
            margin-bottom: 5px;
        }

        .price-tag {
            background: gold;
            padding: 2px 5px;
            border-radius: 4px;
            font-size: 10px;
            margin-top: 2px;
        }

        /* Login Screen */
        #login-screen, #result-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(44, 62, 80, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            z-index: 100;
        }

        .panel-box {
            background: white;
            padding: 40px;
            border-radius: 15px;
            text-align: center;
            color: var(--text-color);
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            border: 4px solid var(--primary-color);
            max-width: 400px;
            width: 90%;
        }

        input {
            padding: 10px;
            font-size: 16px;
            border: 2px solid #ddd;
            border-radius: 5px;
            width: 80%;
            margin: 15px 0;
        }

        button.start-btn {
            background: var(--secondary-color);
            color: white;
            border: none;
            padding: 12px 30px;
            font-size: 18px;
            border-radius: 25px;
            cursor: pointer;
            font-weight: bold;
            transition: 0.3s;
        }

        button.start-btn:hover {
            background: #c0392b;
            transform: scale(1.05);
        }

        h1 { color: var(--secondary-color); margin-bottom: 10px; }
        h2 { margin-top: 0; }
        
        .stat-row {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
            border-bottom: 1px dashed #ccc;
            padding-bottom: 5px;
        }

        /* Tooltip style for messages */
        #message-area {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 15px 30px;
            border-radius: 30px;
            font-size: 20px;
            display: none;
            pointer-events: none;
        }

    </style>
</head>
<body>

    <!-- 1. ç™»å…¥ç•«é¢ -->
    <div id="login-screen">
        <div class="panel-box">
            <h1>ğŸ›¡ï¸ Qç‰ˆä¸‰åœ‹å¡”é˜²</h1>
            <p>è«‹è¼¸å…¥ä½ çš„å¤§åï¼Œæº–å‚™å®ˆè­·åŸæ± ï¼</p>
            <input type="text" id="player-name" placeholder="è«‹è¼¸å…¥å§“åæˆ–æš±ç¨±" maxlength="10">
            <br>
            <button class="start-btn" onclick="Game.initLogin()">é–‹å§‹æŒ‘æˆ°</button>
        </div>
    </div>

    <!-- 2. éŠæˆ²ä¸»ç•«é¢ -->
    <div id="game-container">
        <canvas id="gameCanvas" width="960" height="640"></canvas>
        
        <div id="ui-layer">
            <!-- é ‚éƒ¨è³‡è¨Šåˆ— -->
            <div id="top-bar" class="hud-panel">
                <span id="display-name">å°‡è»: æœªç™»å…¥</span>
                <span>ğŸ† åˆ†æ•¸: <span id="score">0</span></span>
                <span>ğŸ’° è»è²»: <span id="gold">0</span></span>
                <span>â¤ï¸ åŸé˜²: <span id="lives">0</span></span>
                <span>ğŸš© é—œå¡: <span id="level">1</span>/3</span>
                <span id="wave-info">æ³¢æ¬¡: 1</span>
            </div>

            <!-- ä¸­å¤®è¨Šæ¯å€ -->
            <div id="message-area">é—œå¡é–‹å§‹ï¼</div>

            <!-- åº•éƒ¨å¡”é¸æ“‡å€ -->
            <div id="bottom-bar" class="hud-panel">
                <div class="tower-btn" onclick="Game.selectTower('archer')" id="btn-archer">
                    <div class="tower-icon">ğŸ¹</div>
                    <div>å¼“å…µå¡”</div>
                    <div class="price-tag">$100</div>
                </div>
                <div class="tower-btn" onclick="Game.selectTower('spear')" id="btn-spear">
                    <div class="tower-icon">ğŸ”±</div>
                    <div>æ§å…µå¡”</div>
                    <div class="price-tag">$150</div>
                </div>
                <div class="tower-btn" onclick="Game.selectTower('mage')" id="btn-mage">
                    <div class="tower-icon">ğŸ”®</div>
                    <div>ç­–å£«å¡”</div>
                    <div class="price-tag">$250</div>
                </div>
                <div class="tower-btn" onclick="Game.selectTower('cannon')" id="btn-cannon">
                    <div class="tower-icon">ğŸ’£</div>
                    <div>ç ²è»Šå¡”</div>
                    <div class="price-tag">$350</div>
                </div>
            </div>
        </div>
    </div>

    <!-- 3. çµç®—ç•«é¢ -->
    <div id="result-screen" style="display: none;">
        <div class="panel-box">
            <h1>æˆ°å½¹çµæŸ</h1>
            <h2 id="end-title">æ­å–œé€šé—œ</h2>
            <div class="stat-row"><span>ç¸½å¾—åˆ†ï¼š</span><span id="final-score">0</span></div>
            <div class="stat-row"><span>ç¬¬ä¸€é—œï¼š</span><span id="score-l1">0</span></div>
            <div class="stat-row"><span>ç¬¬äºŒé—œï¼š</span><span id="score-l2">0</span></div>
            <div class="stat-row"><span>ç¬¬ä¸‰é—œï¼š</span><span id="score-l3">0</span></div>
            <div class="stat-row"><span>è€—æ™‚ï¼š</span><span id="final-time">0s</span></div>
            <p style="font-size: 12px; color: #888; margin-top: 10px;">è³‡æ–™æ­£å‚³é€è‡³è»æ©Ÿè™•(é›²ç«¯)...</p>
            <button class="start-btn" onclick="location.reload()">å†ç©ä¸€æ¬¡</button>
        </div>
    </div>

<script>
/**
 * éŠæˆ²è¨­å®šèˆ‡å…¨åŸŸè®Šæ•¸
 */
const CONFIG = {
    gridSize: 64, // æ¯å€‹æ ¼å­çš„åƒç´ å¤§å°
    width: 15,    // æ©«å‘æ ¼å­æ•¸ (960/64)
    height: 10,   // ç¸±å‘æ ¼å­æ•¸ (640/64)
    // Google Apps Script Web App URL (è«‹ä½¿ç”¨è€…æ›¿æ›æˆè‡ªå·±çš„)
    gasUrl: 'https://script.google.com/macros/s/AKfycbwqZFv8Jzk4A1ERYbzljRudebPBTlBn4OcSsFWfWBGLTIKGSMDEd3focinsGovte4c9/exec' 
};

// å¡”çš„æ•¸æ“šè¨­å®š
const TOWER_TYPES = {
    archer: { name: 'å¼“å…µ', cost: 100, range: 2.5, damage: 15, cooldown: 30, color: '#27ae60', type: 'single', projectileSpeed: 10 },
    spear:  { name: 'æ§å…µ', cost: 150, range: 2, damage: 25, cooldown: 40, color: '#2980b9', type: 'single', projectileSpeed: 12 },
    mage:   { name: 'ç­–å£«', cost: 250, range: 3.5, damage: 10, cooldown: 50, color: '#8e44ad', type: 'aoe_slow', projectileSpeed: 8 },
    cannon: { name: 'ç ²è»Š', cost: 350, range: 4, damage: 50, cooldown: 90, color: '#c0392b', type: 'aoe_damage', projectileSpeed: 6 }
};

// æ•µäººæ•¸æ“šè¨­å®š
const ENEMY_TYPES = {
    normal: { hp: 40, speed: 2, reward: 15, color: '#e67e22', radius: 15 },
    heavy:  { hp: 120, speed: 1, reward: 30, color: '#7f8c8d', radius: 18 },
    boss:   { hp: 600, speed: 0.8, reward: 200, color: '#c0392b', radius: 25 }
};

// é—œå¡æ³¢æ¬¡è¨­å®š (ç°¡å–®ç‰ˆ)
const LEVELS = [
    {   // Level 1
        startGold: 350,
        waves: [
            { count: 5, type: 'normal', interval: 80 },
            { count: 10, type: 'normal', interval: 60 }
        ]
    },
    {   // Level 2
        startGold: 400,
        waves: [
            { count: 10, type: 'normal', interval: 50 },
            { count: 5, type: 'heavy', interval: 90 },
            { count: 5, type: 'normal', interval: 40 }
        ]
    },
    {   // Level 3
        startGold: 500,
        waves: [
            { count: 8, type: 'heavy', interval: 80 },
            { count: 15, type: 'normal', interval: 30 },
            { count: 1, type: 'boss', interval: 100 }
        ]
    }
];

// åœ°åœ–è·¯å¾‘é» (ä»¥æ ¼å­åº§æ¨™è¡¨ç¤º: x, y)
// é€™æ˜¯ä¸€å€‹ S å‹è·¯ç·š
const PATH_POINTS = [
    {x: 0, y: 2}, {x: 3, y: 2}, {x: 3, y: 7}, 
    {x: 8, y: 7}, {x: 8, y: 2}, {x: 12, y: 2}, 
    {x: 12, y: 6}, {x: 14, y: 6}
];

/**
 * éŠæˆ²æ ¸å¿ƒé¡åˆ¥
 */
class GameEngine {
    constructor() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.player = {
            name: '',
            id: '',
            score: 0,
            levelScores: [0, 0, 0],
            startTime: 0
        };
        
        this.gameState = {
            level: 0, // 0-indexed (0 = Level 1)
            gold: 0,
            lives: 20,
            waveIndex: 0,
            enemiesToSpawn: 0,
            spawnTimer: 0,
            currentEnemyType: null,
            isWaveActive: false,
            isGameOver: false,
            isPlaying: false
        };

        this.entities = {
            towers: [],
            enemies: [],
            projectiles: [],
            particles: [] // çˆ†ç‚¸æ•ˆæœ
        };

        this.selectedTowerType = null;
        this.lastTime = 0;
        
        // ç¶å®šé»æ“Šäº‹ä»¶
        this.canvas.addEventListener('click', (e) => this.handleCanvasClick(e));
        
        // å°‡è·¯å¾‘é»è½‰æ›ç‚ºåƒç´ åº§æ¨™
        this.pathPixels = PATH_POINTS.map(p => ({
            x: p.x * CONFIG.gridSize + CONFIG.gridSize/2,
            y: p.y * CONFIG.gridSize + CONFIG.gridSize/2
        }));
    }

    initLogin() {
        const nameInput = document.getElementById('player-name');
        const name = nameInput.value.trim();
        if (!name) {
            alert("è«‹è¼¸å…¥å¤§åï¼");
            return;
        }

        this.player.name = name;
        this.player.id = 'ID_' + Date.now().toString().slice(-6); // ç°¡æ˜“ID
        this.player.startTime = Date.now();

        document.getElementById('display-name').textContent = `å°‡è»: ${name}`;
        document.getElementById('login-screen').style.display = 'none';
        document.getElementById('game-container').style.display = 'block';

        this.startLevel(0);
        this.gameLoop(0);
    }

    startLevel(levelIndex) {
        if (levelIndex >= LEVELS.length) {
            this.endGame(true); // å…¨é€šé—œ
            return;
        }

        this.gameState.level = levelIndex;
        this.gameState.gold = LEVELS[levelIndex].startGold;
        this.gameState.lives = 20; // æ¯é—œé‡ç½®ç”Ÿå‘½æˆ–ç´¯è¨ˆçœ‹éœ€æ±‚ï¼Œé€™è£¡è¨­å®šé‡ç½®
        this.gameState.waveIndex = 0;
        this.gameState.isWaveActive = true;
        
        // æ¸…ç©ºå¯¦é«”
        this.entities.towers = [];
        this.entities.enemies = [];
        this.entities.projectiles = [];
        this.entities.particles = [];

        this.startNextWave();
        this.updateUI();
        this.showMessage(`ç¬¬ ${levelIndex + 1} é—œ é–‹å§‹ï¼`);
    }

    startNextWave() {
        const levelData = LEVELS[this.gameState.level];
        if (this.gameState.waveIndex >= levelData.waves.length) {
            // æ‰€æœ‰æ³¢æ¬¡çµæŸï¼Œæª¢æŸ¥æ˜¯å¦é‚„æœ‰æ•µäºº
            if (this.entities.enemies.length === 0) {
                // é—œå¡å®Œæˆ
                this.calculateLevelScore();
                setTimeout(() => this.startLevel(this.gameState.level + 1), 2000);
            }
            return;
        }

        const waveData = levelData.waves[this.gameState.waveIndex];
        this.gameState.enemiesToSpawn = waveData.count;
        this.gameState.currentEnemyType = waveData.type;
        this.gameState.spawnInterval = waveData.interval;
        this.gameState.spawnTimer = 0;
        
        document.getElementById('wave-info').textContent = `æ³¢æ¬¡: ${this.gameState.waveIndex + 1}/${levelData.waves.length}`;
    }

    calculateLevelScore() {
        // åˆ†æ•¸ = å‰©é¤˜ç”Ÿå‘½ * 100 + æ“Šæ®ºåˆ† (å·²ç´¯åŠ )
        const bonus = this.gameState.lives * 50;
        this.player.score += bonus;
        this.player.levelScores[this.gameState.level] = this.player.score - (this.gameState.level > 0 ? this.player.levelScores[this.gameState.level-1] : 0);
        this.showMessage(`é—œå¡å®Œæˆï¼çå‹µ ${bonus} åˆ†`);
    }

    selectTower(type) {
        // åˆ‡æ›é¸å–ç‹€æ…‹
        document.querySelectorAll('.tower-btn').forEach(btn => btn.classList.remove('selected'));
        
        if (this.selectedTowerType === type) {
            this.selectedTowerType = null; // å–æ¶ˆé¸å–
        } else {
            this.selectedTowerType = type;
            document.getElementById(`btn-${type}`).classList.add('selected');
        }
    }

    handleCanvasClick(e) {
        if (!this.selectedTowerType) return;

        const rect = this.canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;

        // è½‰æ›ç‚ºæ ¼å­åº§æ¨™
        const gridX = Math.floor(x / CONFIG.gridSize);
        const gridY = Math.floor(y / CONFIG.gridSize);

        // æª¢æŸ¥æ˜¯å¦å¯ä»¥å»ºé€ 
        if (this.canBuild(gridX, gridY)) {
            const cost = TOWER_TYPES[this.selectedTowerType].cost;
            if (this.gameState.gold >= cost) {
                this.gameState.gold -= cost;
                this.entities.towers.push(new Tower(gridX, gridY, this.selectedTowerType));
                // å»ºé€ å¾Œå–æ¶ˆé¸æ“‡ (æˆ–ä¿ç•™çœ‹æ‰‹æ„Ÿï¼Œé€™è£¡è¨­ç‚ºå–æ¶ˆ)
                // this.selectTower(null); 
                this.updateUI();
                this.createEffect(x, y, 'build');
            } else {
                this.showMessage("è»è²»ä¸è¶³ï¼");
            }
        } else {
            this.showMessage("æ­¤è™•ç„¡æ³•å»ºé€ ï¼");
        }
    }

    canBuild(gx, gy) {
        // 1. æª¢æŸ¥æ˜¯å¦åœ¨é‚Šç•Œå…§
        if (gx < 0 || gx >= CONFIG.width || gy < 0 || gy >= CONFIG.height) return false;
        
        // 2. æª¢æŸ¥æ˜¯å¦åœ¨è·¯å¾‘ä¸Š
        // ç°¡å–®åˆ¤å®šï¼šæª¢æŸ¥è©²æ ¼å­æ˜¯å¦åŒ…å«è·¯å¾‘ç·šæ®µ
        // ç”±æ–¼æˆ‘å€‘æ˜¯ç¶²æ ¼ç§»å‹•ï¼Œç°¡å–®æ¯”å°è·¯å¾‘é»é€£ç·š
        for (let i = 0; i < PATH_POINTS.length - 1; i++) {
            const p1 = PATH_POINTS[i];
            const p2 = PATH_POINTS[i+1];
            
            // æª¢æŸ¥æ°´å¹³ç·šæ®µ
            if (p1.y === p2.y && gy === p1.y) {
                if (gx >= Math.min(p1.x, p2.x) && gx <= Math.max(p1.x, p2.x)) return false;
            }
            // æª¢æŸ¥å‚ç›´ç·šæ®µ
            if (p1.x === p2.x && gx === p1.x) {
                if (gy >= Math.min(p1.y, p2.y) && gy <= Math.max(p1.y, p2.y)) return false;
            }
        }

        // 3. æª¢æŸ¥æ˜¯å¦å·²æœ‰å¡”
        for (let t of this.entities.towers) {
            if (t.gx === gx && t.gy === gy) return false;
        }

        return true;
    }

    // --- éŠæˆ²è¿´åœˆ ---
    gameLoop(timestamp) {
        if (this.gameState.isGameOver) return;

        // è¨ˆç®— delta time
        if (!this.lastTime) this.lastTime = timestamp;
        const dt = timestamp - this.lastTime;
        
        // é™åˆ¶æ›´æ–°é »ç‡ç°¡å–®è™•ç† (ä»¥60FPSç‚ºåŸºæº–)
        if (dt > 16) {
            this.update();
            this.draw();
            this.lastTime = timestamp;
        }

        requestAnimationFrame((t) => this.gameLoop(t));
    }

    update() {
        // 1. ç”Ÿæˆæ•µäºº
        if (this.gameState.enemiesToSpawn > 0) {
            this.gameState.spawnTimer++;
            if (this.gameState.spawnTimer > this.gameState.spawnInterval) {
                this.spawnEnemy();
                this.gameState.spawnTimer = 0;
            }
        } else if (this.entities.enemies.length === 0 && this.gameState.isWaveActive) {
            // æœ¬æ³¢æ¬¡çµæŸï¼Œæº–å‚™ä¸‹ä¸€æ³¢
            this.gameState.waveIndex++;
            this.startNextWave();
        }

        // 2. æ›´æ–°æ•µäºº
        for (let i = this.entities.enemies.length - 1; i >= 0; i--) {
            const enemy = this.entities.enemies[i];
            enemy.update();
            
            // åˆ°é”çµ‚é»
            if (enemy.finished) {
                this.gameState.lives--;
                this.entities.enemies.splice(i, 1);
                this.updateUI();
                if (this.gameState.lives <= 0) this.endGame(false);
            }
        }

        // 3. å¡”æ”»æ“Š
        this.entities.towers.forEach(tower => tower.update(this.entities.enemies, this));

        // 4. å­å½ˆç§»å‹•èˆ‡ç¢°æ’
        for (let i = this.entities.projectiles.length - 1; i >= 0; i--) {
            const p = this.entities.projectiles[i];
            p.update();
            if (p.hit) {
                this.createEffect(p.x, p.y, 'hit');
                this.entities.projectiles.splice(i, 1);
            } else if (p.outOfBounds) {
                this.entities.projectiles.splice(i, 1);
            }
        }

        // 5. ç²’å­æ•ˆæœ
        this.entities.particles = this.entities.particles.filter(p => p.life > 0);
        this.entities.particles.forEach(p => p.update());
    }

    spawnEnemy() {
        const typeData = ENEMY_TYPES[this.gameState.currentEnemyType];
        // å¾ç¬¬ä¸€å€‹è·¯å¾‘é»é–‹å§‹
        const startNode = this.pathPixels[0];
        const enemy = new Enemy(startNode.x, startNode.y, this.gameState.currentEnemyType, typeData);
        this.entities.enemies.push(enemy);
        this.gameState.enemiesToSpawn--;
    }

    draw() {
        // æ¸…ç©ºç•«å¸ƒ
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

        // ç¹ªè£½åœ°åœ–ç¶²æ ¼ (æ·¡æ·¡çš„)
        this.ctx.strokeStyle = "rgba(0,0,0,0.05)";
        this.ctx.beginPath();
        for(let x=0; x<=CONFIG.width; x++) {
            this.ctx.moveTo(x*CONFIG.gridSize, 0);
            this.ctx.lineTo(x*CONFIG.gridSize, CONFIG.height*CONFIG.gridSize);
        }
        for(let y=0; y<=CONFIG.height; y++) {
            this.ctx.moveTo(0, y*CONFIG.gridSize);
            this.ctx.lineTo(CONFIG.width*CONFIG.gridSize, y*CONFIG.gridSize);
        }
        this.ctx.stroke();

        // ç¹ªè£½è·¯å¾‘
        this.ctx.lineCap = 'round';
        this.ctx.lineJoin = 'round';
        this.ctx.lineWidth = 40;
        this.ctx.strokeStyle = '#d2b48c'; // åœŸè·¯é¡è‰²
        this.ctx.beginPath();
        if (this.pathPixels.length > 0) {
            this.ctx.moveTo(this.pathPixels[0].x, this.pathPixels[0].y);
            for (let i = 1; i < this.pathPixels.length; i++) {
                this.ctx.lineTo(this.pathPixels[i].x, this.pathPixels[i].y);
            }
        }
        this.ctx.stroke();

        // ç¹ªè£½èµ·é»çµ‚é»
        const start = this.pathPixels[0];
        const end = this.pathPixels[this.pathPixels.length-1];
        this.drawIcon(start.x, start.y, 'ğŸš©', 30);
        this.drawIcon(end.x, end.y, 'ğŸ¯', 40);

        // ç¹ªè£½å¡”
        this.entities.towers.forEach(t => t.draw(this.ctx));

        // ç¹ªè£½æ•µäºº
        this.entities.enemies.forEach(e => e.draw(this.ctx));

        // ç¹ªè£½å­å½ˆ
        this.entities.projectiles.forEach(p => p.draw(this.ctx));
        
        // ç¹ªè£½ç²’å­
        this.entities.particles.forEach(p => p.draw(this.ctx));

        // ç¹ªè£½é¸å–é è¦½ (Ghost Tower)
        if (this.selectedTowerType) {
            // é€™è£¡å¯ä»¥åšæ»‘é¼ è·Ÿéš¨æ•ˆæœï¼Œç‚ºäº†ç°¡åŒ–çœç•¥
        }
    }

    drawIcon(x, y, char, size) {
        this.ctx.font = `${size}px Arial`;
        this.ctx.textAlign = 'center';
        this.ctx.textBaseline = 'middle';
        this.ctx.fillText(char, x, y);
    }

    createEffect(x, y, type) {
        if (type === 'hit') {
            for(let i=0; i<5; i++) {
                this.entities.particles.push(new Particle(x, y, 'orange'));
            }
        } else if (type === 'build') {
            for(let i=0; i<8; i++) {
                this.entities.particles.push(new Particle(x, y, 'white'));
            }
        }
    }

    updateUI() {
        document.getElementById('score').innerText = this.player.score;
        document.getElementById('gold').innerText = this.gameState.gold;
        document.getElementById('lives').innerText = this.gameState.lives;
        document.getElementById('level').innerText = this.gameState.level + 1;
    }

    showMessage(msg) {
        const el = document.getElementById('message-area');
        el.textContent = msg;
        el.style.display = 'block';
        el.style.opacity = 1;
        
        // ç°¡å–®çš„æ·¡å‡ºå‹•ç•«
        setTimeout(() => {
            el.style.display = 'none';
        }, 1500);
    }

    endGame(isWin) {
        this.gameState.isGameOver = true;
        const resultScreen = document.getElementById('result-screen');
        const endTitle = document.getElementById('end-title');
        
        const duration = Math.floor((Date.now() - this.player.startTime) / 1000);
        
        if (isWin) {
            endTitle.textContent = "ğŸ† ä¸€çµ±å¤©ä¸‹ (é€šé—œæˆåŠŸ)";
            endTitle.style.color = "gold";
        } else {
            endTitle.textContent = "ğŸ’€ åŸæ± å¤±å®ˆ (æŒ‘æˆ°å¤±æ•—)";
            endTitle.style.color = "#e74c3c";
        }

        // å¡«å…¥åˆ†æ•¸
        document.getElementById('final-score').textContent = this.player.score;
        // è£œæ»¿æœªå®Œæˆé—œå¡çš„åˆ†æ•¸ç‚º0 (å¦‚æœä¸­é€”å¤±æ•—)
        for(let i=0; i<3; i++) {
            if(!this.player.levelScores[i]) this.player.levelScores[i] = 0;
            document.getElementById(`score-l${i+1}`).textContent = this.player.levelScores[i];
        }
        document.getElementById('final-time').textContent = duration + "s";

        resultScreen.style.display = 'flex';

        // é€å‡ºè³‡æ–™åˆ° GAS
        this.sendDataToGas(duration);
    }

    sendDataToGas(duration) {
        const data = {
            name: this.player.name,
            id: this.player.id,
            totalScore: this.player.score,
            levelScores: this.player.levelScores,
            duration: duration,
            date: new Date().toISOString()
        };

        if (CONFIG.gasUrl.includes("è«‹åœ¨æ­¤å¡«å…¥")) {
            console.log("æœªè¨­å®š GAS URLï¼Œç•¥éä¸Šå‚³");
            return;
        }

        // ä½¿ç”¨ no-cors æ¨¡å¼é¿å…ç€è¦½å™¨æ“‹è·¨åŸŸï¼Œé›–ç„¶æ‹¿ä¸åˆ°å›æ‡‰ï¼Œä½†æ•¸æ“šæœƒé€å‡º
        fetch(CONFIG.gasUrl, {
            method: 'POST',
            mode: 'no-cors', 
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(data)
        }).then(() => {
            console.log("Data sent to GAS");
        }).catch(err => {
            console.error("Upload failed", err);
        });
    }
}

/**
 * å¯¦é«”é¡åˆ¥å®šç¾©
 */
class Enemy {
    constructor(x, y, type, data) {
        this.x = x;
        this.y = y;
        this.type = type; // normal, heavy, boss
        this.hp = data.hp;
        this.maxHp = data.hp;
        this.speed = data.speed;
        this.baseSpeed = data.speed; // ç”¨æ–¼æ¸›é€Ÿé‚„åŸ
        this.reward = data.reward;
        this.color = data.color;
        this.radius = data.radius;
        
        this.pathIndex = 0;
        this.finished = false;
        this.slowTimer = 0; // æ¸›é€Ÿæ•ˆæœè¨ˆæ™‚
    }

    update() {
        // ç‹€æ…‹æ•ˆæœè™•ç†
        if (this.slowTimer > 0) {
            this.slowTimer--;
            this.speed = this.baseSpeed * 0.5;
        } else {
            this.speed = this.baseSpeed;
        }

        // ç§»å‹•é‚è¼¯
        // ç›®æ¨™é»
        const target = Game.pathPixels[this.pathIndex + 1];
        if (!target) {
            this.finished = true;
            return;
        }

        const dx = target.x - this.x;
        const dy = target.y - this.y;
        const dist = Math.hypot(dx, dy);

        if (dist <= this.speed) {
            this.x = target.x;
            this.y = target.y;
            this.pathIndex++;
            if (this.pathIndex >= Game.pathPixels.length - 1) {
                this.finished = true;
            }
        } else {
            this.x += (dx / dist) * this.speed;
            this.y += (dy / dist) * this.speed;
        }
    }

    draw(ctx) {
        // ç•«èº«é«”
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 2;
        ctx.stroke();

        // Qç‰ˆçœ¼ç›
        ctx.fillStyle = 'white';
        ctx.beginPath();
        ctx.arc(this.x - 5, this.y - 2, 4, 0, Math.PI * 2);
        ctx.arc(this.x + 5, this.y - 2, 4, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = 'black';
        ctx.beginPath();
        ctx.arc(this.x - 5, this.y - 2, 2, 0, Math.PI * 2);
        ctx.arc(this.x + 5, this.y - 2, 2, 0, Math.PI * 2);
        ctx.fill();

        // Boss åŠ å€‹çš‡å† 
        if (this.type === 'boss') {
            ctx.fillStyle = 'gold';
            ctx.font = '20px Arial';
            ctx.fillText('ğŸ‘‘', this.x, this.y - 25);
        }

        // è¡€æ¢
        const hpPercent = this.hp / this.maxHp;
        ctx.fillStyle = 'red';
        ctx.fillRect(this.x - 15, this.y - this.radius - 10, 30, 4);
        ctx.fillStyle = '#2ecc71';
        ctx.fillRect(this.x - 15, this.y - this.radius - 10, 30 * hpPercent, 4);
    }
    
    takeDamage(amount) {
        this.hp -= amount;
        if (this.hp <= 0) {
            Game.player.score += Math.floor(this.reward); // å¢åŠ åˆ†æ•¸
            Game.gameState.gold += this.reward; // å¢åŠ é‡‘å¹£
            Game.updateUI();
            
            // å¾é™£åˆ—ç§»é™¤éœ€åœ¨å¤–éƒ¨è¿´åœˆè™•ç†
            const idx = Game.entities.enemies.indexOf(this);
            if (idx > -1) Game.entities.enemies.splice(idx, 1);
        }
    }
}

class Tower {
    constructor(gx, gy, typeKey) {
        this.gx = gx;
        this.gy = gy;
        this.x = gx * CONFIG.gridSize + CONFIG.gridSize/2;
        this.y = gy * CONFIG.gridSize + CONFIG.gridSize/2;
        this.typeKey = typeKey;
        
        const data = TOWER_TYPES[typeKey];
        this.range = data.range * CONFIG.gridSize;
        this.damage = data.damage;
        this.cooldown = data.cooldown;
        this.color = data.color;
        this.cdTimer = 0;
        this.name = data.name;
    }

    update(enemies, game) {
        if (this.cdTimer > 0) this.cdTimer--;

        if (this.cdTimer <= 0) {
            const target = this.findTarget(enemies);
            if (target) {
                this.shoot(target, game);
                this.cdTimer = this.cooldown;
            }
        }
    }

    findTarget(enemies) {
        // æ‰¾ç¯„åœå…§èµ°æœ€å‰é¢çš„æ•µäºº
        let bestTarget = null;
        let maxProgress = -1;

        for (const e of enemies) {
            const dist = Math.hypot(e.x - this.x, e.y - this.y);
            if (dist <= this.range) {
                // pathIndex ä»£è¡¨èµ°äº†å¹¾å€‹é»ï¼Œè¶Šå¾Œé¢ä»£è¡¨è¶Šæ¥è¿‘çµ‚é»
                const progress = e.pathIndex * 1000 + (1000 - Math.hypot(e.x - Game.pathPixels[e.pathIndex+1]?.x || 0, e.y - Game.pathPixels[e.pathIndex+1]?.y || 0));
                
                if (progress > maxProgress) {
                    maxProgress = progress;
                    bestTarget = e;
                }
            }
        }
        return bestTarget;
    }

    shoot(target, game) {
        game.entities.projectiles.push(new Projectile(this.x, this.y, target, this.typeKey));
    }

    draw(ctx) {
        // å¡”åŸºåº§
        ctx.fillStyle = '#bdc3c7';
        ctx.fillRect(this.x - 20, this.y - 20, 40, 40);
        
        // å¡”èº«
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, 15, 0, Math.PI*2);
        ctx.fill();

        // å¡”åœ–ç¤º
        let icon = '';
        if (this.typeKey === 'archer') icon = 'ğŸ¹';
        if (this.typeKey === 'spear') icon = 'ğŸ”±';
        if (this.typeKey === 'mage') icon = 'ğŸ”®';
        if (this.typeKey === 'cannon') icon = 'ğŸ’£';
        
        ctx.font = '20px Arial';
        ctx.fillStyle = 'white';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(icon, this.x, this.y);
    }
}

class Projectile {
    constructor(x, y, target, towerType) {
        this.x = x;
        this.y = y;
        this.target = target; // é–å®šç›®æ¨™
        this.type = towerType;
        
        const tData = TOWER_TYPES[towerType];
        this.speed = tData.projectileSpeed;
        this.damage = tData.damage;
        this.isAoE = tData.type.includes('aoe');
        
        this.hit = false;
        this.outOfBounds = false;
    }

    update() {
        if (!this.target || this.target.hp <= 0) {
            this.hit = true; // ç›®æ¨™æ¶ˆå¤±ï¼Œè¦–ç‚ºæ“Šä¸­æ¶ˆå¤±æˆ–ç„¡æ•ˆ
            return;
        }

        const dx = this.target.x - this.x;
        const dy = this.target.y - this.y;
        const dist = Math.hypot(dx, dy);

        if (dist <= this.speed) {
            this.hitTarget();
        } else {
            this.x += (dx / dist) * this.speed;
            this.y += (dy / dist) * this.speed;
        }
    }

    hitTarget() {
        this.hit = true;
        
        if (this.isAoE) {
            // ç¯„åœå‚·å®³
            const aoeRange = 80;
            Game.entities.enemies.forEach(e => {
                if (Math.hypot(e.x - this.x, e.y - this.y) <= aoeRange) {
                    this.applyDamage(e);
                }
            });
        } else {
            // å–®é«”å‚·å®³
            this.applyDamage(this.target);
        }
    }

    applyDamage(enemy) {
        enemy.takeDamage(this.damage);
        // ç‰¹æ®Šæ•ˆæœ
        if (this.type === 'mage') {
            enemy.slowTimer = 60; // æ¸›é€Ÿ 60 frames (ç´„1ç§’)
        }
    }

    draw(ctx) {
        ctx.fillStyle = 'black';
        ctx.beginPath();
        ctx.arc(this.x, this.y, 4, 0, Math.PI*2);
        ctx.fill();
    }
}

class Particle {
    constructor(x, y, color) {
        this.x = x;
        this.y = y;
        this.color = color;
        this.vx = (Math.random() - 0.5) * 4;
        this.vy = (Math.random() - 0.5) * 4;
        this.life = 1.0;
    }

    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.life -= 0.05;
    }

    draw(ctx) {
        ctx.globalAlpha = Math.max(0, this.life);
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, 3, 0, Math.PI*2);
        ctx.fill();
        ctx.globalAlpha = 1.0;
    }
}

// åˆå§‹åŒ–éŠæˆ²
const Game = new GameEngine();

</script>
</body>
</html>
