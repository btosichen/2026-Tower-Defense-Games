<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>‰∏âÂúãÁ≠ñÁï•ÊîªÈò≤Êà∞ (ËßíËâ≤ÂúñÂÉèÁâà)</title>
    <style>
        :root {
            --primary-color: #f39c12; /* ‰∏âÂúãÈáë */
            --secondary-color: #c0392b; /* Êà∞ÊóóÁ¥Ö */
            --player-color: #2980b9;  /* ÊàëËªçËóç */
            --enemy-color: #c0392b;   /* ÊïµËªçÁ¥Ö */
            --bg-color: #fcf3cf;
            --ui-bg: rgba(255, 255, 255, 0.9);
        }

        body {
            margin: 0;
            padding: 0;
            font-family: "Microsoft JhengHei", "Heiti TC", sans-serif;
            background-color: #2c3e50;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            overflow: hidden;
            user-select: none;
        }

        #game-container {
            position: relative;
            width: 1200px;
            height: 800px;
            background-color: #a9dfbf; /* È†êË®≠ËçâÂú∞Ëâ≤ */
            box-shadow: 0 0 50px rgba(0,0,0,0.8);
            border-radius: 12px;
            overflow: hidden;
            display: none; /* ÁôªÂÖ•ÂæåÈ°ØÁ§∫ */
            cursor: grab;
        }
        
        #game-container:active {
            cursor: grabbing;
        }
        
        @media (max-width: 1220px), (max-height: 820px) {
            #game-container { transform: scale(0.8); }
        }
        @media (max-width: 980px) {
            #game-container { transform: scale(0.6); }
        }

        canvas {
            display: block;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .hud-panel {
            position: absolute;
            background: var(--ui-bg);
            border: 2px solid var(--primary-color);
            border-radius: 8px;
            padding: 8px;
            pointer-events: auto;
            color: #2c3e50;
            font-weight: bold;
            box-shadow: 0 4px 6px rgba(0,0,0,0.2);
            backdrop-filter: blur(4px);
        }

        /* Top Bar */
        #top-bar {
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            height: 50px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 16px;
            border-radius: 25px;
            background: rgba(255, 255, 255, 0.95);
        }

        .hp-bar-container {
            width: 200px;
            height: 16px;
            background: #34495e;
            border-radius: 8px;
            overflow: hidden;
            border: 2px solid #fff;
            position: relative;
            margin: 0 10px;
        }

        .hp-bar-fill {
            height: 100%;
            transition: width 0.2s;
            position: relative;
        }

        /* Camera Controls */
        #cam-controls {
            position: absolute;
            right: 20px;
            top: 80px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            pointer-events: auto;
        }

        .cam-btn {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: 2px solid #fff;
            background: rgba(44, 62, 80, 0.8);
            color: white;
            font-size: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: 0.2s;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }
        .cam-btn:hover { background: var(--primary-color); transform: scale(1.1); }
        .cam-btn:active { transform: scale(0.9); }

        /* Bottom Bar (Unit Selection) */
        #bottom-bar {
            bottom: 15px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 6px;
            padding: 10px 15px;
            width: auto;
            max-width: 95%;
            justify-content: center;
            border-radius: 15px;
            overflow-x: auto; /* Èò≤Ê≠¢ÈÅéÂ§öÊåâÈàïÊ∫¢Âá∫ */
        }

        .unit-btn {
            width: 75px;
            height: 95px;
            border: 2px solid #95a5a6;
            border-radius: 8px;
            background: linear-gradient(to bottom, #fff, #ecf0f1);
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: all 0.1s;
            position: relative;
            box-shadow: 0 4px 0 #7f8c8d;
            overflow: hidden;
            flex-shrink: 0;
        }

        .unit-btn:active { transform: translateY(4px); box-shadow: 0 2px 0 #7f8c8d; }
        
        .unit-btn.disabled { 
            filter: grayscale(100%); 
            opacity: 0.6; 
            cursor: not-allowed; 
            background: #bdc3c7; 
        }
        
        /* ÁâπÂà•Ê®ôË®ªÂ§ßÂ∞áËªçÁöÑÊ®£Âºè */
        .unit-btn[id="btn-general"] {
            border-color: gold;
            background: linear-gradient(to bottom, #fcf3cf, #f9e79f);
        }

        .unit-img-preview {
            width: 40px;
            height: 40px;
            object-fit: contain;
            margin-bottom: 2px;
        }

        .unit-name { font-size: 11px; font-weight: 800; color: #2c3e50; }
        .unit-cost { 
            background: gold; color: #d35400; padding: 1px 4px; 
            border-radius: 4px; font-size: 11px; border: 1px solid #e67e22;
            margin-top: 2px; font-weight: bold;
        }
        .hotkey { position: absolute; top: 2px; right: 5px; font-size: 9px; color: #7f8c8d; }
        
        .limit-badge {
            position: absolute;
            top: 2px; left: 2px;
            background: #c0392b; color: white;
            font-size: 9px; padding: 1px 3px;
            border-radius: 4px;
            display: none;
        }

        /* Screens */
        #login-screen, #result-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(44, 62, 80, 0.98);
            display: flex; flex-direction: column;
            justify-content: center; align-items: center;
            color: white; z-index: 100;
        }
        .panel-box {
            background: #fff; padding: 40px; border-radius: 20px;
            text-align: center; color: #2c3e50;
            border: 6px solid var(--primary-color);
            width: 450px;
            box-shadow: 0 20px 50px rgba(0,0,0,0.5);
        }
        input {
            padding: 15px; font-size: 20px; width: 80%;
            margin: 20px 0; text-align: center; border: 2px solid #bdc3c7; border-radius: 8px;
        }
        button.start-btn {
            background: var(--secondary-color); color: white; border: none;
            padding: 15px 50px; font-size: 24px; border-radius: 40px;
            cursor: pointer; transition: 0.3s; box-shadow: 0 6px 0 #922b21;
        }
        button.start-btn:hover { transform: translateY(-3px); box-shadow: 0 9px 0 #922b21; }

        #message-area {
            position: absolute; top: 40%; left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.85); color: #fff;
            padding: 15px 40px; border-radius: 50px;
            font-size: 28px; font-weight: bold;
            display: none; pointer-events: none;
            z-index: 50; border: 3px solid gold;
        }
    </style>
</head>
<body>

    <div id="login-screen">
        <div class="panel-box">
            <h1 style="font-size: 48px; margin-bottom: 20px;">‚öîÔ∏è ‰∏âÂúãÁ≠ñÁï•ÊîªÈò≤Êà∞</h1>
            <p style="font-size: 18px; color: #7f8c8d;">ÂÖ®ËßíËâ≤ÁôªÂ†¥„Éª3DËá™Áî±Ë¶ñËßí</p>
            <input type="text" id="player-name" placeholder="Ë´ãËº∏ÂÖ•Â∞áËªçÂ§ßÂêç" maxlength="10">
            <button class="start-btn" onclick="Game.initLogin()">Âá∫ÂæÅ</button>
            <p id="loading-text" style="color: #e67e22; font-size: 12px; margin-top: 10px;">Ê≠£Âú®ÂæµÂè¨ÂÖµÈ¶¨ (ËºâÂÖ•ÂúñÁâá)...</p>
        </div>
    </div>

    <div id="game-container">
        <canvas id="gameCanvas" width="1200" height="800"></canvas>
        
        <div id="ui-layer">
            <div id="top-bar" class="hud-panel">
                <div style="display:flex; align-items:center;">
                    <span style="color:var(--enemy-color); margin-right:5px;">üö© ÊïµÁáü</span>
                    <div class="hp-bar-container">
                        <div id="enemy-hp-bar" class="hp-bar-fill" style="width: 100%; background: linear-gradient(to right, #e74c3c, #c0392b);"></div>
                    </div>
                    <span id="enemy-stats-hint" style="font-size:12px;color:#e74c3c; margin-left:5px;"></span>
                </div>

                <div style="text-align:center; min-width: 150px;">
                    <div id="wave-info" style="font-size:20px; color:var(--primary-color); font-weight:900;">Á¨¨ 1 Èóú</div>
                    <div style="font-size:16px;">üí∞ <span id="gold" style="color:#d35400;">0</span></div>
                </div>

                <div style="display:flex; align-items:center;">
                    <span style="color:var(--player-color); margin-right:5px;">üõ°Ô∏è ÊàëÂüé</span>
                    <div class="hp-bar-container">
                        <div id="player-hp-bar" class="hp-bar-fill" style="width: 100%; background: linear-gradient(to right, #3498db, #2980b9);"></div>
                    </div>
                </div>
            </div>

            <!-- Èè°È†≠ÊéßÂà∂Èù¢Êùø -->
            <div id="cam-controls">
                <div class="cam-btn" onclick="Game.camera.zoomIn()" title="ÊîæÂ§ß (+)">‚ûï</div>
                <div class="cam-btn" onclick="Game.camera.zoomOut()" title="Á∏ÆÂ∞è (-)">‚ûñ</div>
                <div class="cam-btn" onclick="Game.camera.rotate(-0.1)" title="Â∑¶ÊóãËΩâ (Q)">‚Ü∫</div>
                <div class="cam-btn" onclick="Game.camera.rotate(0.1)" title="Âè≥ÊóãËΩâ (E)">‚Üª</div>
                <div class="cam-btn" onclick="Game.camera.reset()" title="ÈáçÁΩÆË¶ñËßí (R)">üéØ</div>
            </div>

            <div id="message-area">Êà∞È¨•ÈñãÂßãÔºÅ</div>

            <div id="bottom-bar" class="hud-panel"></div>
        </div>
    </div>

    <div id="result-screen" style="display: none;">
        <div class="panel-box">
            <h1 id="end-title" style="font-size: 48px;">Êà∞ÂΩπÁµêÊùü</h1>
            <p id="end-reason" style="font-size: 20px; color: #555;">...</p>
            <div style="text-align:left; margin: 30px 0; font-size: 20px; background: #f9f9f9; padding: 20px; border-radius: 10px;">
                <div style="margin-bottom: 10px;">üèÖ Á∏ΩÂàÜÔºö<span id="final-score" style="font-weight:bold; color:var(--primary-color);">0</span></div>
                <div>‚è±Ô∏è ËÄóÊôÇÔºö<span id="final-time" style="font-weight:bold;">0s</span></div>
            </div>
            <button class="start-btn" onclick="location.reload()">ÂÜçÊà∞‰∏ÄÂ†¥</button>
        </div>
    </div>

<script>
/**
 * ÂúñÁâáË≥áÊ∫êÁÆ°ÁêÜ
 * ‰ΩøÁî® GitHub Raw ÈÄ£Áµê
 */
const ASSETS = {
    player: {
        castle: "https://raw.githubusercontent.com/btosichen/2026-Tower-Defense-Games/ac4b7a1f6d922e4765e29eef26384cd26bd7afd8/logo-1-0%20(90%20x%2090%20%E5%83%8F%E7%B4%A0).png",
        sword: "https://raw.githubusercontent.com/btosichen/2026-Tower-Defense-Games/ac4b7a1f6d922e4765e29eef26384cd26bd7afd8/logo-1-1%20(50%20x%2050%20%E5%83%8F%E7%B4%A0).png",
        bow: "https://raw.githubusercontent.com/btosichen/2026-Tower-Defense-Games/ac4b7a1f6d922e4765e29eef26384cd26bd7afd8/logo-1-2(50%20x%2050%20%E5%83%8F%E7%B4%A0).png",
        spear: "https://raw.githubusercontent.com/btosichen/2026-Tower-Defense-Games/ac4b7a1f6d922e4765e29eef26384cd26bd7afd8/logo-1-3(50%20x%2050%20%E5%83%8F%E7%B4%A0).png",
        cavalry: "https://raw.githubusercontent.com/btosichen/2026-Tower-Defense-Games/ac4b7a1f6d922e4765e29eef26384cd26bd7afd8/logo-1-4(50%20x%2050%20%E5%83%8F%E7%B4%A0).png",
        vanguard: "https://raw.githubusercontent.com/btosichen/2026-Tower-Defense-Games/ac4b7a1f6d922e4765e29eef26384cd26bd7afd8/logo-1-5(50%20x%2050%20%E5%83%8F%E7%B4%A0).png",
        vice: "https://raw.githubusercontent.com/btosichen/2026-Tower-Defense-Games/ac4b7a1f6d922e4765e29eef26384cd26bd7afd8/logo-1-6(50%20x%2050%20%E5%83%8F%E7%B4%A0).png",
        general: "https://raw.githubusercontent.com/btosichen/2026-Tower-Defense-Games/ac4b7a1f6d922e4765e29eef26384cd26bd7afd8/logo-1-7(50%20x%2050%20%E5%83%8F%E7%B4%A0).png",
        advisor: "https://raw.githubusercontent.com/btosichen/2026-Tower-Defense-Games/ac4b7a1f6d922e4765e29eef26384cd26bd7afd8/logo-1-8(50%20x%2050%20%E5%83%8F%E7%B4%A0).png"
    },
    enemy: {
        castle: "https://raw.githubusercontent.com/btosichen/2026-Tower-Defense-Games/ac4b7a1f6d922e4765e29eef26384cd26bd7afd8/logo-2-0%20(90%20x%2090%20%E5%83%8F%E7%B4%A0).png",
        sword: "https://raw.githubusercontent.com/btosichen/2026-Tower-Defense-Games/ac4b7a1f6d922e4765e29eef26384cd26bd7afd8/logo-2-1(50%20x%2050%20%E5%83%8F%E7%B4%A0).png",
        bow: "https://raw.githubusercontent.com/btosichen/2026-Tower-Defense-Games/ac4b7a1f6d922e4765e29eef26384cd26bd7afd8/logo-2-2(50%20x%2050%20%E5%83%8F%E7%B4%A0).png",
        spear: "https://raw.githubusercontent.com/btosichen/2026-Tower-Defense-Games/ac4b7a1f6d922e4765e29eef26384cd26bd7afd8/logo-2-3(50%20x%2050%20%E5%83%8F%E7%B4%A0).png",
        cavalry: "https://raw.githubusercontent.com/btosichen/2026-Tower-Defense-Games/ac4b7a1f6d922e4765e29eef26384cd26bd7afd8/logo-2-4(50%20x%2050%20%E5%83%8F%E7%B4%A0).png",
        vanguard: "https://raw.githubusercontent.com/btosichen/2026-Tower-Defense-Games/ac4b7a1f6d922e4765e29eef26384cd26bd7afd8/logo-2-5(50%20x%2050%20%E5%83%8F%E7%B4%A0).png",
        vice: "https://raw.githubusercontent.com/btosichen/2026-Tower-Defense-Games/ac4b7a1f6d922e4765e29eef26384cd26bd7afd8/logo-2-6(50%20x%2050%20%E5%83%8F%E7%B4%A0).png",
        general: "https://raw.githubusercontent.com/btosichen/2026-Tower-Defense-Games/ac4b7a1f6d922e4765e29eef26384cd26bd7afd8/logo-2-7(50%20x%2050%20%E5%83%8F%E7%B4%A0).png",
        advisor: "https://raw.githubusercontent.com/btosichen/2026-Tower-Defense-Games/ac4b7a1f6d922e4765e29eef26384cd26bd7afd8/logo-2-8(50%20x%2050%20%E5%83%8F%E7%B4%A0).png"
    },
    images: {} // ËºâÂÖ•ÂæåÁöÑÂúñÁâáÁâ©‰ª∂
};

const ImageLoader = {
    loadAll: function(callback) {
        let loaded = 0;
        const total = 18; // 2 castles + 8 units * 2 teams
        const checkLoad = () => {
            loaded++;
            if (loaded >= total && callback) callback();
        };

        // ËºâÂÖ•Áé©ÂÆ∂ÂúñÁâá
        for (let key in ASSETS.player) {
            const img = new Image();
            img.src = ASSETS.player[key];
            img.onload = checkLoad;
            img.onerror = checkLoad; // Âç≥‰ΩøÂ§±Êïó‰πüÁπºÁ∫åÔºåÈÅøÂÖçÂç°Ê≠ª
            ASSETS.images[`p_${key}`] = img;
        }
        // ËºâÂÖ•Êïµ‰∫∫ÂúñÁâá
        for (let key in ASSETS.enemy) {
            const img = new Image();
            img.src = ASSETS.enemy[key];
            img.onload = checkLoad;
            img.onerror = checkLoad;
            ASSETS.images[`e_${key}`] = img;
        }
    }
};

/**
 * Èü≥ÊïàÁÆ°ÁêÜÂô®
 */
const AudioSys = {
    ctx: null,
    init: function() {
        if (!this.ctx) {
            this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        }
        if (this.ctx.state === 'suspended') this.ctx.resume();
    },
    playTone: function(freq, type, duration, vol = 0.1) {
        if (!this.ctx) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
        gain.gain.setValueAtTime(vol, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.start();
        osc.stop(this.ctx.currentTime + duration);
    },
    sfx: {
        spawn: () => AudioSys.playTone(400, 'triangle', 0.1, 0.1),
        attack_melee: () => AudioSys.playTone(100, 'sawtooth', 0.1, 0.05),
        attack_range: () => AudioSys.playTone(800, 'sine', 0.1, 0.05),
        hit: () => AudioSys.playTone(150, 'square', 0.1, 0.05),
        spell: () => { if(AudioSys.ctx) [600, 500, 400].forEach((f, i) => setTimeout(() => AudioSys.playTone(f, 'sine', 0.3, 0.1), i * 100)); },
        win_level: () => { if(AudioSys.ctx) [440, 554, 659].forEach((f, i) => setTimeout(() => AudioSys.playTone(f, 'square', 0.4, 0.1), i * 100)); },
        game_over: () => { if(AudioSys.ctx) [300, 250, 200].forEach((f, i) => setTimeout(() => AudioSys.playTone(f, 'sawtooth', 0.5, 0.1), i * 300)); }
    }
};

class Camera {
    constructor(width, height) {
        this.width = width;
        this.height = height;
        this.x = width / 2;
        this.y = height / 2;
        this.zoom = 1;
        this.angle = 0; 
        this.dragStart = null;
    }
    toScreen(x, y) {
        let dx = x - this.x;
        let dy = y - this.y;
        let cos = Math.cos(this.angle);
        let sin = Math.sin(this.angle);
        let rx = dx * cos - dy * sin;
        let ry = dx * sin + dy * cos;
        return {
            x: this.width / 2 + rx * this.zoom,
            y: this.height / 2 + ry * this.zoom,
            scale: this.zoom
        };
    }
    zoomIn() { this.zoom = Math.min(this.zoom * 1.1, 3); }
    zoomOut() { this.zoom = Math.max(this.zoom / 1.1, 0.5); }
    rotate(rad) { this.angle += rad; }
    reset() { this.zoom = 1; this.angle = 0; this.x = this.width/2; this.y = this.height/2; }
    
    handleMouseDown(e) { this.dragStart = { x: e.clientX, y: e.clientY, camX: this.x, camY: this.y }; }
    handleMouseMove(e) {
        if (!this.dragStart) return;
        const dx = (e.clientX - this.dragStart.x) / this.zoom;
        const dy = (e.clientY - this.dragStart.y) / this.zoom;
        let cos = Math.cos(-this.angle);
        let sin = Math.sin(-this.angle);
        this.x = this.dragStart.camX - (dx * cos - dy * sin);
        this.y = this.dragStart.camY - (dx * sin + dy * cos);
    }
    handleMouseUp() { this.dragStart = null; }
    handleWheel(e) { e.preventDefault(); if (e.deltaY < 0) this.zoomIn(); else this.zoomOut(); }
}

const CONFIG = {
    gridSize: 80, 
    width: 15, height: 10,
    gasUrl: 'https://script.google.com/macros/s/AKfycbwqZFv8Jzk4A1ERYbzljRudebPBTlBn4OcSsFWfWBGLTIKGSMDEd3focinsGovte4c9/exec'
};

// ÂÖµÁ®ÆÂÆöÁæ©Êõ¥Êñ∞
const UNIT_TYPES = {
    sword:    { name: 'ÂàÄÂÖµ',   cost: 50,  hp: 120, atk: 15, range: 40,  speed: 2.5, type: 'melee', cd: 60 },
    bow:      { name: 'ÂºìÂÖµ',   cost: 120, hp: 80,  atk: 25, range: 250, speed: 2.5, type: 'ranged', cd: 80 },
    spear:    { name: 'ÊßçÂÖµ',   cost: 200, hp: 180, atk: 40, range: 70,  speed: 2.0, type: 'melee', cd: 100 },
    cavalry:  { name: 'È®éÂÖµ',   cost: 280, hp: 220, atk: 45, range: 40,  speed: 5.0, type: 'melee', cd: 120 }, // Êñ∞Â¢û: Âø´ÈÄüÁ™ÅÊìä
    vanguard: { name: 'ÂâçÈãí',   cost: 350, hp: 300, atk: 55, range: 40,  speed: 3.5, type: 'melee', cd: 150 },
    vice:     { name: 'ÂâØÂ∞áËªç', cost: 500, hp: 600, atk: 70, range: 50,  speed: 1.5, type: 'melee', cd: 300 },
    advisor:  { name: 'ÂúãÂ∏´',   cost: 800, hp: 200, atk: 100, range: 300, speed: 1.5, type: 'magic', cd: 400 }, // Êñ∞Â¢û: È´òÂÇ∑ÈÅ†Á®ã
    general:  { name: 'Â§ßÂ∞áËªç', cost: 1500, hp: 2000,atk: 200, range: 60, speed: 1.2, type: 'melee', cd: 600, limit: 1 } // Êõ¥Êñ∞: ÈôêÂà∂1Èöª
};

const MAPS = [
    [{x:0,y:2}, {x:3,y:2}, {x:3,y:7}, {x:8,y:7}, {x:8,y:2}, {x:12,y:2}, {x:12,y:6}, {x:14,y:6}],
    [{x:0,y:1}, {x:2,y:1}, {x:2,y:8}, {x:12,y:8}, {x:12,y:1}, {x:14,y:1}],
    [{x:0,y:8}, {x:2,y:8}, {x:2,y:2}, {x:5,y:2}, {x:5,y:8}, {x:8,y:8}, {x:8,y:2}, {x:11,y:2}, {x:11,y:8}, {x:14,y:8}],
    [{x:0,y:5}, {x:4,y:5}, {x:4,y:3}, {x:10,y:3}, {x:10,y:6}, {x:14,y:6}],
    [{x:0,y:0}, {x:13,y:0}, {x:13,y:8}, {x:2,y:8}, {x:2,y:3}, {x:10,y:3}, {x:10,y:5}, {x:14,y:5}],
    [{x:0,y:9}, {x:3,y:9}, {x:3,y:6}, {x:6,y:6}, {x:6,y:3}, {x:9,y:3}, {x:9,y:0}, {x:14,y:0}],
    [{x:0,y:2}, {x:14,y:2}, {x:14,y:5}, {x:0,y:5}, {x:0,y:8}, {x:14,y:8}],
    [{x:0,y:1}, {x:6,y:1}, {x:6,y:5}, {x:8,y:5}, {x:8,y:9}, {x:14,y:9}],
    [{x:0,y:4}, {x:1,y:4}, {x:1,y:9}, {x:13,y:9}, {x:13,y:1}, {x:1,y:1}, {x:1,y:4}, {x:14,y:4}],
    [{x:0,y:0}, {x:0,y:9}, {x:3,y:9}, {x:3,y:2}, {x:6,y:2}, {x:6,y:7}, {x:9,y:7}, {x:9,y:1}, {x:12,y:1}, {x:12,y:8}, {x:14,y:8}]
];

const LEVELS = Array.from({length: 10}, (_, i) => ({
    enemySpawnRate: Math.max(60, 180 - i * 12),
    goldRate: 1 + i * 0.5,
    enemyTypes: i < 1 ? ['sword', 'sword', 'spear'] :
                i < 3 ? ['sword', 'bow', 'spear', 'cavalry'] :
                i < 6 ? ['spear', 'bow', 'cavalry', 'vanguard', 'vice'] :
                i < 8 ? ['vanguard', 'vice', 'advisor'] :
                        ['vice', 'advisor', 'general'], // ÂæåÊúüÂá∫ÁèæÂ§ßÂ∞áËªç
    statsMultiplier: 1 + i,
    speedMultiplier: 1 + (i * 0.1)
}));

class GameEngine {
    constructor() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.player = { name: '', id: '', score: 0 };
        this.camera = new Camera(1200, 800);
        
        this.gameState = {
            level: 0, gold: 0,
            baseHpPlayer: 1000, baseHpEnemy: 1000, maxBaseHp: 1000,
            isGameOver: false, enemySpawnTimer: 0, isLevelTransitioning: false,
            // ÂñÆ‰ΩçË®àÊï∏Âô® (ÁõÆÂâçÂ†¥‰∏äË©≤ÂÖµÁ®ÆÊï∏Èáè)
            playerUnitCounts: {} 
        };

        this.units = []; this.projectiles = []; this.particles = []; this.pathPixels = [];
        this.lastTime = 0;
        this.cooldowns = {}; 
        
        // ÂÖàËºâÂÖ•ÂúñÁâáÂÜçÂª∫Á´ãÊåâÈàï
        ImageLoader.loadAll(() => {
            document.getElementById('loading-text').innerText = "ÂúñÁâáËºâÂÖ•ÂÆåÊàêÔºåË´ãÈªûÊìäÂá∫ÂæÅÔºÅ";
            this.createUnitButtons();
        });

        const container = document.getElementById('game-container');
        container.addEventListener('mousedown', e => this.camera.handleMouseDown(e));
        window.addEventListener('mousemove', e => this.camera.handleMouseMove(e));
        window.addEventListener('mouseup', () => this.camera.handleMouseUp());
        container.addEventListener('wheel', e => this.camera.handleWheel(e));
        
        document.addEventListener('keydown', e => {
            if (e.key === 'q' || e.key === 'Q') this.camera.rotate(-0.1);
            if (e.key === 'e' || e.key === 'E') this.camera.rotate(0.1);
            if (e.key === 'r' || e.key === 'R') this.camera.reset();
        });
    }

    createUnitButtons() {
        const bar = document.getElementById('bottom-bar');
        bar.innerHTML = '';
        const keys = Object.keys(UNIT_TYPES);
        this.cooldowns = {}; // Reset
        
        keys.forEach((key, index) => {
            const u = UNIT_TYPES[key];
            const div = document.createElement('div');
            div.className = 'unit-btn';
            div.id = `btn-${key}`;
            div.onclick = () => this.spawnPlayerUnit(key);
            
            // ‰ΩøÁî®È†êË¶ΩÂúñ
            const imgSrc = ASSETS.player[key];
            
            div.innerHTML = `
                <span class="hotkey">${index+1}</span>
                <div class="limit-badge" id="limit-${key}">Èôê1</div>
                <img src="${imgSrc}" class="unit-img-preview">
                <div class="unit-name">${u.name}</div>
                <div class="unit-cost">$${u.cost}</div>
                <div class="cooldown-overlay" style="position:absolute;bottom:0;left:0;width:100%;height:0%;background:rgba(0,0,0,0.5);transition:height 0.1s;"></div>
            `;
            bar.appendChild(div);
            this.cooldowns[key] = 0;
            this.gameState.playerUnitCounts[key] = 0;
            
            // Â¶ÇÊûúÊúâÈôêÂà∂ÔºåÈ°ØÁ§∫Ê®ôÁ±§
            if (u.limit) {
                div.querySelector('.limit-badge').style.display = 'block';
            }
        });
        
        // ÁßªÈô§ËàäÁöÑ event listener ÈÅøÂÖçÈáçË§áÁ∂ÅÂÆö (ÈÄôÂú®Á∞°ÂñÆÁØÑ‰æã‰∏≠ÈÄöÂ∏∏‰∏çËôïÁêÜÔºå‰ΩÜÂö¥Ë¨πÈªûÂ•Ω)
        // ÈÄôË£°Á∞°ÂåñÔºåÂÅáË®≠Âè™Âü∑Ë°å‰∏ÄÊ¨° init
        document.addEventListener('keydown', (e) => {
            const idx = parseInt(e.key) - 1;
            if (idx >= 0 && idx < keys.length) this.spawnPlayerUnit(keys[idx]);
        });
    }

    initLogin() {
        const name = document.getElementById('player-name').value.trim();
        if (!name) return alert("Ë´ãËº∏ÂÖ•Â§ßÂêçÔºÅ");
        this.player.name = name; this.player.id = 'ID_' + Date.now(); this.player.startTime = Date.now();
        AudioSys.init();
        document.getElementById('login-screen').style.display = 'none';
        document.getElementById('game-container').style.display = 'block';
        this.startLevel(0);
        this.gameLoop(0);
    }

    startLevel(lvl) {
        this.gameState.isLevelTransitioning = false;
        if (lvl >= LEVELS.length) { AudioSys.sfx.win_level(); return this.endGame(true, "Â§©‰∏ãÁµ±‰∏ÄÔºÅ‰∏âÂúãÊ≠∏‰∏ÄÔºÅ"); }
        
        this.gameState.level = lvl;
        this.camera.reset(); 
        
        const mapPoints = MAPS[lvl % MAPS.length];
        this.pathPixels = mapPoints.map(p => ({
            x: p.x * CONFIG.gridSize + CONFIG.gridSize/2,
            y: p.y * CONFIG.gridSize + CONFIG.gridSize/2
        }));

        const lvlConfig = LEVELS[lvl];
        this.gameState.maxBaseHp = 1000 + (lvl * 1000); 
        this.gameState.baseHpEnemy = this.gameState.maxBaseHp * lvlConfig.statsMultiplier; 
        this.gameState.baseHpPlayer = 1000 + (lvl * 200);
        
        if (lvl === 0) this.gameState.gold = 1000; // ÂàùÂßãÈáëÈå¢Â¢ûÂä†‰ª•‰æøÊ∏¨Ë©¶Êñ∞ÂÖµÁ®Æ
        else {
            const bonus = 1000 + (lvl * 500);
            this.gameState.gold += bonus;
            this.showMessage(`Áç≤ÂæóÂá±ÊóãÁçéÈáë $${bonus}ÔºÅ`, false);
        }

        this.units = []; this.projectiles = []; this.particles = []; this.gameState.enemySpawnTimer = 0;
        // ÈáçÁΩÆÂñÆ‰ΩçË®àÊï∏
        for(let k in this.gameState.playerUnitCounts) this.gameState.playerUnitCounts[k] = 0;
        
        this.updateUI();
        document.getElementById('enemy-stats-hint').innerText = `(Âº∑Â∫¶: ${Math.round(lvlConfig.statsMultiplier * 100)}%)`;
        setTimeout(() => { AudioSys.sfx.win_level(); this.showMessage(`Á¨¨ ${lvl+1} Èóú - ÈÄ≤ÊîªÔºÅ`); }, 500);
    }

    spawnPlayerUnit(typeKey) {
        if (this.gameState.isLevelTransitioning || this.gameState.isGameOver) return;
        const data = UNIT_TYPES[typeKey];
        
        // Ê™¢Êü•ÈáëÈå¢
        if (this.gameState.gold < data.cost) return this.showMessage("ËªçË≤ª‰∏çË∂≥", true);
        // Ê™¢Êü•ÂÜ∑Âçª
        if (this.cooldowns[typeKey] > 0) return;
        // Ê™¢Êü•Êï∏ÈáèÈôêÂà∂
        if (data.limit && (this.gameState.playerUnitCounts[typeKey] || 0) >= data.limit) {
            return this.showMessage(`Êà∞Â†¥Âè™ËÉΩÊúâ‰∏Ä‰Ωç${data.name}ÔºÅ`, true);
        }

        this.gameState.gold -= data.cost; 
        this.cooldowns[typeKey] = data.cd; 
        this.gameState.playerUnitCounts[typeKey] = (this.gameState.playerUnitCounts[typeKey] || 0) + 1;
        
        AudioSys.sfx.spawn();
        const startNode = this.pathPixels[this.pathPixels.length - 1];
        this.units.push(new Unit(startNode.x, startNode.y, 'player', typeKey, this.pathPixels.length - 1, 1, 1));
        this.updateUI();
    }

    spawnEnemyUnit() {
        if (this.gameState.isLevelTransitioning) return;
        const lvlData = LEVELS[this.gameState.level];
        const types = lvlData.enemyTypes;
        const randType = types[Math.floor(Math.random() * types.length)];
        
        // ÊïµÊñπÂ§ßÂ∞áËªç‰πüË¶ÅÊ™¢Êü•ÈôêÂà∂ÂóéÔºüÁ®çÂæÆÊîæÂØ¨ÔºåËÆìÈõªËÖ¶Èö®Ê©üÂá∫ÔºåÂ¢ûÂä†Èõ£Â∫¶
        
        const startNode = this.pathPixels[0];
        this.units.push(new Unit(startNode.x, startNode.y, 'enemy', randType, 0, lvlData.statsMultiplier, lvlData.speedMultiplier));
    }

    gameLoop(timestamp) {
        if (this.gameState.isGameOver) return;
        if (!this.lastTime) this.lastTime = timestamp;
        const dt = timestamp - this.lastTime;
        if (dt > 16) { this.update(); this.draw(); this.lastTime = timestamp; }
        requestAnimationFrame((t) => this.gameLoop(t));
    }

    update() {
        const lvlData = LEVELS[this.gameState.level];
        if (!this.gameState.isLevelTransitioning) {
            this.gameState.gold += lvlData.goldRate * 0.5; 
            if (this.gameState.gold > 50000) this.gameState.gold = 50000;
        }

        this.gameState.enemySpawnTimer++;
        if (this.gameState.enemySpawnTimer > lvlData.enemySpawnRate) {
            this.spawnEnemyUnit();
            this.gameState.enemySpawnTimer = 0;
        }

        for (let key in this.cooldowns) {
            if (this.cooldowns[key] > 0) this.cooldowns[key]--;
            const btn = document.getElementById(`btn-${key}`);
            if(btn) {
                const overlay = btn.querySelector('.cooldown-overlay');
                const percent = (this.cooldowns[key] / UNIT_TYPES[key].cd) * 100;
                overlay.style.height = `${percent}%`;
                
                const data = UNIT_TYPES[key];
                const isLimited = data.limit && (this.gameState.playerUnitCounts[key] || 0) >= data.limit;
                
                if((percent <= 0 && this.gameState.gold < data.cost) || isLimited) {
                    btn.classList.add('disabled');
                } else {
                    btn.classList.remove('disabled');
                }
            }
        }

        this.units.sort((a, b) => a.y - b.y);
        for (let i = this.units.length - 1; i >= 0; i--) {
            const u = this.units[i];
            u.update(this);
            if (u.dead) {
                // Ê∏õÂ∞ëË®àÊï∏
                if (u.team === 'player' && this.gameState.playerUnitCounts[u.typeKey] > 0) {
                    this.gameState.playerUnitCounts[u.typeKey]--;
                }
                
                this.units.splice(i, 1);
                if (u.team === 'enemy') {
                    this.gameState.gold += UNIT_TYPES[u.typeKey].cost * 0.3 * lvlData.statsMultiplier;
                    this.player.score += 10 * (this.gameState.level + 1);
                }
            }
        }

        for (let i = this.projectiles.length - 1; i >= 0; i--) {
            const p = this.projectiles[i];
            p.update();
            if (p.hit) this.projectiles.splice(i, 1);
        }

        this.particles = this.particles.filter(p => p.life > 0);
        this.particles.forEach(p => p.update());
        this.updateUI();

        if (this.gameState.baseHpPlayer <= 0 && !this.gameState.isGameOver) {
            AudioSys.sfx.game_over(); this.endGame(false, "ÂüéÊ±†Èô∑ËêΩÔºåÂãùÊïó‰πÉÂÖµÂÆ∂Â∏∏‰∫ã...");
        }
        if (this.gameState.baseHpEnemy <= 0 && !this.gameState.isLevelTransitioning) {
            this.gameState.baseHpEnemy = 0; this.gameState.isLevelTransitioning = true;
            AudioSys.sfx.win_level(); this.showMessage("ÊïµÁáüÊîªÁ†¥ÔºÅÂÖ®ËªçÊï¥ÂÇô...", false);
            this.units.forEach(u => u.state = 'move');
            setTimeout(() => { this.startLevel(this.gameState.level + 1); }, 3000);
        }
    }

    draw() {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        
        this.drawGrid();
        this.drawPath();

        const start = this.pathPixels[0];
        const end = this.pathPixels[this.pathPixels.length-1];
        
        // Áπ™Ë£ΩÂü∫Âú∞ (ÊîπÁî®ÂúñÁâá)
        this.drawCastle(start.x, start.y, 'enemy', `ÊïµÁáü Lv.${this.gameState.level+1}`);
        this.drawCastle(end.x, end.y, 'player', "ÊàëÂüé");

        this.units.forEach(u => u.draw(this.ctx, this.camera));
        this.projectiles.forEach(p => p.draw(this.ctx, this.camera));
        this.particles.forEach(p => p.draw(this.ctx, this.camera));
    }

    drawGrid() {
        // Á∞°ÂåñÁ∂≤Ê†ºËÉåÊôØ
        const p1 = this.camera.toScreen(0, 0);
        const p2 = this.camera.toScreen(1200, 0);
        const p3 = this.camera.toScreen(1200, 800);
        const p4 = this.camera.toScreen(0, 800);
        
        this.ctx.strokeStyle = "rgba(0,0,0,0.1)";
        this.ctx.lineWidth = 2;
        this.ctx.beginPath();
        this.ctx.moveTo(p1.x, p1.y); this.ctx.lineTo(p2.x, p2.y);
        this.ctx.lineTo(p3.x, p3.y); this.ctx.lineTo(p4.x, p4.y);
        this.ctx.closePath();
        this.ctx.stroke();
        this.ctx.fillStyle = "rgba(169, 223, 191, 0.3)";
        this.ctx.fill();
    }

    drawPath() {
        this.ctx.lineCap = 'round'; this.ctx.lineJoin = 'round';
        this.ctx.lineWidth = 70 * this.camera.zoom;
        this.ctx.strokeStyle = '#e6d0ce'; 
        this.ctx.beginPath();
        if (this.pathPixels.length > 0) {
            const start = this.camera.toScreen(this.pathPixels[0].x, this.pathPixels[0].y);
            this.ctx.moveTo(start.x, start.y);
            for (let i = 1; i < this.pathPixels.length; i++) {
                const p = this.camera.toScreen(this.pathPixels[i].x, this.pathPixels[i].y);
                this.ctx.lineTo(p.x, p.y);
            }
        }
        this.ctx.stroke();
    }

    drawCastle(wx, wy, type, label) {
        const pos = this.camera.toScreen(wx, wy);
        const s = pos.scale;
        
        // Èô∞ÂΩ±
        this.ctx.fillStyle = "rgba(0,0,0,0.3)";
        this.ctx.beginPath();
        this.ctx.ellipse(pos.x, pos.y, 40 * s, 20 * s, 0, 0, Math.PI * 2);
        this.ctx.fill();

        // ÂúñÁâá
        const imgKey = type === 'player' ? 'p_castle' : 'e_castle';
        const img = ASSETS.images[imgKey];
        if (img) {
            const size = 100 * s;
            // ËÆìÂüéÂ†°Á´ãÂú®Èªû‰∏ä (yËª∏Âêë‰∏äÂÅèÁßª)
            this.ctx.drawImage(img, pos.x - size/2, pos.y - size, size, size);
        } else {
            // Fallback
            this.ctx.fillStyle = type === 'player' ? 'blue' : 'red';
            this.ctx.fillRect(pos.x - 20*s, pos.y - 40*s, 40*s, 40*s);
        }

        // ÊñáÂ≠ó
        this.drawText(pos.x, pos.y - 110 * s, label, `${20 * s}px Arial`, "#fff");
    }

    drawText(x, y, text, font, color) {
        this.ctx.font = font; this.ctx.fillStyle = color;
        this.ctx.textAlign = "center"; this.ctx.shadowColor = "rgba(0,0,0,0.8)";
        this.ctx.shadowBlur = 4; this.ctx.fillText(text, x, y); this.ctx.shadowBlur = 0;
    }

    updateUI() {
        document.getElementById('gold').innerText = Math.floor(this.gameState.gold);
        document.getElementById('wave-info').innerText = `Á¨¨ ${this.gameState.level + 1} Èóú`;
        const pPct = Math.max(0, (this.gameState.baseHpPlayer / (1000 + this.gameState.level * 200)) * 100);
        document.getElementById('player-hp-bar').style.width = `${pPct}%`;
        const enemyMaxHp = (1000 + (this.gameState.level * 1000)) * LEVELS[this.gameState.level].statsMultiplier;
        const ePct = Math.max(0, (this.gameState.baseHpEnemy / enemyMaxHp) * 100);
        document.getElementById('enemy-hp-bar').style.width = `${ePct}%`;
    }

    showMessage(msg, isWarning = false) {
        const el = document.getElementById('message-area');
        el.innerText = msg;
        el.style.color = isWarning ? '#e74c3c' : '#fff';
        el.style.borderColor = isWarning ? '#e74c3c' : 'gold';
        el.style.display = 'block'; el.style.opacity = 1;
        if(this.msgTimeout) clearTimeout(this.msgTimeout);
        this.msgTimeout = setTimeout(() => { el.style.display = 'none'; }, 1500);
    }

    createEffect(x, y, type) {
        let color = 'white'; if (type === 'hit') color = 'orange'; if (type === 'blood') color = 'red';
        for(let i=0; i<6; i++) this.particles.push(new Particle(x, y, color));
    }

    endGame(isWin, reason) {
        this.gameState.isGameOver = true;
        document.getElementById('result-screen').style.display = 'flex';
        document.getElementById('end-title').innerText = isWin ? "üèÜ Â§ßÁç≤ÂÖ®Âãù" : "üíÄ Êà∞Êïó";
        document.getElementById('end-title').style.color = isWin ? "gold" : "#e74c3c";
        document.getElementById('end-reason').innerText = reason;
        const duration = Math.floor((Date.now() - this.player.startTime)/1000);
        document.getElementById('final-score').innerText = this.player.score;
        document.getElementById('final-time').innerText = duration + "s";
        this.sendToGas(duration);
    }

    sendToGas(duration) {
        if(CONFIG.gasUrl.includes("exec")) {
            const data = { name: this.player.name, id: this.player.id, score: this.player.score, duration: duration, date: new Date().toISOString() };
            fetch(CONFIG.gasUrl, { method: 'POST', mode: 'no-cors', headers: {'Content-Type': 'application/json'}, body: JSON.stringify(data) }).catch(e => console.error(e));
        }
    }
}

class Unit {
    constructor(x, y, team, typeKey, pathIdx, statsMult = 1, speedMult = 1) {
        this.x = x; this.y = y; this.team = team; this.typeKey = typeKey;
        const data = UNIT_TYPES[typeKey];
        this.name = data.name; this.maxHp = data.hp * statsMult; this.hp = this.maxHp;
        this.atk = data.atk * statsMult; this.range = data.range; this.speed = data.speed * speedMult;
        this.attackType = data.type; this.cd = data.cd;
        this.pathIndex = pathIdx; this.state = 'move'; this.attackCooldown = 0; this.dead = false;
        this.bounce = 0;
        
        // ÂúñÁâá key
        this.imgKey = (team === 'player' ? 'p_' : 'e_') + typeKey;
    }

    update(game) {
        if (this.dead) return;
        if (this.attackCooldown > 0) this.attackCooldown--;
        let target = this.findTarget(game);
        if (target) {
            this.state = 'attack';
            if (this.attackCooldown <= 0) { this.attack(target, game); this.attackCooldown = 60; }
        } else {
            this.state = 'move'; this.move(game);
        }
        if (this.state === 'move') this.bounce = Math.abs(Math.sin(Date.now() / 150)) * 5; else this.bounce = 0;
    }

    findTarget(game) {
        for (let u of game.units) {
            if (u.team !== this.team && !u.dead) {
                const dist = Math.hypot(u.x - this.x, u.y - this.y);
                if (dist <= this.range) return u;
            }
        }
        let baseDist = 9999;
        if (this.team === 'player') {
            const base = game.pathPixels[0];
            baseDist = Math.hypot(base.x - this.x, base.y - this.y);
            if (baseDist <= this.range) return { type: 'base', team: 'enemy' };
        } else {
            const base = game.pathPixels[game.pathPixels.length-1];
            baseDist = Math.hypot(base.x - this.x, base.y - this.y);
            if (baseDist <= this.range) return { type: 'base', team: 'player' };
        }
        return null;
    }

    attack(target, game) {
        if (this.attackType === 'ranged' || this.attackType === 'magic') {
            game.projectiles.push(new Projectile(this.x, this.y - 30, target, this.atk, this.team, this.attackType));
            if(this.attackType === 'magic') AudioSys.sfx.spell();
            else AudioSys.sfx.attack_range();
        } else {
            game.createEffect(target.x || this.x, target.y || this.y, 'hit');
            AudioSys.sfx.attack_melee();
            if (target.type === 'base') {
                if (target.team === 'player') game.gameState.baseHpPlayer -= this.atk;
                else game.gameState.baseHpEnemy -= this.atk;
                game.createEffect(this.x, this.y, 'hit'); 
            } else { target.takeDamage(this.atk, game); }
        }
    }

    move(game) {
        let nextIdx = (this.team === 'player') ? this.pathIndex - 1 : this.pathIndex + 1;
        if (nextIdx < 0 || nextIdx >= game.pathPixels.length) return;
        const targetNode = game.pathPixels[nextIdx];
        const dx = targetNode.x - this.x; const dy = targetNode.y - this.y;
        const dist = Math.hypot(dx, dy);
        if (dist <= this.speed) { this.x = targetNode.x; this.y = targetNode.y; this.pathIndex = nextIdx; }
        else { this.x += (dx / dist) * this.speed; this.y += (dy / dist) * this.speed; }
    }

    takeDamage(amount, game) {
        this.hp -= amount; game.createEffect(this.x, this.y - 30, 'blood');
        if (this.hp <= 0) { this.dead = true; AudioSys.sfx.hit(); }
    }

    draw(ctx, camera) {
        const pos = camera.toScreen(this.x, this.y);
        const s = pos.scale;
        const drawY = pos.y - (30 * s) - (this.bounce * s); // 30ÁÇ∫ÂúñÁâáÂü∫Â∫ïÂÅèÁßª

        // ËÖ≥Â∫ïÈô∞ÂΩ±
        ctx.fillStyle = "rgba(0,0,0,0.3)";
        ctx.beginPath();
        ctx.ellipse(pos.x, pos.y, 15 * s, 8 * s, 0, 0, Math.PI*2);
        ctx.fill();

        // Áπ™Ë£ΩËßíËâ≤ÂúñÁâá
        const img = ASSETS.images[this.imgKey];
        if (img) {
            const size = 50 * s;
            // Áπ™Ë£ΩÂú® drawY ‰∏äÊñπ (ÂúñÁâá‰∏≠ÂøÉÂ∞çÈΩä x)
            ctx.drawImage(img, pos.x - size/2, pos.y - size - (this.bounce * s), size, size);
        } else {
            // Fallback ÂúìÂΩ¢
            ctx.fillStyle = this.team === 'player' ? 'blue' : 'red';
            ctx.beginPath(); ctx.arc(pos.x, drawY, 10*s, 0, Math.PI*2); ctx.fill();
        }

        // Ë°ÄÊ¢ù
        const hpPct = this.hp / this.maxHp;
        const barY = pos.y - (55 * s) - (this.bounce * s);
        ctx.fillStyle = "#555";
        ctx.fillRect(pos.x - (15 * s), barY, 30 * s, 4 * s);
        ctx.fillStyle = hpPct > 0.5 ? "#2ecc71" : "#e74c3c";
        ctx.fillRect(pos.x - (15 * s), barY, (30 * s) * hpPct, 4 * s);
    }
}

class Projectile {
    constructor(x, y, target, dmg, team, type = 'ranged') {
        this.x = x; this.y = y; this.target = target;
        this.damage = dmg; this.team = team; this.speed = 12; this.hit = false;
        this.type = type; // ranged or magic
        this.tx = target.x || (team === 'player' ? Game.pathPixels[0].x : Game.pathPixels[Game.pathPixels.length-1].x);
        this.ty = target.y || (team === 'player' ? Game.pathPixels[0].y : Game.pathPixels[Game.pathPixels.length-1].y);
        this.ty -= 30; // Aim center
    }

    update() {
        if (this.target && !this.target.dead) {
            this.tx = this.target.x || this.tx;
            this.ty = (this.target.y || this.ty) - 30;
        }
        const dx = this.tx - this.x; const dy = this.ty - this.y;
        const dist = Math.hypot(dx, dy);
        if (dist <= this.speed) {
            this.hit = true; 
            Game.createEffect(this.tx, this.ty, 'hit'); 
            AudioSys.sfx.hit();
            
            // Ê≥ïË°ìÊì¥Êï£ÂÇ∑ÂÆ≥ (Advisor)
            if (this.type === 'magic') {
                const splashRange = 100;
                Game.createEffect(this.tx, this.ty, 'hit'); // Extra visual
                if (this.target.type !== 'base') {
                    // Â∞çÂë®ÂúçÊïµ‰∫∫ÈÄ†Êàê 50% ÂÇ∑ÂÆ≥
                    Game.units.forEach(u => {
                        if (u.team !== this.team && !u.dead) {
                            if (Math.hypot(u.x - this.tx, u.y - 30 - this.ty) < splashRange) {
                                u.takeDamage(this.damage * 0.5, Game);
                            }
                        }
                    });
                }
            }

            if (this.target.type === 'base') {
                if (this.target.team === 'player') Game.gameState.baseHpPlayer -= this.damage;
                else Game.gameState.baseHpEnemy -= this.damage;
            } else if (this.target.takeDamage) { this.target.takeDamage(this.damage, Game); }
        } else { this.x += (dx/dist) * this.speed; this.y += (dy/dist) * this.speed; }
    }

    draw(ctx, camera) {
        const pos = camera.toScreen(this.x, this.y);
        const s = pos.scale;
        
        ctx.fillStyle = this.team === 'player' ? '#3498db' : '#e74c3c';
        if (this.type === 'magic') ctx.fillStyle = '#9b59b6'; // Á¥´Ëâ≤Ê≥ïÁêÉ
        
        ctx.beginPath();
        ctx.arc(pos.x, pos.y, (this.type === 'magic' ? 8 : 5) * s, 0, Math.PI*2);
        ctx.fill();
    }
}

class Particle {
    constructor(x, y, color) {
        this.x = x; this.y = y; this.color = color;
        this.vx = (Math.random()-0.5)*6; this.vy = (Math.random()-0.5)*6;
        this.life = 1.0; this.gravity = 0.2;
    }
    update() { this.x += this.vx; this.y += this.vy; this.vy += this.gravity; this.life -= 0.05; }
    draw(ctx, camera) {
        const pos = camera.toScreen(this.x, this.y);
        const s = pos.scale;
        ctx.globalAlpha = Math.max(0, this.life);
        ctx.fillStyle = this.color;
        ctx.beginPath(); ctx.arc(pos.x, pos.y, 4 * s, 0, Math.PI*2); ctx.fill();
        ctx.globalAlpha = 1;
    }
}

const Game = new GameEngine();

</script>
</body>
</html>
