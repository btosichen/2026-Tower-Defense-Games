<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ä¸‰åœ‹ç­–ç•¥æ”»é˜²æˆ° (é›™å‘å°æˆ°ç‰ˆ)</title>
    <style>
        :root {
            --primary-color: #f39c12; /* ä¸‰åœ‹é‡‘ */
            --secondary-color: #c0392b; /* æˆ°æ——ç´… */
            --player-color: #2980b9;  /* æˆ‘è»è— */
            --enemy-color: #c0392b;   /* æ•µè»ç´… */
            --bg-color: #fcf3cf;
            --ui-bg: rgba(255, 255, 255, 0.95);
        }

        body {
            margin: 0;
            padding: 0;
            font-family: "Microsoft JhengHei", "Heiti TC", sans-serif;
            background-color: #2c3e50;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            overflow: hidden;
            user-select: none;
        }

        #game-container {
            position: relative;
            width: 1200px;
            height: 800px;
            background-color: var(--bg-color);
            box-shadow: 0 0 30px rgba(0,0,0,0.6);
            border-radius: 12px;
            overflow: hidden;
            display: none;
            transform-origin: center;
        }
        
        @media (max-width: 1220px), (max-height: 820px) {
            #game-container { transform: scale(0.8); }
        }
        @media (max-width: 980px) {
            #game-container { transform: scale(0.6); }
        }

        canvas {
            display: block;
            background: #a9dfbf;
            background-image: 
                radial-gradient(#88d498 15%, transparent 16%),
                radial-gradient(#88d498 15%, transparent 16%);
            background-size: 20px 20px;
            background-position: 0 0, 10px 10px;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .hud-panel {
            position: absolute;
            background: var(--ui-bg);
            border: 3px solid var(--primary-color);
            border-radius: 10px;
            padding: 10px;
            pointer-events: auto;
            color: #2c3e50;
            font-weight: bold;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        /* Top Bar */
        #top-bar {
            top: 15px;
            left: 15px;
            right: 15px;
            height: 60px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 20px;
        }

        .hp-bar-container {
            width: 300px;
            height: 20px;
            background: #555;
            border-radius: 10px;
            overflow: hidden;
            border: 2px solid #fff;
            position: relative;
        }

        .hp-bar-fill {
            height: 100%;
            transition: width 0.2s;
        }

        /* Bottom Bar (Unit Selection) */
        #bottom-bar {
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            padding: 10px 20px;
            width: 90%;
            justify-content: center;
        }

        .unit-btn {
            width: 100px;
            height: 110px;
            border: 3px solid #ccc;
            border-radius: 10px;
            background: linear-gradient(to bottom, #fff, #ecf0f1);
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: all 0.1s;
            position: relative;
            box-shadow: 0 4px 0 #95a5a6;
        }

        .unit-btn:active {
            transform: translateY(4px);
            box-shadow: 0 0 0 #95a5a6;
        }
        
        .unit-btn.disabled {
            filter: grayscale(100%);
            opacity: 0.6;
            cursor: not-allowed;
        }

        .unit-icon { font-size: 36px; margin-bottom: 5px; }
        .unit-name { font-size: 14px; margin-bottom: 2px; }
        .unit-cost { 
            background: gold; color: #d35400; padding: 2px 8px; 
            border-radius: 4px; font-size: 14px; border: 1px solid #e67e22;
        }
        .hotkey {
            position: absolute; top: 2px; right: 5px; font-size: 10px; color: #7f8c8d;
        }

        /* Login & Result */
        #login-screen, #result-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(44, 62, 80, 0.95);
            display: flex; flex-direction: column;
            justify-content: center; align-items: center;
            color: white; z-index: 100;
        }

        .panel-box {
            background: white; padding: 40px; border-radius: 20px;
            text-align: center; color: #2c3e50;
            border: 5px solid var(--primary-color);
            width: 400px;
        }

        input {
            padding: 10px; font-size: 18px; width: 80%;
            margin: 20px 0; text-align: center;
        }

        button.start-btn {
            background: var(--secondary-color); color: white; border: none;
            padding: 15px 40px; font-size: 20px; border-radius: 30px;
            cursor: pointer; transition: 0.3s;
        }
        button.start-btn:hover { transform: scale(1.05); }

        /* Message */
        #message-area {
            position: absolute; top: 30%; left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.8); color: #fff;
            padding: 20px 40px; border-radius: 10px;
            font-size: 32px; font-weight: bold;
            display: none; pointer-events: none;
            z-index: 50; border: 2px solid gold;
        }
    </style>
</head>
<body>

    <!-- 1. ç™»å…¥ç•«é¢ -->
    <div id="login-screen">
        <div class="panel-box">
            <h1>âš”ï¸ ä¸‰åœ‹ç­–ç•¥æ”»é˜²æˆ°</h1>
            <p>èª¿å…µé£å°‡ï¼Œæ”»ç ´æ•µæ–¹å¤§ç‡Ÿï¼</p>
            <input type="text" id="player-name" placeholder="è¼¸å…¥å°‡è»å¤§å" maxlength="10">
            <button class="start-btn" onclick="Game.initLogin()">å‡ºå¾</button>
            <p style="font-size:12px; color:#7f8c8d; margin-top:10px;">(è¨˜å¾—ç¢ºèª GAS å·²éƒ¨ç½²)</p>
        </div>
    </div>

    <!-- 2. éŠæˆ²ä¸»ç•«é¢ -->
    <div id="game-container">
        <canvas id="gameCanvas" width="1200" height="800"></canvas>
        
        <div id="ui-layer">
            <div id="top-bar" class="hud-panel">
                <div style="display:flex; flex-direction:column; align-items:flex-start;">
                    <span style="color:var(--enemy-color); font-size:14px;">æ•µè»å¤§ç‡Ÿ (é­)</span>
                    <div class="hp-bar-container">
                        <div id="enemy-hp-bar" class="hp-bar-fill" style="width: 100%; background: #c0392b;"></div>
                    </div>
                </div>

                <div style="text-align:center;">
                    <div id="wave-info" style="font-size:24px; color:var(--primary-color);">ç¬¬ 1 é—œ</div>
                    <div style="font-size:16px;">ğŸ’° è»è²»: <span id="gold" style="color:gold; text-shadow:1px 1px 0 #000;">0</span></div>
                </div>

                <div style="display:flex; flex-direction:column; align-items:flex-end;">
                    <span style="color:var(--player-color); font-size:14px;">æˆ‘è»åŸæ±  (èœ€)</span>
                    <div class="hp-bar-container">
                        <div id="player-hp-bar" class="hp-bar-fill" style="width: 100%; background: #2980b9;"></div>
                    </div>
                </div>
            </div>

            <div id="message-area">æˆ°é¬¥é–‹å§‹ï¼</div>

            <div id="bottom-bar" class="hud-panel">
                <!-- å…µç¨®æŒ‰éˆ•ç”± JS å‹•æ…‹ç”Ÿæˆ -->
            </div>
        </div>
    </div>

    <!-- 3. çµç®—ç•«é¢ -->
    <div id="result-screen" style="display: none;">
        <div class="panel-box">
            <h1 id="end-title">æˆ°å½¹çµæŸ</h1>
            <p id="end-reason">...</p>
            <div style="text-align:left; margin: 20px 0;">
                <div>ç¸½åˆ†ï¼š<span id="final-score">0</span></div>
                <div>è€—æ™‚ï¼š<span id="final-time">0s</span></div>
            </div>
            <button class="start-btn" onclick="location.reload()">å†æˆ°ä¸€å ´</button>
        </div>
    </div>

<script>
/**
 * ç¹ªåœ–è¼”åŠ©: ç•«åœ“æŸ±é«” (è§£æ±º this.drawCylinder å ±éŒ¯å•é¡Œ)
 */
function drawCylinder(ctx, x, y, radius, height, color, sideColor) {
    ctx.fillStyle = sideColor;
    ctx.beginPath();
    ctx.moveTo(x - radius, y - height);
    ctx.lineTo(x + radius, y - height);
    ctx.lineTo(x + radius, y);
    ctx.lineTo(x - radius, y);
    ctx.closePath();
    ctx.fill();

    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.ellipse(x, y - height, radius, radius * 0.4, 0, 0, Math.PI * 2);
    ctx.fill();
}

/**
 * éŠæˆ²è¨­å®š
 */
const CONFIG = {
    gridSize: 80, 
    width: 15,
    height: 10,
    gasUrl: 'https://script.google.com/macros/s/AKfycbwqZFv8Jzk4A1ERYbzljRudebPBTlBn4OcSsFWfWBGLTIKGSMDEd3focinsGovte4c9/exec' // è«‹ç¢ºèªæ­¤ç‚ºæ‚¨çš„ Web App URL
};

// å…µç¨®å®šç¾© (é›™æ–¹é€šç”¨)
// type: melee (è¿‘æˆ°), ranged (é ç¨‹)
const UNIT_TYPES = {
    sword:    { name: 'åˆ€å…µ',   cost: 50,  hp: 120, atk: 15, range: 40,  speed: 2.5, type: 'melee',  icon: 'ğŸ—¡ï¸', color: '#f1c40f', cd: 60 },
    bow:      { name: 'å¼“å…µ',   cost: 120, hp: 80,  atk: 25, range: 250, speed: 2.5, type: 'ranged', icon: 'ğŸ¹', color: '#2ecc71', cd: 80 },
    spear:    { name: 'æ§å…µ',   cost: 200, hp: 180, atk: 40, range: 70,  speed: 2.0, type: 'melee',  icon: 'ğŸ”±', color: '#3498db', cd: 100 },
    vanguard: { name: 'å‰é‹’',   cost: 300, hp: 250, atk: 50, range: 40,  speed: 4.0, type: 'melee',  icon: 'ğŸ‡', color: '#e67e22', cd: 150 },
    vice:     { name: 'å‰¯å°‡è»', cost: 500, hp: 600, atk: 70, range: 50,  speed: 1.5, type: 'melee',  icon: 'ğŸ›¡ï¸', color: '#9b59b6', cd: 300 },
    general:  { name: 'å¤§å°‡è»', cost: 900, hp: 1200,atk: 120,range: 60,  speed: 1.2, type: 'melee',  icon: 'ğŸ‘‘', color: '#c0392b', cd: 500 }
};

// é—œå¡è¨­å®š
const LEVELS = [
    {   // Level 1
        enemySpawnRate: 180, // frames
        enemyTypes: ['sword', 'sword', 'spear'],
        goldRate: 1 // æ¯å¹€é‡‘éŒ¢å¢åŠ 
    },
    {   // Level 2
        enemySpawnRate: 150,
        enemyTypes: ['sword', 'bow', 'spear', 'vanguard'],
        goldRate: 1.5
    },
    {   // Level 3
        enemySpawnRate: 120,
        enemyTypes: ['spear', 'bow', 'vanguard', 'vice', 'general'],
        goldRate: 2
    }
];

// è·¯å¾‘é» (Så‹)
const PATH_POINTS = [
    {x: 0, y: 2}, {x: 3, y: 2}, {x: 3, y: 7}, 
    {x: 8, y: 7}, {x: 8, y: 2}, {x: 12, y: 2}, 
    {x: 12, y: 6}, {x: 14, y: 6}
];

class GameEngine {
    constructor() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.player = { name: '', id: '', score: 0 };
        
        this.gameState = {
            level: 0,
            gold: 0,
            baseHpPlayer: 1000,
            baseHpEnemy: 1000,
            maxBaseHp: 1000,
            isGameOver: false,
            enemySpawnTimer: 0
        };

        this.units = []; // æ‰€æœ‰çš„å…µ (æ•µ + æˆ‘)
        this.projectiles = [];
        this.particles = [];
        
        // é å…ˆè¨ˆç®—è·¯å¾‘åƒç´ 
        this.pathPixels = PATH_POINTS.map(p => ({
            x: p.x * CONFIG.gridSize + CONFIG.gridSize/2,
            y: p.y * CONFIG.gridSize + CONFIG.gridSize/2
        }));

        this.lastTime = 0;
        
        // Fix: initialize cooldowns BEFORE creating buttons that use it
        this.cooldowns = {}; 
        this.createUnitButtons();
    }

    createUnitButtons() {
        const bar = document.getElementById('bottom-bar');
        bar.innerHTML = '';
        const keys = Object.keys(UNIT_TYPES);
        keys.forEach((key, index) => {
            const u = UNIT_TYPES[key];
            const div = document.createElement('div');
            div.className = 'unit-btn';
            div.id = `btn-${key}`;
            div.onclick = () => this.spawnPlayerUnit(key);
            div.innerHTML = `
                <span class="hotkey">${index+1}</span>
                <div class="unit-icon">${u.icon}</div>
                <div class="unit-name">${u.name}</div>
                <div class="unit-cost">$${u.cost}</div>
                <div class="cooldown-overlay" style="position:absolute;bottom:0;left:0;width:100%;height:0%;background:rgba(0,0,0,0.5);transition:height 0.1s;"></div>
            `;
            bar.appendChild(div);
            // This line was causing the error because this.cooldowns was undefined
            this.cooldowns[key] = 0;
        });

        // éµç›¤ç†±éµ
        document.addEventListener('keydown', (e) => {
            const idx = parseInt(e.key) - 1;
            if (idx >= 0 && idx < keys.length) {
                this.spawnPlayerUnit(keys[idx]);
            }
        });
    }

    initLogin() {
        const name = document.getElementById('player-name').value.trim();
        if (!name) return alert("è«‹è¼¸å…¥å¤§åï¼");
        this.player.name = name;
        this.player.id = 'ID_' + Date.now();
        this.player.startTime = Date.now();
        
        document.getElementById('login-screen').style.display = 'none';
        document.getElementById('game-container').style.display = 'block';
        
        this.startLevel(0);
        this.gameLoop(0);
    }

    startLevel(lvl) {
        if (lvl >= LEVELS.length) return this.endGame(true, "å¤©ä¸‹çµ±ä¸€ï¼");
        
        this.gameState.level = lvl;
        this.gameState.gold = 500; // åˆå§‹é‡‘éŒ¢
        this.gameState.maxBaseHp = 1000 + (lvl * 500);
        this.gameState.baseHpEnemy = this.gameState.maxBaseHp;
        this.gameState.baseHpPlayer = 1000; // ç©å®¶ä¸»å ¡è¡€é‡å›ºå®š? æˆ–è€…ä¹Ÿå¯ä»¥å‡ç´š
        
        this.units = [];
        this.projectiles = [];
        this.particles = [];
        
        this.updateUI();
        this.showMessage(`ç¬¬ ${lvl+1} é—œ - é€²æ”»ï¼`);
    }

    spawnPlayerUnit(typeKey) {
        const data = UNIT_TYPES[typeKey];
        // æª¢æŸ¥é‡‘éŒ¢
        if (this.gameState.gold < data.cost) {
            this.showMessage("è»è²»ä¸è¶³", true);
            return;
        }
        // æª¢æŸ¥å†·å»
        if (this.cooldowns[typeKey] > 0) return;

        // æ‰£æ¬¾èˆ‡ç”Ÿæˆ
        this.gameState.gold -= data.cost;
        this.cooldowns[typeKey] = data.cd; // è¨­å®šå†·å»

        // ç©å®¶å–®ä½ï¼šå¾è·¯å¾‘æœ€å¾Œä¸€é»å‡ºç™¼ï¼Œå¾€ index 0 èµ°
        const startNode = this.pathPixels[this.pathPixels.length - 1];
        const unit = new Unit(startNode.x, startNode.y, 'player', typeKey, this.pathPixels.length - 1);
        this.units.push(unit);
        this.updateUI();
    }

    spawnEnemyUnit() {
        const lvlData = LEVELS[this.gameState.level];
        const types = lvlData.enemyTypes;
        const randType = types[Math.floor(Math.random() * types.length)];
        
        // æ•µæ–¹å–®ä½ï¼šå¾è·¯å¾‘ 0 å‡ºç™¼ï¼Œå¾€æœ€å¾Œèµ°
        const startNode = this.pathPixels[0];
        const unit = new Unit(startNode.x, startNode.y, 'enemy', randType, 0);
        this.units.push(unit);
    }

    gameLoop(timestamp) {
        if (this.gameState.isGameOver) return;
        if (!this.lastTime) this.lastTime = timestamp;
        const dt = timestamp - this.lastTime;

        if (dt > 16) {
            this.update();
            this.draw();
            this.lastTime = timestamp;
        }
        requestAnimationFrame((t) => this.gameLoop(t));
    }

    update() {
        const lvlData = LEVELS[this.gameState.level];

        // 1. è³‡æºèˆ‡ç”Ÿæˆ
        this.gameState.gold += lvlData.goldRate * 0.5; // é‡‘éŒ¢è‡ªç„¶å¢é•·
        if (this.gameState.gold > 5000) this.gameState.gold = 5000;

        // æ•µè»ç”Ÿæˆ
        this.gameState.enemySpawnTimer++;
        if (this.gameState.enemySpawnTimer > lvlData.enemySpawnRate) {
            this.spawnEnemyUnit();
            this.gameState.enemySpawnTimer = 0;
        }

        // å†·å»æ›´æ–°
        for (let key in this.cooldowns) {
            if (this.cooldowns[key] > 0) this.cooldowns[key]--;
            // æ›´æ–° UI é®ç½©é«˜åº¦
            const btn = document.getElementById(`btn-${key}`);
            if(btn) {
                const overlay = btn.querySelector('.cooldown-overlay');
                const percent = (this.cooldowns[key] / UNIT_TYPES[key].cd) * 100;
                overlay.style.height = `${percent}%`;
                if(percent <= 0 && this.gameState.gold < UNIT_TYPES[key].cost) {
                     btn.classList.add('disabled');
                } else {
                     btn.classList.remove('disabled');
                }
            }
        }

        // 2. å–®ä½é‚è¼¯ (ç§»å‹•ã€æˆ°é¬¥)
        // å…ˆæ’åº (yè»¸æ¸²æŸ“ç”¨ï¼Œä½†ä¹Ÿå¯ç”¨æ–¼ç°¡å–®çš„é‚è¼¯è™•ç†)
        this.units.sort((a, b) => a.y - b.y);

        for (let i = this.units.length - 1; i >= 0; i--) {
            const u = this.units[i];
            u.update(this);
            if (u.dead) {
                this.units.splice(i, 1);
                // çå‹µé‡‘
                if (u.team === 'enemy') {
                    this.gameState.gold += UNIT_TYPES[u.typeKey].cost * 0.3;
                    this.player.score += 10;
                }
            }
        }

        // 3. å­å½ˆ
        for (let i = this.projectiles.length - 1; i >= 0; i--) {
            const p = this.projectiles[i];
            p.update();
            if (p.hit) this.projectiles.splice(i, 1);
        }

        // 4. ç²’å­
        this.particles = this.particles.filter(p => p.life > 0);
        this.particles.forEach(p => p.update());

        this.updateUI();

        // å‹è² åˆ¤å®š
        if (this.gameState.baseHpPlayer <= 0) this.endGame(false, "åŸæ± é™·è½ï¼Œå‹æ•—ä¹ƒå…µå®¶å¸¸äº‹...");
        if (this.gameState.baseHpEnemy <= 0) {
            // ä¸‹ä¸€é—œ
            this.gameState.baseHpEnemy = 0; // é˜²æ­¢è² æ•¸
            this.showMessage("æ•µç‡Ÿæ”»ç ´ï¼å‰å¾€ä¸‹ä¸€æˆ°å ´...", false);
            // æ¸…å ´ä¸¦é€²å…¥ä¸‹ä¸€é—œ
            setTimeout(() => {
                 this.startLevel(this.gameState.level + 1);
            }, 2000);
        }
    }

    draw() {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        
        // ç•«è·¯å¾‘
        this.drawPath();

        // ç•«åŸºåœ°
        const start = this.pathPixels[0];
        const end = this.pathPixels[this.pathPixels.length-1];
        
        // æ•µæ–¹åŸºåœ° (å·¦ä¸Š)
        drawCylinder(this.ctx, start.x, start.y, 50, 60, '#c0392b', '#922b21');
        this.drawText(start.x, start.y - 80, "æ•µç‡Ÿ", "20px Arial", "#fff");
        
        // æˆ‘æ–¹åŸºåœ° (å³ä¸‹)
        drawCylinder(this.ctx, end.x, end.y, 50, 60, '#2980b9', '#1a5276');
        this.drawText(end.x, end.y - 80, "æˆ‘åŸ", "20px Arial", "#fff");

        // ç•«å–®ä½
        this.units.forEach(u => u.draw(this.ctx));

        // ç•«å­å½ˆ
        this.projectiles.forEach(p => p.draw(this.ctx));

        // ç•«ç²’å­
        this.particles.forEach(p => p.draw(this.ctx));
    }

    drawPath() {
        this.ctx.lineCap = 'round';
        this.ctx.lineJoin = 'round';
        this.ctx.lineWidth = 60;
        this.ctx.strokeStyle = '#d7bde2'; // è·¯å¾‘åº•è‰²
        this.ctx.beginPath();
        if (this.pathPixels.length > 0) {
            this.ctx.moveTo(this.pathPixels[0].x, this.pathPixels[0].y + 5);
            for (let i = 1; i < this.pathPixels.length; i++) {
                this.ctx.lineTo(this.pathPixels[i].x, this.pathPixels[i].y + 5);
            }
        }
        this.ctx.stroke();

        this.ctx.strokeStyle = '#f5eef8'; // è·¯é¢
        this.ctx.beginPath();
        if (this.pathPixels.length > 0) {
            this.ctx.moveTo(this.pathPixels[0].x, this.pathPixels[0].y);
            for (let i = 1; i < this.pathPixels.length; i++) {
                this.ctx.lineTo(this.pathPixels[i].x, this.pathPixels[i].y);
            }
        }
        this.ctx.stroke();
    }

    drawText(x, y, text, font, color) {
        this.ctx.font = font;
        this.ctx.fillStyle = color;
        this.ctx.textAlign = "center";
        this.ctx.fillText(text, x, y);
    }

    updateUI() {
        document.getElementById('gold').innerText = Math.floor(this.gameState.gold);
        document.getElementById('wave-info').innerText = `ç¬¬ ${this.gameState.level + 1} é—œ`;
        
        // è¡€æ¢æ›´æ–°
        const pPct = Math.max(0, (this.gameState.baseHpPlayer / 1000) * 100);
        document.getElementById('player-hp-bar').style.width = `${pPct}%`;
        
        const ePct = Math.max(0, (this.gameState.baseHpEnemy / this.gameState.maxBaseHp) * 100);
        document.getElementById('enemy-hp-bar').style.width = `${ePct}%`;
    }

    showMessage(msg, isWarning = false) {
        const el = document.getElementById('message-area');
        el.innerText = msg;
        el.style.color = isWarning ? '#e74c3c' : '#fff';
        el.style.borderColor = isWarning ? '#e74c3c' : 'gold';
        el.style.display = 'block';
        el.style.opacity = 1;
        
        // æ¸…é™¤ä¹‹å‰çš„ timeout é˜²æ­¢é–ƒçˆ
        if(this.msgTimeout) clearTimeout(this.msgTimeout);
        this.msgTimeout = setTimeout(() => {
            el.style.display = 'none';
        }, 1500);
    }

    createEffect(x, y, type) {
        let color = 'white';
        if (type === 'hit') color = 'orange';
        if (type === 'blood') color = 'red';
        for(let i=0; i<5; i++) {
            this.particles.push(new Particle(x, y, color));
        }
    }

    endGame(isWin, reason) {
        this.gameState.isGameOver = true;
        document.getElementById('result-screen').style.display = 'flex';
        document.getElementById('end-title').innerText = isWin ? "ğŸ† å¤§ç²å…¨å‹" : "ğŸ’€ æˆ°æ•—";
        document.getElementById('end-title').style.color = isWin ? "gold" : "#e74c3c";
        document.getElementById('end-reason').innerText = reason;
        
        const duration = Math.floor((Date.now() - this.player.startTime)/1000);
        document.getElementById('final-score').innerText = this.player.score;
        document.getElementById('final-time').innerText = duration + "s";

        // ç™¼é€è³‡æ–™
        this.sendToGas(duration);
    }

    sendToGas(duration) {
        if(CONFIG.gasUrl.includes("exec")) {
            const data = {
                name: this.player.name,
                id: this.player.id,
                score: this.player.score,
                duration: duration,
                date: new Date().toISOString()
            };
            fetch(CONFIG.gasUrl, {
                method: 'POST',
                mode: 'no-cors',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify(data)
            }).then(() => console.log("Sent to GAS")).catch(e => console.error(e));
        }
    }
}

/**
 * å–®ä½é¡åˆ¥ (æ•µæˆ‘é€šç”¨)
 */
class Unit {
    constructor(x, y, team, typeKey, pathIdx) {
        this.x = x;
        this.y = y;
        this.team = team; // 'player' or 'enemy'
        this.typeKey = typeKey;
        
        const data = UNIT_TYPES[typeKey];
        this.name = data.name;
        this.maxHp = data.hp;
        this.hp = data.hp;
        this.atk = data.atk;
        this.range = data.range;
        this.speed = data.speed;
        this.attackType = data.type; // melee, ranged
        this.icon = data.icon;
        this.color = data.color;

        // è·¯å¾‘é‚è¼¯
        this.pathIndex = pathIdx;
        this.targetNode = null;
        this.state = 'move'; // move, attack
        this.attackCooldown = 0;
        this.dead = false;
        
        // 3D è¦–è¦ºåç§»
        this.visualHeight = (typeKey === 'general') ? 50 : 30;
        this.bounce = 0;
    }

    update(game) {
        if (this.dead) return;

        // æˆ°é¬¥é‚è¼¯
        if (this.attackCooldown > 0) this.attackCooldown--;

        // å°‹æ‰¾ç›®æ¨™
        let target = this.findTarget(game);
        
        if (target) {
            // æœ‰ç›®æ¨™åœ¨å°„ç¨‹å…§ -> æ”»æ“Š
            this.state = 'attack';
            if (this.attackCooldown <= 0) {
                this.attack(target, game);
                this.attackCooldown = 60; // æ”»æ“Šé–“éš” (1ç§’)
            }
        } else {
            // ç„¡ç›®æ¨™ -> ç§»å‹•
            this.state = 'move';
            this.move(game);
        }

        // èµ°è·¯å‹•ç•«
        if (this.state === 'move') {
            this.bounce = Math.sin(Date.now() / 100) * 3;
        } else {
            this.bounce = 0;
        }
    }

    findTarget(game) {
        // 1. æª¢æŸ¥æ˜¯å¦æœ‰æ•µæ–¹å–®ä½åœ¨å°„ç¨‹å…§
        for (let u of game.units) {
            if (u.team !== this.team && !u.dead) {
                const dist = Math.hypot(u.x - this.x, u.y - this.y);
                if (dist <= this.range) return u;
            }
        }
        // 2. æª¢æŸ¥æ˜¯å¦åœ¨æ•µæ–¹åŸºåœ°å°„ç¨‹å…§
        let baseDist = 9999;
        if (this.team === 'player') {
            // ç›®æ¨™æ˜¯æ•µæ–¹åŸºåœ° (èµ·é» path[0])
            const base = game.pathPixels[0];
            baseDist = Math.hypot(base.x - this.x, base.y - this.y);
            if (baseDist <= this.range) return { type: 'base', team: 'enemy' };
        } else {
            // ç›®æ¨™æ˜¯æˆ‘æ–¹åŸºåœ° (çµ‚é»)
            const base = game.pathPixels[game.pathPixels.length-1];
            baseDist = Math.hypot(base.x - this.x, base.y - this.y);
            if (baseDist <= this.range) return { type: 'base', team: 'player' };
        }
        return null;
    }

    attack(target, game) {
        // å¦‚æœæ˜¯é ç¨‹ï¼Œç™¼å°„å­å½ˆ
        if (this.attackType === 'ranged') {
            game.projectiles.push(new Projectile(this.x, this.y - this.visualHeight, target, this.atk, this.team));
        } else {
            // è¿‘æˆ°ç›´æ¥æ‰£è¡€
            game.createEffect(target.x || this.x, target.y || this.y, 'hit');
            if (target.type === 'base') {
                if (target.team === 'player') game.gameState.baseHpPlayer -= this.atk;
                else game.gameState.baseHpEnemy -= this.atk;
                game.createEffect(this.x, this.y, 'hit'); // æ”»æ“Šç‰¹æ•ˆ
            } else {
                target.takeDamage(this.atk, game);
            }
        }
    }

    move(game) {
        // æ ¹æ“šéšŠä¼æ±ºå®šä¸‹ä¸€å€‹è·¯å¾‘é»
        // ç©å®¶: index N -> 0
        // æ•µè»: index 0 -> N
        
        let nextIdx = (this.team === 'player') ? this.pathIndex - 1 : this.pathIndex + 1;
        
        // æª¢æŸ¥æ˜¯å¦åˆ°é”çµ‚é» (åŸºåœ°)
        if (nextIdx < 0 || nextIdx >= game.pathPixels.length) {
            return; // å·²åœ¨åŸºåœ°æ—ï¼Œç­‰å¾…æ”»æ“Š
        }

        const targetNode = game.pathPixels[nextIdx];
        const dx = targetNode.x - this.x;
        const dy = targetNode.y - this.y;
        const dist = Math.hypot(dx, dy);

        if (dist <= this.speed) {
            this.x = targetNode.x;
            this.y = targetNode.y;
            this.pathIndex = nextIdx;
        } else {
            this.x += (dx / dist) * this.speed;
            this.y += (dy / dist) * this.speed;
        }
    }

    takeDamage(amount, game) {
        this.hp -= amount;
        game.createEffect(this.x, this.y - this.visualHeight, 'blood');
        if (this.hp <= 0) {
            this.dead = true;
        }
    }

    draw(ctx) {
        const drawY = this.y - this.visualHeight + this.bounce;

        // è…³åº•é™°å½±
        ctx.fillStyle = "rgba(0,0,0,0.3)";
        ctx.beginPath();
        ctx.ellipse(this.x, this.y, 15, 8, 0, 0, Math.PI*2);
        ctx.fill();

        // èº«é«” (é¡è‰²å€åˆ†é™£ç‡Ÿ)
        // æ•µè»ç´…æ¡†ï¼Œæˆ‘è»è—æ¡†
        ctx.lineWidth = 3;
        ctx.strokeStyle = this.team === 'player' ? '#2980b9' : '#c0392b';
        ctx.fillStyle = this.color;
        
        ctx.beginPath();
        ctx.arc(this.x, drawY, 20, 0, Math.PI*2);
        ctx.fill();
        ctx.stroke();

        // icon
        ctx.font = "20px Arial";
        ctx.fillStyle = "#fff";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(this.icon, this.x, drawY);

        // è¡€æ¢
        const hpPct = this.hp / this.maxHp;
        ctx.fillStyle = "red";
        ctx.fillRect(this.x - 15, drawY - 30, 30, 5);
        ctx.fillStyle = "#2ecc71";
        ctx.fillRect(this.x - 15, drawY - 30, 30 * hpPct, 5);
    }
}

class Projectile {
    constructor(x, y, target, dmg, team) {
        this.x = x; this.y = y;
        this.target = target;
        this.damage = dmg;
        this.team = team;
        this.speed = 10;
        this.hit = false;
        
        // é–å®šç›®æ¨™ä½ç½® (å› ç‚ºç›®æ¨™å¯èƒ½æ˜¯ç‰©ä»¶æˆ–åº§æ¨™)
        this.tx = target.x || (team === 'player' ? Game.pathPixels[0].x : Game.pathPixels[Game.pathPixels.length-1].x);
        this.ty = target.y || (team === 'player' ? Game.pathPixels[0].y : Game.pathPixels[Game.pathPixels.length-1].y);
        if(target.visualHeight) this.ty -= target.visualHeight;
    }

    update() {
        // è¿½è¹¤é‚è¼¯ (ç°¡å–®è¿½è¹¤)
        if (this.target && !this.target.dead) {
            this.tx = this.target.x || this.tx;
            this.ty = (this.target.y || this.ty) - (this.target.visualHeight || 30);
        }

        const dx = this.tx - this.x;
        const dy = this.ty - this.y;
        const dist = Math.hypot(dx, dy);

        if (dist <= this.speed) {
            this.hit = true;
            Game.createEffect(this.tx, this.ty, 'hit');
            if (this.target.type === 'base') {
                if (this.target.team === 'player') Game.gameState.baseHpPlayer -= this.damage;
                else Game.gameState.baseHpEnemy -= this.damage;
            } else if (this.target.takeDamage) {
                this.target.takeDamage(this.damage, Game);
            }
        } else {
            this.x += (dx/dist) * this.speed;
            this.y += (dy/dist) * this.speed;
        }
    }

    draw(ctx) {
        ctx.fillStyle = this.team === 'player' ? '#3498db' : '#e74c3c';
        ctx.beginPath();
        ctx.arc(this.x, this.y, 5, 0, Math.PI*2);
        ctx.fill();
    }
}

class Particle {
    constructor(x, y, color) {
        this.x = x; this.y = y; this.color = color;
        this.vx = (Math.random()-0.5)*5;
        this.vy = (Math.random()-0.5)*5;
        this.life = 1.0;
    }
    update() {
        this.x += this.vx; this.y += this.vy; this.life -= 0.1;
    }
    draw(ctx) {
        ctx.globalAlpha = Math.max(0, this.life);
        ctx.fillStyle = this.color;
        ctx.beginPath(); ctx.arc(this.x, this.y, 3, 0, Math.PI*2); ctx.fill();
        ctx.globalAlpha = 1;
    }
}

const Game = new GameEngine();

</script>
</body>
</html>
