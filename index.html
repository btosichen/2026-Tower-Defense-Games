<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>‰∏âÂúãÁ≠ñÁï•ÊîªÈò≤Êà∞ (3DÈü≥ÊïàÂº∑ÂåñÁâà)</title>
    <style>
        :root {
            --primary-color: #f39c12; /* ‰∏âÂúãÈáë */
            --secondary-color: #c0392b; /* Êà∞ÊóóÁ¥Ö */
            --player-color: #2980b9;  /* ÊàëËªçËóç */
            --enemy-color: #c0392b;   /* ÊïµËªçÁ¥Ö */
            --bg-color: #fcf3cf;
            --ui-bg: rgba(255, 255, 255, 0.95);
        }

        body {
            margin: 0;
            padding: 0;
            font-family: "Microsoft JhengHei", "Heiti TC", sans-serif;
            background-color: #2c3e50;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            overflow: hidden;
            user-select: none;
        }

        #game-container {
            position: relative;
            width: 1200px;
            height: 800px;
            background-color: var(--bg-color);
            box-shadow: 0 0 50px rgba(0,0,0,0.8);
            border-radius: 12px;
            overflow: hidden;
            display: none;
            transform-origin: center;
        }
        
        @media (max-width: 1220px), (max-height: 820px) {
            #game-container { transform: scale(0.8); }
        }
        @media (max-width: 980px) {
            #game-container { transform: scale(0.6); }
        }

        canvas {
            display: block;
            background: #a9dfbf;
            /* Âú∞Èù¢Á¥ãÁêÜ */
            background-image: 
                linear-gradient(rgba(255,255,255,0.1) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255,255,255,0.1) 1px, transparent 1px);
            background-size: 80px 80px;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .hud-panel {
            position: absolute;
            background: var(--ui-bg);
            border: 3px solid var(--primary-color);
            border-radius: 10px;
            padding: 10px;
            pointer-events: auto;
            color: #2c3e50;
            font-weight: bold;
            box-shadow: 0 6px 0 rgba(0,0,0,0.2);
        }

        /* Top Bar */
        #top-bar {
            top: 15px;
            left: 15px;
            right: 15px;
            height: 70px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 20px;
        }

        .hp-bar-container {
            width: 320px;
            height: 24px;
            background: #34495e;
            border-radius: 12px;
            overflow: hidden;
            border: 3px solid #fff;
            position: relative;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.5);
        }

        .hp-bar-fill {
            height: 100%;
            transition: width 0.2s;
            position: relative;
        }
        
        .hp-bar-fill::after {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0; height: 50%;
            background: rgba(255,255,255,0.2);
        }

        /* Bottom Bar (Unit Selection) */
        #bottom-bar {
            bottom: 15px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 12px;
            padding: 15px 30px;
            width: 90%;
            justify-content: center;
        }

        .unit-btn {
            width: 100px;
            height: 120px;
            border: 2px solid #95a5a6;
            border-radius: 10px;
            background: linear-gradient(to bottom, #fff, #ecf0f1);
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: all 0.1s;
            position: relative;
            box-shadow: 0 6px 0 #7f8c8d;
            overflow: hidden;
        }

        .unit-btn:active {
            transform: translateY(4px);
            box-shadow: 0 2px 0 #7f8c8d;
        }
        
        .unit-btn.disabled {
            filter: grayscale(100%);
            opacity: 0.6;
            cursor: not-allowed;
            background: #bdc3c7;
        }

        .unit-icon { font-size: 40px; margin-bottom: 5px; text-shadow: 2px 2px 0 rgba(0,0,0,0.1); }
        .unit-name { font-size: 15px; font-weight: 800; color: #2c3e50; }
        .unit-cost { 
            background: gold; color: #d35400; padding: 2px 8px; 
            border-radius: 4px; font-size: 14px; border: 1px solid #e67e22;
            margin-top: 4px; font-weight: bold;
        }
        .hotkey {
            position: absolute; top: 2px; right: 5px; font-size: 12px; color: #7f8c8d; font-weight: bold;
        }

        /* Login & Result */
        #login-screen, #result-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(44, 62, 80, 0.98);
            display: flex; flex-direction: column;
            justify-content: center; align-items: center;
            color: white; z-index: 100;
        }

        .panel-box {
            background: #fff; padding: 50px; border-radius: 20px;
            text-align: center; color: #2c3e50;
            border: 6px solid var(--primary-color);
            width: 450px;
            box-shadow: 0 20px 50px rgba(0,0,0,0.5);
        }

        input {
            padding: 15px; font-size: 20px; width: 80%;
            margin: 20px 0; text-align: center; border: 2px solid #bdc3c7; border-radius: 8px;
        }

        button.start-btn {
            background: var(--secondary-color); color: white; border: none;
            padding: 15px 50px; font-size: 24px; border-radius: 40px;
            cursor: pointer; transition: 0.3s;
            box-shadow: 0 6px 0 #922b21;
        }
        button.start-btn:hover { transform: translateY(-3px); box-shadow: 0 9px 0 #922b21; }
        button.start-btn:active { transform: translateY(3px); box-shadow: 0 3px 0 #922b21; }

        /* Message */
        #message-area {
            position: absolute; top: 35%; left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.85); color: #fff;
            padding: 20px 50px; border-radius: 50px;
            font-size: 36px; font-weight: bold;
            display: none; pointer-events: none;
            z-index: 50; border: 4px solid gold;
            text-shadow: 0 2px 4px black;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }
    </style>
</head>
<body>

    <!-- 1. ÁôªÂÖ•Áï´Èù¢ -->
    <div id="login-screen">
        <div class="panel-box">
            <h1 style="font-size: 48px; margin-bottom: 20px;">‚öîÔ∏è ‰∏âÂúãÁ≠ñÁï•ÊîªÈò≤Êà∞</h1>
            <p style="font-size: 18px; color: #7f8c8d;">Ëôü‰ª§‰∏âËªçÔºå‰∏ÄÁµ±Â§©‰∏ãÔºÅ(Èü≥ÊïàÁâà)</p>
            <input type="text" id="player-name" placeholder="Ë´ãËº∏ÂÖ•Â∞áËªçÂ§ßÂêç" maxlength="10">
            <button class="start-btn" onclick="Game.initLogin()">Âá∫ÂæÅ</button>
        </div>
    </div>

    <!-- 2. ÈÅäÊà≤‰∏ªÁï´Èù¢ -->
    <div id="game-container">
        <canvas id="gameCanvas" width="1200" height="800"></canvas>
        
        <div id="ui-layer">
            <div id="top-bar" class="hud-panel">
                <div style="display:flex; flex-direction:column; align-items:flex-start;">
                    <span style="color:var(--enemy-color); font-size:16px; margin-bottom:5px;">üö© ÊïµËªçÂ§ßÁáü (È≠è) <span id="enemy-stats-hint" style="font-size:12px;color:#e74c3c;"></span></span>
                    <div class="hp-bar-container">
                        <div id="enemy-hp-bar" class="hp-bar-fill" style="width: 100%; background: linear-gradient(to right, #e74c3c, #c0392b);"></div>
                    </div>
                </div>

                <div style="text-align:center;">
                    <div id="wave-info" style="font-size:28px; color:var(--primary-color); text-shadow: 1px 1px 0 #333; font-weight:900;">Á¨¨ 1 Èóú</div>
                    <div style="font-size:20px; margin-top:5px; background:rgba(0,0,0,0.1); padding:2px 10px; border-radius:10px;">üí∞ <span id="gold" style="color:#d35400;">0</span></div>
                </div>

                <div style="display:flex; flex-direction:column; align-items:flex-end;">
                    <span style="color:var(--player-color); font-size:16px; margin-bottom:5px;">üõ°Ô∏è ÊàëËªçÂüéÊ±† (ËúÄ)</span>
                    <div class="hp-bar-container">
                        <div id="player-hp-bar" class="hp-bar-fill" style="width: 100%; background: linear-gradient(to right, #3498db, #2980b9);"></div>
                    </div>
                </div>
            </div>

            <div id="message-area">Êà∞È¨•ÈñãÂßãÔºÅ</div>

            <div id="bottom-bar" class="hud-panel">
                <!-- ÂÖµÁ®ÆÊåâÈàïÁî± JS ÂãïÊÖãÁîüÊàê -->
            </div>
        </div>
    </div>

    <!-- 3. ÁµêÁÆóÁï´Èù¢ -->
    <div id="result-screen" style="display: none;">
        <div class="panel-box">
            <h1 id="end-title" style="font-size: 48px;">Êà∞ÂΩπÁµêÊùü</h1>
            <p id="end-reason" style="font-size: 20px; color: #555;">...</p>
            <div style="text-align:left; margin: 30px 0; font-size: 20px; background: #f9f9f9; padding: 20px; border-radius: 10px;">
                <div style="margin-bottom: 10px;">üèÖ Á∏ΩÂàÜÔºö<span id="final-score" style="font-weight:bold; color:var(--primary-color);">0</span></div>
                <div>‚è±Ô∏è ËÄóÊôÇÔºö<span id="final-time" style="font-weight:bold;">0s</span></div>
            </div>
            <button class="start-btn" onclick="location.reload()">ÂÜçÊà∞‰∏ÄÂ†¥</button>
        </div>
    </div>

<script>
/**
 * Èü≥ÊïàÁÆ°ÁêÜÂô® (Web Audio API)
 */
const AudioSys = {
    ctx: null,
    init: function() {
        if (!this.ctx) {
            this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        }
        if (this.ctx.state === 'suspended') {
            this.ctx.resume();
        }
    },
    playTone: function(freq, type, duration, vol = 0.1) {
        if (!this.ctx) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = type; // sine, square, sawtooth, triangle
        osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
        gain.gain.setValueAtTime(vol, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.start();
        osc.stop(this.ctx.currentTime + duration);
    },
    playNoise: function(duration, vol = 0.1) {
        if (!this.ctx) return;
        const bufferSize = this.ctx.sampleRate * duration;
        const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) {
            data[i] = Math.random() * 2 - 1;
        }
        const noise = this.ctx.createBufferSource();
        noise.buffer = buffer;
        const gain = this.ctx.createGain();
        gain.gain.setValueAtTime(vol, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
        noise.connect(gain);
        gain.connect(this.ctx.destination);
        noise.start();
    },
    // Èü≥ÊïàÂ∫´
    sfx: {
        spawn: () => AudioSys.playTone(400, 'triangle', 0.1, 0.1),
        attack_melee: () => AudioSys.playNoise(0.1, 0.05),
        attack_range: () => AudioSys.playTone(800, 'sine', 0.1, 0.05),
        hit: () => AudioSys.playNoise(0.1, 0.1),
        win_level: () => {
            if(!AudioSys.ctx) return;
            // ÂãùÂà©ÂíåÂº¶
            [440, 554, 659].forEach((f, i) => setTimeout(() => AudioSys.playTone(f, 'square', 0.4, 0.1), i * 100));
        },
        game_over: () => {
             if(!AudioSys.ctx) return;
             [300, 250, 200].forEach((f, i) => setTimeout(() => AudioSys.playTone(f, 'sawtooth', 0.5, 0.1), i * 300));
        }
    }
};

/**
 * 3D Áπ™ÂúñËºîÂä©: Âº∑ÂåñÁâàÂúìÊü±È´î (Êº∏Â±§ + Èô∞ÂΩ±)
 */
function drawCylinder(ctx, x, y, radius, height, color, sideColor) {
    // 1. Â∫ïÈÉ®Èô∞ÂΩ± (ËÆìÁâ©È´îÊµÆÂú®Âú∞‰∏ä)
    ctx.fillStyle = "rgba(0,0,0,0.3)";
    ctx.beginPath();
    ctx.ellipse(x, y, radius, radius * 0.4, 0, 0, Math.PI * 2);
    ctx.fill();

    // 2. ÂÅ¥Èù¢ (‰ΩøÁî®Êº∏Â±§Ê®°Êì¨Êõ≤Èù¢ÂÖâÂΩ±)
    const gradient = ctx.createLinearGradient(x - radius, y, x + radius, y);
    gradient.addColorStop(0, sideColor);     // ÈÇäÁ∑£Ê∑±Ëâ≤
    gradient.addColorStop(0.2, color);       // ‰∫ÆÈÉ®
    gradient.addColorStop(0.5, color);       // Ê≠£Èù¢
    gradient.addColorStop(0.8, color);       
    gradient.addColorStop(1, sideColor);     // ÈÇäÁ∑£Ê∑±Ëâ≤

    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.moveTo(x - radius, y - height);
    ctx.lineTo(x + radius, y - height);
    ctx.lineTo(x + radius, y);
    ctx.lineTo(x - radius, y);
    ctx.closePath();
    ctx.fill();

    // ÂÅ¥Èù¢ÈÇäÊ°ÜÁ∑ö (Â¢ûÂº∑Ëº™Âªì)
    ctx.strokeStyle = "rgba(0,0,0,0.1)";
    ctx.lineWidth = 1;
    ctx.stroke();

    // 3. È†ÇÈÉ® (Á®çÂæÆ‰∫Æ‰∏ÄÈªû)
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.ellipse(x, y - height, radius, radius * 0.4, 0, 0, Math.PI * 2);
    ctx.fill();
    
    // È†ÇÈÉ®È´òÂÖâ
    ctx.fillStyle = "rgba(255,255,255,0.1)";
    ctx.beginPath();
    ctx.ellipse(x, y - height, radius * 0.8, radius * 0.3, 0, 0, Math.PI * 2);
    ctx.fill();
}

/**
 * ÈÅäÊà≤Ë®≠ÂÆö
 */
const CONFIG = {
    gridSize: 80, 
    width: 15,
    height: 10,
    gasUrl: 'https://script.google.com/macros/s/AKfycbwqZFv8Jzk4A1ERYbzljRudebPBTlBn4OcSsFWfWBGLTIKGSMDEd3focinsGovte4c9/exec'
};

const UNIT_TYPES = {
    sword:    { name: 'ÂàÄÂÖµ',   cost: 50,  hp: 120, atk: 15, range: 40,  speed: 2.5, type: 'melee',  icon: 'üó°Ô∏è', color: '#f1c40f', cd: 60 },
    bow:      { name: 'ÂºìÂÖµ',   cost: 120, hp: 80,  atk: 25, range: 250, speed: 2.5, type: 'ranged', icon: 'üèπ', color: '#2ecc71', cd: 80 },
    spear:    { name: 'ÊßçÂÖµ',   cost: 200, hp: 180, atk: 40, range: 70,  speed: 2.0, type: 'melee',  icon: 'üî±', color: '#3498db', cd: 100 },
    vanguard: { name: 'ÂâçÈãí',   cost: 300, hp: 250, atk: 50, range: 40,  speed: 4.0, type: 'melee',  icon: 'üèá', color: '#e67e22', cd: 150 },
    vice:     { name: 'ÂâØÂ∞áËªç', cost: 500, hp: 600, atk: 70, range: 50,  speed: 1.5, type: 'melee',  icon: 'üõ°Ô∏è', color: '#9b59b6', cd: 300 },
    general:  { name: 'Â§ßÂ∞áËªç', cost: 900, hp: 1200,atk: 120,range: 60,  speed: 1.2, type: 'melee',  icon: 'üëë', color: '#c0392b', cd: 500 }
};

const MAPS = [
    [{x:0,y:2}, {x:3,y:2}, {x:3,y:7}, {x:8,y:7}, {x:8,y:2}, {x:12,y:2}, {x:12,y:6}, {x:14,y:6}],
    [{x:0,y:1}, {x:2,y:1}, {x:2,y:8}, {x:12,y:8}, {x:12,y:1}, {x:14,y:1}],
    [{x:0,y:8}, {x:2,y:8}, {x:2,y:2}, {x:5,y:2}, {x:5,y:8}, {x:8,y:8}, {x:8,y:2}, {x:11,y:2}, {x:11,y:8}, {x:14,y:8}],
    [{x:0,y:5}, {x:4,y:5}, {x:4,y:3}, {x:10,y:3}, {x:10,y:6}, {x:14,y:6}],
    [{x:0,y:0}, {x:13,y:0}, {x:13,y:8}, {x:2,y:8}, {x:2,y:3}, {x:10,y:3}, {x:10,y:5}, {x:14,y:5}],
    [{x:0,y:9}, {x:3,y:9}, {x:3,y:6}, {x:6,y:6}, {x:6,y:3}, {x:9,y:3}, {x:9,y:0}, {x:14,y:0}],
    [{x:0,y:2}, {x:14,y:2}, {x:14,y:5}, {x:0,y:5}, {x:0,y:8}, {x:14,y:8}],
    [{x:0,y:1}, {x:6,y:1}, {x:6,y:5}, {x:8,y:5}, {x:8,y:9}, {x:14,y:9}],
    [{x:0,y:4}, {x:1,y:4}, {x:1,y:9}, {x:13,y:9}, {x:13,y:1}, {x:1,y:1}, {x:1,y:4}, {x:14,y:4}],
    [{x:0,y:0}, {x:0,y:9}, {x:3,y:9}, {x:3,y:2}, {x:6,y:2}, {x:6,y:7}, {x:9,y:7}, {x:9,y:1}, {x:12,y:1}, {x:12,y:8}, {x:14,y:8}]
];

const LEVELS = Array.from({length: 10}, (_, i) => ({
    enemySpawnRate: Math.max(60, 180 - i * 12),
    goldRate: 1 + i * 0.5,
    enemyTypes: i < 2 ? ['sword', 'sword', 'spear'] :
                i < 4 ? ['sword', 'bow', 'spear', 'vanguard'] :
                i < 7 ? ['spear', 'bow', 'vanguard', 'vice'] :
                        ['vanguard', 'vice', 'general'],
    statsMultiplier: 1 + i,
    speedMultiplier: 1 + (i * 0.1)
}));

class GameEngine {
    constructor() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.player = { name: '', id: '', score: 0 };
        
        this.gameState = {
            level: 0,
            gold: 0,
            baseHpPlayer: 1000,
            baseHpEnemy: 1000,
            maxBaseHp: 1000,
            isGameOver: false,
            enemySpawnTimer: 0,
            // ÈóúÈçµ‰øÆÊ≠£ÔºöÈò≤Ê≠¢ÈóúÂç°ÁµêÊùüÊôÇÈÄ£Á∫åËß∏Áôº
            isLevelTransitioning: false
        };

        this.units = []; 
        this.projectiles = [];
        this.particles = [];
        this.pathPixels = [];
        
        this.lastTime = 0;
        this.cooldowns = {}; 
        this.createUnitButtons();
    }

    createUnitButtons() {
        const bar = document.getElementById('bottom-bar');
        bar.innerHTML = '';
        const keys = Object.keys(UNIT_TYPES);
        keys.forEach((key, index) => {
            const u = UNIT_TYPES[key];
            const div = document.createElement('div');
            div.className = 'unit-btn';
            div.id = `btn-${key}`;
            div.onclick = () => this.spawnPlayerUnit(key);
            div.innerHTML = `
                <span class="hotkey">${index+1}</span>
                <div class="unit-icon">${u.icon}</div>
                <div class="unit-name">${u.name}</div>
                <div class="unit-cost">$${u.cost}</div>
                <div class="cooldown-overlay" style="position:absolute;bottom:0;left:0;width:100%;height:0%;background:rgba(0,0,0,0.5);transition:height 0.1s;"></div>
            `;
            bar.appendChild(div);
            this.cooldowns[key] = 0;
        });

        document.addEventListener('keydown', (e) => {
            const idx = parseInt(e.key) - 1;
            if (idx >= 0 && idx < keys.length) {
                this.spawnPlayerUnit(keys[idx]);
            }
        });
    }

    initLogin() {
        const name = document.getElementById('player-name').value.trim();
        if (!name) return alert("Ë´ãËº∏ÂÖ•Â§ßÂêçÔºÅ");
        this.player.name = name;
        this.player.id = 'ID_' + Date.now();
        this.player.startTime = Date.now();
        
        // ÂïüÂãïÈü≥ÊïàÂºïÊìé
        AudioSys.init();
        
        document.getElementById('login-screen').style.display = 'none';
        document.getElementById('game-container').style.display = 'block';
        
        this.startLevel(0);
        this.gameLoop(0);
    }

    startLevel(lvl) {
        // ÈáçÁΩÆËΩâÂ†¥ÁãÄÊÖã
        this.gameState.isLevelTransitioning = false;

        if (lvl >= LEVELS.length) {
            AudioSys.sfx.win_level();
            return this.endGame(true, "Â§©‰∏ãÁµ±‰∏ÄÔºÅ‰∏âÂúãÊ≠∏‰∏ÄÔºÅ");
        }
        
        this.gameState.level = lvl;
        
        // Âú∞Âúñ
        const mapPoints = MAPS[lvl % MAPS.length];
        this.pathPixels = mapPoints.map(p => ({
            x: p.x * CONFIG.gridSize + CONFIG.gridSize/2,
            y: p.y * CONFIG.gridSize + CONFIG.gridSize/2
        }));

        // Èõ£Â∫¶
        const lvlConfig = LEVELS[lvl];
        this.gameState.maxBaseHp = 1000 + (lvl * 1000); 
        this.gameState.baseHpEnemy = this.gameState.maxBaseHp * lvlConfig.statsMultiplier; 
        this.gameState.baseHpPlayer = 1000 + (lvl * 200);
        
        if (lvl === 0) {
            this.gameState.gold = 500;
        } else {
            const bonus = 1000 + (lvl * 500);
            this.gameState.gold += bonus;
            this.showMessage(`Áç≤ÂæóÂá±ÊóãÁçéÈáë $${bonus}ÔºÅ`, false);
        }

        this.units = [];
        this.projectiles = [];
        this.particles = [];
        this.gameState.enemySpawnTimer = 0; // ÈáçÁΩÆÂá∫ÂÖµË®àÊôÇ
        
        this.updateUI();
        
        const enemyStatsText = `(Âº∑Â∫¶: ${Math.round(lvlConfig.statsMultiplier * 100)}%)`;
        document.getElementById('enemy-stats-hint').innerText = enemyStatsText;
        
        setTimeout(() => {
            AudioSys.sfx.win_level(); // Áî®ÂãùÂà©Èü≥ÊïàÁï∂‰ΩúÈñãÂ†¥ËôüËßí
            this.showMessage(`Á¨¨ ${lvl+1} Èóú - ÈÄ≤ÊîªÔºÅ`);
        }, 500);
    }

    spawnPlayerUnit(typeKey) {
        if (this.gameState.isLevelTransitioning || this.gameState.isGameOver) return;

        const data = UNIT_TYPES[typeKey];
        if (this.gameState.gold < data.cost) {
            this.showMessage("ËªçË≤ª‰∏çË∂≥", true);
            return;
        }
        if (this.cooldowns[typeKey] > 0) return;

        this.gameState.gold -= data.cost;
        this.cooldowns[typeKey] = data.cd; 
        
        AudioSys.sfx.spawn(); // Èü≥Êïà

        const startNode = this.pathPixels[this.pathPixels.length - 1];
        const unit = new Unit(startNode.x, startNode.y, 'player', typeKey, this.pathPixels.length - 1, 1, 1);
        this.units.push(unit);
        this.updateUI();
    }

    spawnEnemyUnit() {
        if (this.gameState.isLevelTransitioning) return;

        const lvlData = LEVELS[this.gameState.level];
        const types = lvlData.enemyTypes;
        const randType = types[Math.floor(Math.random() * types.length)];
        
        const startNode = this.pathPixels[0];
        const unit = new Unit(startNode.x, startNode.y, 'enemy', randType, 0, lvlData.statsMultiplier, lvlData.speedMultiplier);
        this.units.push(unit);
    }

    gameLoop(timestamp) {
        if (this.gameState.isGameOver) return;
        if (!this.lastTime) this.lastTime = timestamp;
        const dt = timestamp - this.lastTime;

        if (dt > 16) {
            this.update();
            this.draw();
            this.lastTime = timestamp;
        }
        requestAnimationFrame((t) => this.gameLoop(t));
    }

    update() {
        const lvlData = LEVELS[this.gameState.level];

        // Ë≥áÊ∫ê
        if (!this.gameState.isLevelTransitioning) {
            this.gameState.gold += lvlData.goldRate * 0.5; 
            if (this.gameState.gold > 20000) this.gameState.gold = 20000;
        }

        // ÊïµËªçÁîüÊàê
        this.gameState.enemySpawnTimer++;
        if (this.gameState.enemySpawnTimer > lvlData.enemySpawnRate) {
            this.spawnEnemyUnit();
            this.gameState.enemySpawnTimer = 0;
        }

        // ÂÜ∑Âçª
        for (let key in this.cooldowns) {
            if (this.cooldowns[key] > 0) this.cooldowns[key]--;
            const btn = document.getElementById(`btn-${key}`);
            if(btn) {
                const overlay = btn.querySelector('.cooldown-overlay');
                const percent = (this.cooldowns[key] / UNIT_TYPES[key].cd) * 100;
                overlay.style.height = `${percent}%`;
                if(percent <= 0 && this.gameState.gold < UNIT_TYPES[key].cost) {
                     btn.classList.add('disabled');
                } else {
                     btn.classList.remove('disabled');
                }
            }
        }

        // ÂñÆ‰Ωç
        this.units.sort((a, b) => a.y - b.y);

        for (let i = this.units.length - 1; i >= 0; i--) {
            const u = this.units[i];
            u.update(this);
            if (u.dead) {
                this.units.splice(i, 1);
                if (u.team === 'enemy') {
                    this.gameState.gold += UNIT_TYPES[u.typeKey].cost * 0.3 * lvlData.statsMultiplier;
                    this.player.score += 10 * (this.gameState.level + 1);
                }
            }
        }

        // Â≠êÂΩà
        for (let i = this.projectiles.length - 1; i >= 0; i--) {
            const p = this.projectiles[i];
            p.update();
            if (p.hit) this.projectiles.splice(i, 1);
        }

        // Á≤íÂ≠ê
        this.particles = this.particles.filter(p => p.life > 0);
        this.particles.forEach(p => p.update());

        this.updateUI();

        // ÂãùË≤†Âà§ÂÆö
        if (this.gameState.baseHpPlayer <= 0 && !this.gameState.isGameOver) {
            AudioSys.sfx.game_over();
            this.endGame(false, "ÂüéÊ±†Èô∑ËêΩÔºåÂãùÊïó‰πÉÂÖµÂÆ∂Â∏∏‰∫ã...");
        }

        // ÂãùÂà©Âà§Êñ∑ (‰øÆÊ≠£ÁÑ°ÈôêÂæ™Áí∞ Bug)
        if (this.gameState.baseHpEnemy <= 0 && !this.gameState.isLevelTransitioning) {
            this.gameState.baseHpEnemy = 0;
            this.gameState.isLevelTransitioning = true; // ÈéñÂÆöÁãÄÊÖã
            
            AudioSys.sfx.win_level();
            this.showMessage("ÊïµÁáüÊîªÁ†¥ÔºÅÂÖ®ËªçÊï¥ÂÇôÔºåÂâçÂæÄ‰∏ã‰∏ÄÊà∞Â†¥...", false);
            
            // Ê∏ÖÈô§ÊâÄÊúâÂ≠êÂΩàËàáÊîªÊìäË°åÁÇ∫
            this.units.forEach(u => u.state = 'move');
            
            setTimeout(() => {
                 this.startLevel(this.gameState.level + 1);
            }, 3000);
        }
    }

    draw() {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        
        this.drawPath();

        const start = this.pathPixels[0];
        const end = this.pathPixels[this.pathPixels.length-1];
        
        // ÊïµÊñπÂü∫Âú∞ (3D Âº∑Âåñ)
        const enemyScale = 1 + (this.gameState.level * 0.1);
        drawCylinder(this.ctx, start.x, start.y, 50 * enemyScale, 80 * enemyScale, '#e74c3c', '#c0392b');
        this.drawText(start.x, start.y - 100 * enemyScale, `ÊïµÁáü Lv.${this.gameState.level+1}`, "24px Arial", "#fff");
        
        // ÊàëÊñπÂü∫Âú∞ (3D Âº∑Âåñ)
        drawCylinder(this.ctx, end.x, end.y, 50, 80, '#3498db', '#2980b9');
        this.drawText(end.x, end.y - 100, "ÊàëÂüé", "24px Arial", "#fff");

        this.units.forEach(u => u.draw(this.ctx));
        this.projectiles.forEach(p => p.draw(this.ctx));
        this.particles.forEach(p => p.draw(this.ctx));
    }

    drawPath() {
        this.ctx.lineCap = 'round';
        this.ctx.lineJoin = 'round';
        
        // Ë∑ØÂæëÈô∞ÂΩ± (ÂéöÂ∫¶ÊÑü)
        this.ctx.lineWidth = 70;
        this.ctx.strokeStyle = '#a08d85'; // Ê∑±Ëâ≤Ê≥•Âúü
        this.ctx.beginPath();
        if (this.pathPixels.length > 0) {
            this.ctx.moveTo(this.pathPixels[0].x, this.pathPixels[0].y + 8);
            for (let i = 1; i < this.pathPixels.length; i++) {
                this.ctx.lineTo(this.pathPixels[i].x, this.pathPixels[i].y + 8);
            }
        }
        this.ctx.stroke();

        // Ë∑ØÈù¢
        this.ctx.lineWidth = 70;
        this.ctx.strokeStyle = '#e6d0ce'; // Ê∑∫Ëâ≤Ë∑ØÈù¢
        this.ctx.beginPath();
        if (this.pathPixels.length > 0) {
            this.ctx.moveTo(this.pathPixels[0].x, this.pathPixels[0].y);
            for (let i = 1; i < this.pathPixels.length; i++) {
                this.ctx.lineTo(this.pathPixels[i].x, this.pathPixels[i].y);
            }
        }
        this.ctx.stroke();
    }

    drawText(x, y, text, font, color) {
        this.ctx.font = font;
        this.ctx.fillStyle = color;
        this.ctx.textAlign = "center";
        this.ctx.shadowColor = "rgba(0,0,0,0.8)";
        this.ctx.shadowBlur = 4;
        this.ctx.fillText(text, x, y);
        this.ctx.shadowBlur = 0;
    }

    updateUI() {
        document.getElementById('gold').innerText = Math.floor(this.gameState.gold);
        document.getElementById('wave-info').innerText = `Á¨¨ ${this.gameState.level + 1} Èóú`;
        
        const pPct = Math.max(0, (this.gameState.baseHpPlayer / (1000 + this.gameState.level * 200)) * 100);
        document.getElementById('player-hp-bar').style.width = `${pPct}%`;
        
        const enemyMaxHp = (1000 + (this.gameState.level * 1000)) * LEVELS[this.gameState.level].statsMultiplier;
        const ePct = Math.max(0, (this.gameState.baseHpEnemy / enemyMaxHp) * 100);
        document.getElementById('enemy-hp-bar').style.width = `${ePct}%`;
    }

    showMessage(msg, isWarning = false) {
        const el = document.getElementById('message-area');
        el.innerText = msg;
        el.style.color = isWarning ? '#e74c3c' : '#fff';
        el.style.borderColor = isWarning ? '#e74c3c' : 'gold';
        el.style.display = 'block';
        el.style.opacity = 1;
        
        if(this.msgTimeout) clearTimeout(this.msgTimeout);
        this.msgTimeout = setTimeout(() => {
            el.style.display = 'none';
        }, 1500);
    }

    createEffect(x, y, type) {
        let color = 'white';
        if (type === 'hit') color = 'orange';
        if (type === 'blood') color = 'red';
        for(let i=0; i<6; i++) {
            this.particles.push(new Particle(x, y, color));
        }
    }

    endGame(isWin, reason) {
        this.gameState.isGameOver = true;
        document.getElementById('result-screen').style.display = 'flex';
        document.getElementById('end-title').innerText = isWin ? "üèÜ Â§ßÁç≤ÂÖ®Âãù" : "üíÄ Êà∞Êïó";
        document.getElementById('end-title').style.color = isWin ? "gold" : "#e74c3c";
        document.getElementById('end-reason').innerText = reason;
        
        const duration = Math.floor((Date.now() - this.player.startTime)/1000);
        document.getElementById('final-score').innerText = this.player.score;
        document.getElementById('final-time').innerText = duration + "s";

        this.sendToGas(duration);
    }

    sendToGas(duration) {
        if(CONFIG.gasUrl.includes("exec")) {
            const data = {
                name: this.player.name,
                id: this.player.id,
                score: this.player.score,
                duration: duration,
                date: new Date().toISOString()
            };
            fetch(CONFIG.gasUrl, {
                method: 'POST',
                mode: 'no-cors',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify(data)
            }).then(() => console.log("Sent to GAS")).catch(e => console.error(e));
        }
    }
}

class Unit {
    constructor(x, y, team, typeKey, pathIdx, statsMult = 1, speedMult = 1) {
        this.x = x;
        this.y = y;
        this.team = team; 
        this.typeKey = typeKey;
        
        const data = UNIT_TYPES[typeKey];
        this.name = data.name;
        this.maxHp = data.hp * statsMult;
        this.hp = this.maxHp;
        this.atk = data.atk * statsMult;
        this.range = data.range;
        this.speed = data.speed * speedMult;
        
        this.attackType = data.type; 
        this.icon = data.icon;
        this.color = data.color;

        this.pathIndex = pathIdx;
        this.targetNode = null;
        this.state = 'move'; 
        this.attackCooldown = 0;
        this.dead = false;
        
        this.visualHeight = (typeKey === 'general') ? 50 : 30;
        this.bounce = 0;
        this.scaleY = 0.9; // 3D Â£ìÊâÅÊïàÊûú
    }

    update(game) {
        if (this.dead) return;

        if (this.attackCooldown > 0) this.attackCooldown--;

        let target = this.findTarget(game);
        
        if (target) {
            this.state = 'attack';
            if (this.attackCooldown <= 0) {
                this.attack(target, game);
                this.attackCooldown = 60; 
            }
        } else {
            this.state = 'move';
            this.move(game);
        }

        if (this.state === 'move') {
            this.bounce = Math.abs(Math.sin(Date.now() / 150)) * 5;
        } else {
            this.bounce = 0;
        }
    }

    findTarget(game) {
        for (let u of game.units) {
            if (u.team !== this.team && !u.dead) {
                const dist = Math.hypot(u.x - this.x, u.y - this.y);
                if (dist <= this.range) return u;
            }
        }
        let baseDist = 9999;
        if (this.team === 'player') {
            const base = game.pathPixels[0];
            baseDist = Math.hypot(base.x - this.x, base.y - this.y);
            if (baseDist <= this.range) return { type: 'base', team: 'enemy' };
        } else {
            const base = game.pathPixels[game.pathPixels.length-1];
            baseDist = Math.hypot(base.x - this.x, base.y - this.y);
            if (baseDist <= this.range) return { type: 'base', team: 'player' };
        }
        return null;
    }

    attack(target, game) {
        if (this.attackType === 'ranged') {
            game.projectiles.push(new Projectile(this.x, this.y - this.visualHeight, target, this.atk, this.team));
            AudioSys.sfx.attack_range();
        } else {
            game.createEffect(target.x || this.x, target.y || this.y, 'hit');
            AudioSys.sfx.attack_melee();
            if (target.type === 'base') {
                if (target.team === 'player') game.gameState.baseHpPlayer -= this.atk;
                else game.gameState.baseHpEnemy -= this.atk;
                game.createEffect(this.x, this.y, 'hit'); 
            } else {
                target.takeDamage(this.atk, game);
            }
        }
    }

    move(game) {
        let nextIdx = (this.team === 'player') ? this.pathIndex - 1 : this.pathIndex + 1;
        
        if (nextIdx < 0 || nextIdx >= game.pathPixels.length) {
            return; 
        }

        const targetNode = game.pathPixels[nextIdx];
        const dx = targetNode.x - this.x;
        const dy = targetNode.y - this.y;
        const dist = Math.hypot(dx, dy);

        if (dist <= this.speed) {
            this.x = targetNode.x;
            this.y = targetNode.y;
            this.pathIndex = nextIdx;
        } else {
            this.x += (dx / dist) * this.speed;
            this.y += (dy / dist) * this.speed;
        }
    }

    takeDamage(amount, game) {
        this.hp -= amount;
        game.createEffect(this.x, this.y - this.visualHeight, 'blood');
        if (this.hp <= 0) {
            this.dead = true;
            AudioSys.sfx.hit();
        }
    }

    draw(ctx) {
        const drawY = this.y - this.visualHeight - this.bounce;

        // 3D Èô∞ÂΩ± (ÂçäÈÄèÊòéÈªëËâ≤Ê©¢Âúì)
        ctx.fillStyle = "rgba(0,0,0,0.3)";
        ctx.beginPath();
        ctx.ellipse(this.x, this.y, 18, 10, 0, 0, Math.PI*2);
        ctx.fill();

        // Ë∫´È´î (‰ΩøÁî® drawCylinder Áï´Ë∫´È´îÊõ¥Êúâ 3D ÊÑü)
        // ÈÄôË£°Á∞°ÂåñÁÇ∫ÂúìÂΩ¢‰ΩÜÂä†‰∏äÊº∏Â±§
        const grad = ctx.createRadialGradient(this.x - 5, drawY - 5, 2, this.x, drawY, 20);
        grad.addColorStop(0, this.color);
        grad.addColorStop(1, this.team === 'player' ? '#2980b9' : '#c0392b'); // Èô∞ÂΩ±Ëâ≤

        ctx.fillStyle = grad;
        ctx.lineWidth = 2;
        ctx.strokeStyle = '#fff';
        
        ctx.beginPath();
        ctx.arc(this.x, drawY, 22, 0, Math.PI*2);
        ctx.fill();
        ctx.stroke();

        ctx.font = "24px Arial";
        ctx.fillStyle = "#fff";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.shadowColor = "rgba(0,0,0,0.5)";
        ctx.shadowBlur = 2;
        ctx.fillText(this.icon, this.x, drawY);
        ctx.shadowBlur = 0;

        // Ë°ÄÊ¢ù (Êõ¥Á≤æÁ∑ª)
        const hpPct = this.hp / this.maxHp;
        const barY = drawY - 35;
        ctx.fillStyle = "#555";
        ctx.fillRect(this.x - 18, barY, 36, 6);
        ctx.fillStyle = hpPct > 0.5 ? "#2ecc71" : "#e74c3c";
        ctx.fillRect(this.x - 18, barY, 36 * hpPct, 6);
        ctx.strokeStyle = "#fff";
        ctx.lineWidth = 1;
        ctx.strokeRect(this.x - 18, barY, 36, 6);
    }
}

class Projectile {
    constructor(x, y, target, dmg, team) {
        this.x = x; this.y = y;
        this.target = target;
        this.damage = dmg;
        this.team = team;
        this.speed = 12;
        this.hit = false;
        
        this.tx = target.x || (team === 'player' ? Game.pathPixels[0].x : Game.pathPixels[Game.pathPixels.length-1].x);
        this.ty = target.y || (team === 'player' ? Game.pathPixels[0].y : Game.pathPixels[Game.pathPixels.length-1].y);
        if(target.visualHeight) this.ty -= target.visualHeight;
    }

    update() {
        if (this.target && !this.target.dead) {
            this.tx = this.target.x || this.tx;
            this.ty = (this.target.y || this.ty) - (this.target.visualHeight || 30);
        }

        const dx = this.tx - this.x;
        const dy = this.ty - this.y;
        const dist = Math.hypot(dx, dy);

        if (dist <= this.speed) {
            this.hit = true;
            Game.createEffect(this.tx, this.ty, 'hit');
            AudioSys.sfx.hit(); // Êìä‰∏≠Èü≥Êïà
            if (this.target.type === 'base') {
                if (this.target.team === 'player') Game.gameState.baseHpPlayer -= this.damage;
                else Game.gameState.baseHpEnemy -= this.damage;
            } else if (this.target.takeDamage) {
                this.target.takeDamage(this.damage, Game);
            }
        } else {
            this.x += (dx/dist) * this.speed;
            this.y += (dy/dist) * this.speed;
        }
    }

    draw(ctx) {
        ctx.fillStyle = this.team === 'player' ? '#3498db' : '#e74c3c';
        ctx.beginPath();
        ctx.arc(this.x, this.y, 6, 0, Math.PI*2);
        ctx.fill();
    }
}

class Particle {
    constructor(x, y, color) {
        this.x = x; this.y = y; this.color = color;
        this.vx = (Math.random()-0.5)*6;
        this.vy = (Math.random()-0.5)*6;
        this.life = 1.0;
        this.gravity = 0.2;
    }
    update() {
        this.x += this.vx; this.y += this.vy; 
        this.vy += this.gravity;
        this.life -= 0.05;
    }
    draw(ctx) {
        ctx.globalAlpha = Math.max(0, this.life);
        ctx.fillStyle = this.color;
        ctx.beginPath(); ctx.arc(this.x, this.y, 4, 0, Math.PI*2); ctx.fill();
        ctx.globalAlpha = 1;
    }
}

const Game = new GameEngine();

</script>
</body>
</html>
