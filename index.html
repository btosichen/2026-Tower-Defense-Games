<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ä¸‰åœ‹ç­–ç•¥æ”»é˜²æˆ° (3Dè‡ªç”±è¦–è§’ç‰ˆ)v0127</title>
    <style>
        :root {
            --primary-color: #f39c12; /* ä¸‰åœ‹é‡‘ */
            --secondary-color: #c0392b; /* æˆ°æ——ç´… */
            --player-color: #2980b9;  /* æˆ‘è»è— */
            --enemy-color: #c0392b;   /* æ•µè»ç´… */
            --bg-color: #fcf3cf;
            --ui-bg: rgba(255, 255, 255, 0.9);
        }

        body {
            margin: 0;
            padding: 0;
            font-family: "Microsoft JhengHei", "Heiti TC", sans-serif;
            background-color: #2c3e50;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            overflow: hidden;
            user-select: none;
        }

        #game-container {
            position: relative;
            width: 1200px;
            height: 800px;
            background-color: #a9dfbf; /* é è¨­è‰åœ°è‰² */
            box-shadow: 0 0 50px rgba(0,0,0,0.8);
            border-radius: 12px;
            overflow: hidden;
            display: none;
            cursor: grab; /* é è¨­æ¸¸æ¨™ç‚ºæŠ“å–æ‰‹å‹¢ */
        }
        
        #game-container:active {
            cursor: grabbing; /* æŠ“å–ä¸­ */
        }
        
        @media (max-width: 1220px), (max-height: 820px) {
            #game-container { transform: scale(0.8); }
        }
        @media (max-width: 980px) {
            #game-container { transform: scale(0.6); }
        }

        canvas {
            display: block;
            /* èƒŒæ™¯ç´‹ç†ç¾åœ¨ç”± JS ç¹ªè£½ä»¥æ”¯æ´æ—‹è½‰ */
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .hud-panel {
            position: absolute;
            background: var(--ui-bg);
            border: 2px solid var(--primary-color);
            border-radius: 8px;
            padding: 8px;
            pointer-events: auto;
            color: #2c3e50;
            font-weight: bold;
            box-shadow: 0 4px 6px rgba(0,0,0,0.2);
            backdrop-filter: blur(4px);
        }

        /* Top Bar - ç˜¦èº«ç‰ˆ */
        #top-bar {
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            height: 50px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 16px;
            border-radius: 25px;
            background: rgba(255, 255, 255, 0.95);
        }

        .hp-bar-container {
            width: 200px; /* ç¸®çŸ­è¡€æ¢ */
            height: 16px;
            background: #34495e;
            border-radius: 8px;
            overflow: hidden;
            border: 2px solid #fff;
            position: relative;
            margin: 0 10px;
        }

        .hp-bar-fill {
            height: 100%;
            transition: width 0.2s;
            position: relative;
        }

        /* Camera Controls - æ–°å¢ */
        #cam-controls {
            position: absolute;
            right: 20px;
            top: 80px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            pointer-events: auto;
        }

        .cam-btn {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: 2px solid #fff;
            background: rgba(44, 62, 80, 0.8);
            color: white;
            font-size: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: 0.2s;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }
        .cam-btn:hover { background: var(--primary-color); transform: scale(1.1); }
        .cam-btn:active { transform: scale(0.9); }

        /* Bottom Bar (Unit Selection) */
        #bottom-bar {
            bottom: 15px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 8px;
            padding: 10px 20px;
            width: auto;
            justify-content: center;
            border-radius: 15px;
        }

        .unit-btn {
            width: 80px;
            height: 100px;
            border: 2px solid #95a5a6;
            border-radius: 8px;
            background: linear-gradient(to bottom, #fff, #ecf0f1);
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: all 0.1s;
            position: relative;
            box-shadow: 0 4px 0 #7f8c8d;
            overflow: hidden;
        }

        .unit-btn:active { transform: translateY(4px); box-shadow: 0 2px 0 #7f8c8d; }
        .unit-btn.disabled { filter: grayscale(100%); opacity: 0.6; cursor: not-allowed; background: #bdc3c7; }
        .unit-icon { font-size: 32px; margin-bottom: 2px; }
        .unit-name { font-size: 12px; font-weight: 800; color: #2c3e50; }
        .unit-cost { 
            background: gold; color: #d35400; padding: 1px 6px; 
            border-radius: 4px; font-size: 12px; border: 1px solid #e67e22;
            margin-top: 2px; font-weight: bold;
        }
        .hotkey { position: absolute; top: 2px; right: 5px; font-size: 10px; color: #7f8c8d; }

        /* Screens */
        #login-screen, #result-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(44, 62, 80, 0.98);
            display: flex; flex-direction: column;
            justify-content: center; align-items: center;
            color: white; z-index: 100;
        }
        .panel-box {
            background: #fff; padding: 40px; border-radius: 20px;
            text-align: center; color: #2c3e50;
            border: 6px solid var(--primary-color);
            width: 450px;
            box-shadow: 0 20px 50px rgba(0,0,0,0.5);
        }
        input {
            padding: 15px; font-size: 20px; width: 80%;
            margin: 20px 0; text-align: center; border: 2px solid #bdc3c7; border-radius: 8px;
        }
        button.start-btn {
            background: var(--secondary-color); color: white; border: none;
            padding: 15px 50px; font-size: 24px; border-radius: 40px;
            cursor: pointer; transition: 0.3s; box-shadow: 0 6px 0 #922b21;
        }
        button.start-btn:hover { transform: translateY(-3px); box-shadow: 0 9px 0 #922b21; }

        /* Message */
        #message-area {
            position: absolute; top: 40%; left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.85); color: #fff;
            padding: 15px 40px; border-radius: 50px;
            font-size: 28px; font-weight: bold;
            display: none; pointer-events: none;
            z-index: 50; border: 3px solid gold;
        }
    </style>
</head>
<body>

    <div id="login-screen">
        <div class="panel-box">
            <h1 style="font-size: 48px; margin-bottom: 20px;">âš”ï¸ ä¸‰åœ‹ç­–ç•¥æ”»é˜²æˆ°</h1>
            <p style="font-size: 18px; color: #7f8c8d;">å…¨3Dè¦–è§’ãƒ»è‡ªç”±ç¸®æ”¾</p>
            <input type="text" id="player-name" placeholder="è«‹è¼¸å…¥å°‡è»å¤§å" maxlength="10">
            <button class="start-btn" onclick="Game.initLogin()">å‡ºå¾</button>
        </div>
    </div>

    <div id="game-container">
        <canvas id="gameCanvas" width="1200" height="800"></canvas>
        
        <div id="ui-layer">
            <div id="top-bar" class="hud-panel">
                <div style="display:flex; align-items:center;">
                    <span style="color:var(--enemy-color); margin-right:5px;">ğŸš© æ•µç‡Ÿ</span>
                    <div class="hp-bar-container">
                        <div id="enemy-hp-bar" class="hp-bar-fill" style="width: 100%; background: linear-gradient(to right, #e74c3c, #c0392b);"></div>
                    </div>
                    <span id="enemy-stats-hint" style="font-size:12px;color:#e74c3c; margin-left:5px;"></span>
                </div>

                <div style="text-align:center; min-width: 150px;">
                    <div id="wave-info" style="font-size:20px; color:var(--primary-color); font-weight:900;">ç¬¬ 1 é—œ</div>
                    <div style="font-size:16px;">ğŸ’° <span id="gold" style="color:#d35400;">0</span></div>
                </div>

                <div style="display:flex; align-items:center;">
                    <span style="color:var(--player-color); margin-right:5px;">ğŸ›¡ï¸ æˆ‘åŸ</span>
                    <div class="hp-bar-container">
                        <div id="player-hp-bar" class="hp-bar-fill" style="width: 100%; background: linear-gradient(to right, #3498db, #2980b9);"></div>
                    </div>
                </div>
            </div>

            <!-- é¡é ­æ§åˆ¶é¢æ¿ -->
            <div id="cam-controls">
                <div class="cam-btn" onclick="Game.camera.zoomIn()" title="æ”¾å¤§ (+)">â•</div>
                <div class="cam-btn" onclick="Game.camera.zoomOut()" title="ç¸®å° (-)">â–</div>
                <div class="cam-btn" onclick="Game.camera.rotate(-0.1)" title="å·¦æ—‹è½‰ (Q)">â†º</div>
                <div class="cam-btn" onclick="Game.camera.rotate(0.1)" title="å³æ—‹è½‰ (E)">â†»</div>
                <div class="cam-btn" onclick="Game.camera.reset()" title="é‡ç½®è¦–è§’ (R)">ğŸ¯</div>
            </div>

            <div id="message-area">æˆ°é¬¥é–‹å§‹ï¼</div>

            <div id="bottom-bar" class="hud-panel"></div>
        </div>
    </div>

    <div id="result-screen" style="display: none;">
        <div class="panel-box">
            <h1 id="end-title" style="font-size: 48px;">æˆ°å½¹çµæŸ</h1>
            <p id="end-reason" style="font-size: 20px; color: #555;">...</p>
            <div style="text-align:left; margin: 30px 0; font-size: 20px; background: #f9f9f9; padding: 20px; border-radius: 10px;">
                <div style="margin-bottom: 10px;">ğŸ… ç¸½åˆ†ï¼š<span id="final-score" style="font-weight:bold; color:var(--primary-color);">0</span></div>
                <div>â±ï¸ è€—æ™‚ï¼š<span id="final-time" style="font-weight:bold;">0s</span></div>
            </div>
            <button class="start-btn" onclick="location.reload()">å†æˆ°ä¸€å ´</button>
        </div>
    </div>

<script>
/**
 * éŸ³æ•ˆç®¡ç†å™¨
 */
const AudioSys = {
    ctx: null,
    init: function() {
        if (!this.ctx) {
            this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        }
        if (this.ctx.state === 'suspended') this.ctx.resume();
    },
    playTone: function(freq, type, duration, vol = 0.1) {
        if (!this.ctx) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
        gain.gain.setValueAtTime(vol, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.start();
        osc.stop(this.ctx.currentTime + duration);
    },
    sfx: {
        spawn: () => AudioSys.playTone(400, 'triangle', 0.1, 0.1),
        attack_melee: () => AudioSys.playTone(100, 'sawtooth', 0.1, 0.05),
        attack_range: () => AudioSys.playTone(800, 'sine', 0.1, 0.05),
        hit: () => AudioSys.playTone(150, 'square', 0.1, 0.05),
        win_level: () => { if(AudioSys.ctx) [440, 554, 659].forEach((f, i) => setTimeout(() => AudioSys.playTone(f, 'square', 0.4, 0.1), i * 100)); },
        game_over: () => { if(AudioSys.ctx) [300, 250, 200].forEach((f, i) => setTimeout(() => AudioSys.playTone(f, 'sawtooth', 0.5, 0.1), i * 300)); }
    }
};

/**
 * é¡é ­ç³»çµ± (è² è²¬åº§æ¨™è½‰æ›)
 */
class Camera {
    constructor(width, height) {
        this.width = width;
        this.height = height;
        this.x = width / 2;
        this.y = height / 2;
        this.zoom = 1;
        this.angle = 0; // æ—‹è½‰è§’åº¦ (å¼§åº¦)
        this.dragStart = null;
    }

    // å°‡ä¸–ç•Œåº§æ¨™è½‰æ›ç‚ºè¢å¹•åº§æ¨™
    toScreen(x, y) {
        // 1. ç›¸å°æ–¼é¡é ­ä¸­å¿ƒçš„ä½ç§»
        let dx = x - this.x;
        let dy = y - this.y;

        // 2. æ—‹è½‰
        let cos = Math.cos(this.angle);
        let sin = Math.sin(this.angle);
        let rx = dx * cos - dy * sin;
        let ry = dx * sin + dy * cos;

        // 3. ç¸®æ”¾ä¸¦åŠ ä¸Šè¢å¹•ä¸­å¿ƒåç§»
        return {
            x: this.width / 2 + rx * this.zoom,
            y: this.height / 2 + ry * this.zoom,
            scale: this.zoom
        };
    }

    // æ§åˆ¶åŠŸèƒ½
    zoomIn() { this.zoom = Math.min(this.zoom * 1.1, 3); }
    zoomOut() { this.zoom = Math.max(this.zoom / 1.1, 0.5); }
    rotate(rad) { this.angle += rad; }
    reset() { this.zoom = 1; this.angle = 0; this.x = this.width/2; this.y = this.height/2; }
    
    // æ‹–æ›³é‚è¼¯
    handleMouseDown(e) { this.dragStart = { x: e.clientX, y: e.clientY, camX: this.x, camY: this.y }; }
    handleMouseMove(e) {
        if (!this.dragStart) return;
        const dx = (e.clientX - this.dragStart.x) / this.zoom;
        const dy = (e.clientY - this.dragStart.y) / this.zoom;
        
        // é€†æ—‹è½‰ä½ç§»é‡ï¼Œç¢ºä¿æ‹–æ›³æ–¹å‘ç¬¦åˆè¦–è¦º
        let cos = Math.cos(-this.angle);
        let sin = Math.sin(-this.angle);
        
        this.x = this.dragStart.camX - (dx * cos - dy * sin);
        this.y = this.dragStart.camY - (dx * sin + dy * cos);
    }
    handleMouseUp() { this.dragStart = null; }
    handleWheel(e) {
        e.preventDefault();
        if (e.deltaY < 0) this.zoomIn(); else this.zoomOut();
    }
}

/**
 * ç¹ªåœ–è¼”åŠ©: æ”¯æ´æ—‹è½‰çš„ 3D åœ“æŸ±é«”
 */
function drawCylinder3D(ctx, screenPos, radius, height, color, sideColor) {
    const x = screenPos.x;
    const y = screenPos.y;
    const s = screenPos.scale;
    const r = radius * s;
    const h = height * s;

    // å› ç‚ºæˆ‘å€‘æ˜¯è½‰æ›äº†ä¸­å¿ƒé»ï¼Œä½†æ²’æœ‰æ—‹è½‰ Canvas Context (ç‚ºäº†ä¿æŒ UI/æ–‡å­—æ­£å¸¸)ï¼Œ
    // æ‰€ä»¥åœ“æŸ±é«”çš„ã€Œé«˜åº¦ã€æ°¸é æ˜¯å‘ä¸Šçš„ (Screen Y è² æ–¹å‘)ã€‚
    // é€™æ¨£ç„¡è«–åœ°åœ–æ€éº¼è½‰ï¼Œå»ºç¯‰ç‰©æ°¸é æœå‘è¢å¹•ä¸Šæ–¹ï¼Œç¬¦åˆ 2.5D éŠæˆ²é‚è¼¯ã€‚

    // 1. åº•éƒ¨é™°å½±
    ctx.fillStyle = "rgba(0,0,0,0.3)";
    ctx.beginPath();
    ctx.ellipse(x, y, r, r * 0.4, 0, 0, Math.PI * 2);
    ctx.fill();

    // 2. å´é¢ (æ¼¸å±¤)
    const gradient = ctx.createLinearGradient(x - r, y, x + r, y);
    gradient.addColorStop(0, sideColor);
    gradient.addColorStop(0.2, color);
    gradient.addColorStop(0.5, color);
    gradient.addColorStop(0.8, color);       
    gradient.addColorStop(1, sideColor);

    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.moveTo(x - r, y - h);
    ctx.lineTo(x + r, y - h);
    ctx.lineTo(x + r, y);
    ctx.lineTo(x - r, y);
    ctx.closePath();
    ctx.fill();
    ctx.strokeStyle = "rgba(0,0,0,0.1)"; ctx.lineWidth = 1; ctx.stroke();

    // 3. é ‚éƒ¨
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.ellipse(x, y - h, r, r * 0.4, 0, 0, Math.PI * 2);
    ctx.fill();
    // é«˜å…‰
    ctx.fillStyle = "rgba(255,255,255,0.15)";
    ctx.beginPath();
    ctx.ellipse(x, y - h, r * 0.8, r * 0.3, 0, 0, Math.PI * 2);
    ctx.fill();
}

/**
 * éŠæˆ²è¨­å®š
 */
const CONFIG = {
    gridSize: 80, 
    width: 15, height: 10,
    gasUrl: 'https://script.google.com/macros/s/AKfycbwqZFv8Jzk4A1ERYbzljRudebPBTlBn4OcSsFWfWBGLTIKGSMDEd3focinsGovte4c9/exec'
};

const UNIT_TYPES = {
    sword:    { name: 'åˆ€å…µ',   cost: 50,  hp: 120, atk: 15, range: 40,  speed: 2.5, type: 'melee',  icon: 'ğŸ—¡ï¸', color: '#f1c40f', cd: 60 },
    bow:      { name: 'å¼“å…µ',   cost: 120, hp: 80,  atk: 25, range: 250, speed: 2.5, type: 'ranged', icon: 'ğŸ¹', color: '#2ecc71', cd: 80 },
    spear:    { name: 'æ§å…µ',   cost: 200, hp: 180, atk: 40, range: 70,  speed: 2.0, type: 'melee',  icon: 'ğŸ”±', color: '#3498db', cd: 100 },
    vanguard: { name: 'å‰é‹’',   cost: 300, hp: 250, atk: 50, range: 40,  speed: 4.0, type: 'melee',  icon: 'ğŸ‡', color: '#e67e22', cd: 150 },
    vice:     { name: 'å‰¯å°‡è»', cost: 500, hp: 600, atk: 70, range: 50,  speed: 1.5, type: 'melee',  icon: 'ğŸ›¡ï¸', color: '#9b59b6', cd: 300 },
    general:  { name: 'å¤§å°‡è»', cost: 900, hp: 1200,atk: 120,range: 60,  speed: 1.2, type: 'melee',  icon: 'ğŸ‘‘', color: '#c0392b', cd: 500 }
};

const MAPS = [
    [{x:0,y:2}, {x:3,y:2}, {x:3,y:7}, {x:8,y:7}, {x:8,y:2}, {x:12,y:2}, {x:12,y:6}, {x:14,y:6}],
    [{x:0,y:1}, {x:2,y:1}, {x:2,y:8}, {x:12,y:8}, {x:12,y:1}, {x:14,y:1}],
    [{x:0,y:8}, {x:2,y:8}, {x:2,y:2}, {x:5,y:2}, {x:5,y:8}, {x:8,y:8}, {x:8,y:2}, {x:11,y:2}, {x:11,y:8}, {x:14,y:8}],
    [{x:0,y:5}, {x:4,y:5}, {x:4,y:3}, {x:10,y:3}, {x:10,y:6}, {x:14,y:6}],
    [{x:0,y:0}, {x:13,y:0}, {x:13,y:8}, {x:2,y:8}, {x:2,y:3}, {x:10,y:3}, {x:10,y:5}, {x:14,y:5}],
    [{x:0,y:9}, {x:3,y:9}, {x:3,y:6}, {x:6,y:6}, {x:6,y:3}, {x:9,y:3}, {x:9,y:0}, {x:14,y:0}],
    [{x:0,y:2}, {x:14,y:2}, {x:14,y:5}, {x:0,y:5}, {x:0,y:8}, {x:14,y:8}],
    [{x:0,y:1}, {x:6,y:1}, {x:6,y:5}, {x:8,y:5}, {x:8,y:9}, {x:14,y:9}],
    [{x:0,y:4}, {x:1,y:4}, {x:1,y:9}, {x:13,y:9}, {x:13,y:1}, {x:1,y:1}, {x:1,y:4}, {x:14,y:4}],
    [{x:0,y:0}, {x:0,y:9}, {x:3,y:9}, {x:3,y:2}, {x:6,y:2}, {x:6,y:7}, {x:9,y:7}, {x:9,y:1}, {x:12,y:1}, {x:12,y:8}, {x:14,y:8}]
];

const LEVELS = Array.from({length: 10}, (_, i) => ({
    enemySpawnRate: Math.max(60, 180 - i * 12),
    goldRate: 1 + i * 0.5,
    enemyTypes: i < 2 ? ['sword', 'sword', 'spear'] :
                i < 4 ? ['sword', 'bow', 'spear', 'vanguard'] :
                i < 7 ? ['spear', 'bow', 'vanguard', 'vice'] :
                        ['vanguard', 'vice', 'general'],
    statsMultiplier: 1 + i,
    speedMultiplier: 1 + (i * 0.1)
}));

class GameEngine {
    constructor() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.player = { name: '', id: '', score: 0 };
        this.camera = new Camera(1200, 800);
        
        this.gameState = {
            level: 0, gold: 0,
            baseHpPlayer: 1000, baseHpEnemy: 1000, maxBaseHp: 1000,
            isGameOver: false, enemySpawnTimer: 0, isLevelTransitioning: false
        };

        this.units = []; this.projectiles = []; this.particles = []; this.pathPixels = [];
        this.lastTime = 0;
        this.cooldowns = {}; 
        this.createUnitButtons();

        // ç¶å®šé¡é ­äº‹ä»¶
        const container = document.getElementById('game-container');
        container.addEventListener('mousedown', e => this.camera.handleMouseDown(e));
        window.addEventListener('mousemove', e => this.camera.handleMouseMove(e));
        window.addEventListener('mouseup', () => this.camera.handleMouseUp());
        container.addEventListener('wheel', e => this.camera.handleWheel(e));
        
        // ç¶å®šéµç›¤æ—‹è½‰
        document.addEventListener('keydown', e => {
            if (e.key === 'q' || e.key === 'Q') this.camera.rotate(-0.1);
            if (e.key === 'e' || e.key === 'E') this.camera.rotate(0.1);
            if (e.key === 'r' || e.key === 'R') this.camera.reset();
        });
    }

    createUnitButtons() {
        const bar = document.getElementById('bottom-bar');
        bar.innerHTML = '';
        const keys = Object.keys(UNIT_TYPES);
        keys.forEach((key, index) => {
            const u = UNIT_TYPES[key];
            const div = document.createElement('div');
            div.className = 'unit-btn';
            div.id = `btn-${key}`;
            div.onclick = () => this.spawnPlayerUnit(key);
            div.innerHTML = `
                <span class="hotkey">${index+1}</span>
                <div class="unit-icon">${u.icon}</div>
                <div class="unit-name">${u.name}</div>
                <div class="unit-cost">$${u.cost}</div>
                <div class="cooldown-overlay" style="position:absolute;bottom:0;left:0;width:100%;height:0%;background:rgba(0,0,0,0.5);transition:height 0.1s;"></div>
            `;
            bar.appendChild(div);
            this.cooldowns[key] = 0;
        });
        document.addEventListener('keydown', (e) => {
            const idx = parseInt(e.key) - 1;
            if (idx >= 0 && idx < keys.length) this.spawnPlayerUnit(keys[idx]);
        });
    }

    initLogin() {
        const name = document.getElementById('player-name').value.trim();
        if (!name) return alert("è«‹è¼¸å…¥å¤§åï¼");
        this.player.name = name; this.player.id = 'ID_' + Date.now(); this.player.startTime = Date.now();
        AudioSys.init();
        document.getElementById('login-screen').style.display = 'none';
        document.getElementById('game-container').style.display = 'block';
        this.startLevel(0);
        this.gameLoop(0);
    }

    startLevel(lvl) {
        this.gameState.isLevelTransitioning = false;
        if (lvl >= LEVELS.length) { AudioSys.sfx.win_level(); return this.endGame(true, "å¤©ä¸‹çµ±ä¸€ï¼ä¸‰åœ‹æ­¸ä¸€ï¼"); }
        
        this.gameState.level = lvl;
        this.camera.reset(); // æ¯é—œé‡ç½®è¦–è§’
        
        const mapPoints = MAPS[lvl % MAPS.length];
        this.pathPixels = mapPoints.map(p => ({
            x: p.x * CONFIG.gridSize + CONFIG.gridSize/2,
            y: p.y * CONFIG.gridSize + CONFIG.gridSize/2
        }));

        const lvlConfig = LEVELS[lvl];
        this.gameState.maxBaseHp = 1000 + (lvl * 1000); 
        this.gameState.baseHpEnemy = this.gameState.maxBaseHp * lvlConfig.statsMultiplier; 
        this.gameState.baseHpPlayer = 1000 + (lvl * 200);
        
        if (lvl === 0) this.gameState.gold = 500;
        else {
            const bonus = 1000 + (lvl * 500);
            this.gameState.gold += bonus;
            this.showMessage(`ç²å¾—å‡±æ—‹çé‡‘ $${bonus}ï¼`, false);
        }

        this.units = []; this.projectiles = []; this.particles = []; this.gameState.enemySpawnTimer = 0;
        this.updateUI();
        document.getElementById('enemy-stats-hint').innerText = `(å¼·åº¦: ${Math.round(lvlConfig.statsMultiplier * 100)}%)`;
        setTimeout(() => { AudioSys.sfx.win_level(); this.showMessage(`ç¬¬ ${lvl+1} é—œ - é€²æ”»ï¼`); }, 500);
    }

    spawnPlayerUnit(typeKey) {
        if (this.gameState.isLevelTransitioning || this.gameState.isGameOver) return;
        const data = UNIT_TYPES[typeKey];
        if (this.gameState.gold < data.cost) return this.showMessage("è»è²»ä¸è¶³", true);
        if (this.cooldowns[typeKey] > 0) return;

        this.gameState.gold -= data.cost; this.cooldowns[typeKey] = data.cd; 
        AudioSys.sfx.spawn();
        const startNode = this.pathPixels[this.pathPixels.length - 1];
        this.units.push(new Unit(startNode.x, startNode.y, 'player', typeKey, this.pathPixels.length - 1, 1, 1));
        this.updateUI();
    }

    spawnEnemyUnit() {
        if (this.gameState.isLevelTransitioning) return;
        const lvlData = LEVELS[this.gameState.level];
        const types = lvlData.enemyTypes;
        const randType = types[Math.floor(Math.random() * types.length)];
        const startNode = this.pathPixels[0];
        this.units.push(new Unit(startNode.x, startNode.y, 'enemy', randType, 0, lvlData.statsMultiplier, lvlData.speedMultiplier));
    }

    gameLoop(timestamp) {
        if (this.gameState.isGameOver) return;
        if (!this.lastTime) this.lastTime = timestamp;
        const dt = timestamp - this.lastTime;
        if (dt > 16) { this.update(); this.draw(); this.lastTime = timestamp; }
        requestAnimationFrame((t) => this.gameLoop(t));
    }

    update() {
        const lvlData = LEVELS[this.gameState.level];
        if (!this.gameState.isLevelTransitioning) {
            this.gameState.gold += lvlData.goldRate * 0.5; 
            if (this.gameState.gold > 20000) this.gameState.gold = 20000;
        }

        this.gameState.enemySpawnTimer++;
        if (this.gameState.enemySpawnTimer > lvlData.enemySpawnRate) {
            this.spawnEnemyUnit();
            this.gameState.enemySpawnTimer = 0;
        }

        for (let key in this.cooldowns) {
            if (this.cooldowns[key] > 0) this.cooldowns[key]--;
            const btn = document.getElementById(`btn-${key}`);
            if(btn) {
                const overlay = btn.querySelector('.cooldown-overlay');
                const percent = (this.cooldowns[key] / UNIT_TYPES[key].cd) * 100;
                overlay.style.height = `${percent}%`;
                if(percent <= 0 && this.gameState.gold < UNIT_TYPES[key].cost) btn.classList.add('disabled');
                else btn.classList.remove('disabled');
            }
        }

        this.units.sort((a, b) => a.y - b.y);
        for (let i = this.units.length - 1; i >= 0; i--) {
            const u = this.units[i];
            u.update(this);
            if (u.dead) {
                this.units.splice(i, 1);
                if (u.team === 'enemy') {
                    this.gameState.gold += UNIT_TYPES[u.typeKey].cost * 0.3 * lvlData.statsMultiplier;
                    this.player.score += 10 * (this.gameState.level + 1);
                }
            }
        }

        for (let i = this.projectiles.length - 1; i >= 0; i--) {
            const p = this.projectiles[i];
            p.update();
            if (p.hit) this.projectiles.splice(i, 1);
        }

        this.particles = this.particles.filter(p => p.life > 0);
        this.particles.forEach(p => p.update());
        this.updateUI();

        if (this.gameState.baseHpPlayer <= 0 && !this.gameState.isGameOver) {
            AudioSys.sfx.game_over(); this.endGame(false, "åŸæ± é™·è½ï¼Œå‹æ•—ä¹ƒå…µå®¶å¸¸äº‹...");
        }
        if (this.gameState.baseHpEnemy <= 0 && !this.gameState.isLevelTransitioning) {
            this.gameState.baseHpEnemy = 0; this.gameState.isLevelTransitioning = true;
            AudioSys.sfx.win_level(); this.showMessage("æ•µç‡Ÿæ”»ç ´ï¼å…¨è»æ•´å‚™...", false);
            this.units.forEach(u => u.state = 'move');
            setTimeout(() => { this.startLevel(this.gameState.level + 1); }, 3000);
        }
    }

    draw() {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        
        // 1. ç¹ªè£½ä¸–ç•Œç¶²æ ¼ (éœ€è®Šæ›)
        this.drawGrid();

        // 2. ç¹ªè£½è·¯å¾‘ (éœ€è®Šæ›)
        this.drawPath();

        const start = this.pathPixels[0];
        const end = this.pathPixels[this.pathPixels.length-1];
        
        // 3. ç¹ªè£½åŸºåœ° (ä½¿ç”¨ 3D æŠ•å½±)
        const startPos = this.camera.toScreen(start.x, start.y);
        const endPos = this.camera.toScreen(end.x, end.y);
        const enemyScale = 1 + (this.gameState.level * 0.1);
        
        drawCylinder3D(this.ctx, startPos, 50 * enemyScale, 80 * enemyScale, '#e74c3c', '#c0392b');
        this.drawText(startPos.x, startPos.y - (100 * enemyScale * startPos.scale), `æ•µç‡Ÿ Lv.${this.gameState.level+1}`, "24px Arial", "#fff");
        
        drawCylinder3D(this.ctx, endPos, 50, 80, '#3498db', '#2980b9');
        this.drawText(endPos.x, endPos.y - (100 * endPos.scale), "æˆ‘åŸ", "24px Arial", "#fff");

        // 4. ç¹ªè£½å–®ä½èˆ‡ç‰¹æ•ˆ
        this.units.forEach(u => u.draw(this.ctx, this.camera));
        this.projectiles.forEach(p => p.draw(this.ctx, this.camera));
        this.particles.forEach(p => p.draw(this.ctx, this.camera));
    }

    drawGrid() {
        // ç°¡å–®ç¹ªè£½ä¸€å€‹å¤§èƒŒæ™¯æ¡†è¡¨ç¤ºé‚Šç•Œ
        const tl = this.camera.toScreen(0, 0);
        const br = this.camera.toScreen(CONFIG.width * CONFIG.gridSize, CONFIG.height * CONFIG.gridSize);
        // é€™é‚Šç°¡åŒ–è™•ç†ï¼Œåªç•«é‚Šæ¡†ï¼Œç¶²æ ¼è‹¥è¦æ—‹è½‰éœ€è¦è¤‡é›œé‹ç®—
        this.ctx.strokeStyle = "rgba(0,0,0,0.1)";
        this.ctx.lineWidth = 2;
        this.ctx.beginPath();
        
        // ç¹ªè£½å››å€‹è§’
        const p1 = this.camera.toScreen(0, 0);
        const p2 = this.camera.toScreen(1200, 0);
        const p3 = this.camera.toScreen(1200, 800);
        const p4 = this.camera.toScreen(0, 800);
        
        this.ctx.moveTo(p1.x, p1.y);
        this.ctx.lineTo(p2.x, p2.y);
        this.ctx.lineTo(p3.x, p3.y);
        this.ctx.lineTo(p4.x, p4.y);
        this.ctx.closePath();
        this.ctx.stroke();
        
        // å¡«å……è‰åœ°ç´‹ç†
        this.ctx.fillStyle = "rgba(169, 223, 191, 0.3)";
        this.ctx.fill();
    }

    drawPath() {
        this.ctx.lineCap = 'round'; this.ctx.lineJoin = 'round';
        
        // è·¯å¾‘è·¯é¢
        this.ctx.lineWidth = 70 * this.camera.zoom;
        this.ctx.strokeStyle = '#e6d0ce'; 
        this.ctx.beginPath();
        if (this.pathPixels.length > 0) {
            const start = this.camera.toScreen(this.pathPixels[0].x, this.pathPixels[0].y);
            this.ctx.moveTo(start.x, start.y);
            for (let i = 1; i < this.pathPixels.length; i++) {
                const p = this.camera.toScreen(this.pathPixels[i].x, this.pathPixels[i].y);
                this.ctx.lineTo(p.x, p.y);
            }
        }
        this.ctx.stroke();
    }

    drawText(x, y, text, font, color) {
        this.ctx.font = font; this.ctx.fillStyle = color;
        this.ctx.textAlign = "center"; this.ctx.shadowColor = "rgba(0,0,0,0.8)";
        this.ctx.shadowBlur = 4; this.ctx.fillText(text, x, y); this.ctx.shadowBlur = 0;
    }

    updateUI() {
        document.getElementById('gold').innerText = Math.floor(this.gameState.gold);
        document.getElementById('wave-info').innerText = `ç¬¬ ${this.gameState.level + 1} é—œ`;
        const pPct = Math.max(0, (this.gameState.baseHpPlayer / (1000 + this.gameState.level * 200)) * 100);
        document.getElementById('player-hp-bar').style.width = `${pPct}%`;
        const enemyMaxHp = (1000 + (this.gameState.level * 1000)) * LEVELS[this.gameState.level].statsMultiplier;
        const ePct = Math.max(0, (this.gameState.baseHpEnemy / enemyMaxHp) * 100);
        document.getElementById('enemy-hp-bar').style.width = `${ePct}%`;
    }

    showMessage(msg, isWarning = false) {
        const el = document.getElementById('message-area');
        el.innerText = msg;
        el.style.color = isWarning ? '#e74c3c' : '#fff';
        el.style.borderColor = isWarning ? '#e74c3c' : 'gold';
        el.style.display = 'block'; el.style.opacity = 1;
        if(this.msgTimeout) clearTimeout(this.msgTimeout);
        this.msgTimeout = setTimeout(() => { el.style.display = 'none'; }, 1500);
    }

    createEffect(x, y, type) {
        let color = 'white'; if (type === 'hit') color = 'orange'; if (type === 'blood') color = 'red';
        for(let i=0; i<6; i++) this.particles.push(new Particle(x, y, color));
    }

    endGame(isWin, reason) {
        this.gameState.isGameOver = true;
        document.getElementById('result-screen').style.display = 'flex';
        document.getElementById('end-title').innerText = isWin ? "ğŸ† å¤§ç²å…¨å‹" : "ğŸ’€ æˆ°æ•—";
        document.getElementById('end-title').style.color = isWin ? "gold" : "#e74c3c";
        document.getElementById('end-reason').innerText = reason;
        const duration = Math.floor((Date.now() - this.player.startTime)/1000);
        document.getElementById('final-score').innerText = this.player.score;
        document.getElementById('final-time').innerText = duration + "s";
        this.sendToGas(duration);
    }

    sendToGas(duration) {
        if(CONFIG.gasUrl.includes("exec")) {
            const data = { name: this.player.name, id: this.player.id, score: this.player.score, duration: duration, date: new Date().toISOString() };
            fetch(CONFIG.gasUrl, { method: 'POST', mode: 'no-cors', headers: {'Content-Type': 'application/json'}, body: JSON.stringify(data) }).catch(e => console.error(e));
        }
    }
}

class Unit {
    constructor(x, y, team, typeKey, pathIdx, statsMult = 1, speedMult = 1) {
        this.x = x; this.y = y; this.team = team; this.typeKey = typeKey;
        const data = UNIT_TYPES[typeKey];
        this.name = data.name; this.maxHp = data.hp * statsMult; this.hp = this.maxHp;
        this.atk = data.atk * statsMult; this.range = data.range; this.speed = data.speed * speedMult;
        this.attackType = data.type; this.icon = data.icon; this.color = data.color;
        this.pathIndex = pathIdx; this.state = 'move'; this.attackCooldown = 0; this.dead = false;
        this.visualHeight = (typeKey === 'general') ? 50 : 30; this.bounce = 0;
    }

    update(game) {
        if (this.dead) return;
        if (this.attackCooldown > 0) this.attackCooldown--;
        let target = this.findTarget(game);
        if (target) {
            this.state = 'attack';
            if (this.attackCooldown <= 0) { this.attack(target, game); this.attackCooldown = 60; }
        } else {
            this.state = 'move'; this.move(game);
        }
        if (this.state === 'move') this.bounce = Math.abs(Math.sin(Date.now() / 150)) * 5; else this.bounce = 0;
    }

    findTarget(game) {
        for (let u of game.units) {
            if (u.team !== this.team && !u.dead) {
                const dist = Math.hypot(u.x - this.x, u.y - this.y);
                if (dist <= this.range) return u;
            }
        }
        let baseDist = 9999;
        if (this.team === 'player') {
            const base = game.pathPixels[0];
            baseDist = Math.hypot(base.x - this.x, base.y - this.y);
            if (baseDist <= this.range) return { type: 'base', team: 'enemy' };
        } else {
            const base = game.pathPixels[game.pathPixels.length-1];
            baseDist = Math.hypot(base.x - this.x, base.y - this.y);
            if (baseDist <= this.range) return { type: 'base', team: 'player' };
        }
        return null;
    }

    attack(target, game) {
        if (this.attackType === 'ranged') {
            game.projectiles.push(new Projectile(this.x, this.y - this.visualHeight, target, this.atk, this.team));
            AudioSys.sfx.attack_range();
        } else {
            game.createEffect(target.x || this.x, target.y || this.y, 'hit');
            AudioSys.sfx.attack_melee();
            if (target.type === 'base') {
                if (target.team === 'player') game.gameState.baseHpPlayer -= this.atk;
                else game.gameState.baseHpEnemy -= this.atk;
                game.createEffect(this.x, this.y, 'hit'); 
            } else { target.takeDamage(this.atk, game); }
        }
    }

    move(game) {
        let nextIdx = (this.team === 'player') ? this.pathIndex - 1 : this.pathIndex + 1;
        if (nextIdx < 0 || nextIdx >= game.pathPixels.length) return;
        const targetNode = game.pathPixels[nextIdx];
        const dx = targetNode.x - this.x; const dy = targetNode.y - this.y;
        const dist = Math.hypot(dx, dy);
        if (dist <= this.speed) { this.x = targetNode.x; this.y = targetNode.y; this.pathIndex = nextIdx; }
        else { this.x += (dx / dist) * this.speed; this.y += (dy / dist) * this.speed; }
    }

    takeDamage(amount, game) {
        this.hp -= amount; game.createEffect(this.x, this.y - this.visualHeight, 'blood');
        if (this.hp <= 0) { this.dead = true; AudioSys.sfx.hit(); }
    }

    draw(ctx, camera) {
        // å–å¾—è½‰æ›å¾Œçš„è¢å¹•åº§æ¨™
        const pos = camera.toScreen(this.x, this.y);
        const s = pos.scale;
        const drawY = pos.y - (this.visualHeight * s) - (this.bounce * s);

        // 3D æŠ•å½±ç¹ªè£½
        // è…³åº•é™°å½±
        ctx.fillStyle = "rgba(0,0,0,0.3)";
        ctx.beginPath();
        ctx.ellipse(pos.x, pos.y, 18 * s, 10 * s, 0, 0, Math.PI*2);
        ctx.fill();

        // èº«é«” (åœ“çƒ+æ¼¸å±¤)
        const grad = ctx.createRadialGradient(pos.x - 5*s, drawY - 5*s, 2*s, pos.x, drawY, 20*s);
        grad.addColorStop(0, this.color);
        grad.addColorStop(1, this.team === 'player' ? '#2980b9' : '#c0392b');

        ctx.fillStyle = grad;
        ctx.lineWidth = 2 * s;
        ctx.strokeStyle = '#fff';
        
        ctx.beginPath();
        ctx.arc(pos.x, drawY, 22 * s, 0, Math.PI*2);
        ctx.fill();
        ctx.stroke();

        ctx.font = `${24 * s}px Arial`;
        ctx.fillStyle = "#fff";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(this.icon, pos.x, drawY);

        // è¡€æ¢
        const hpPct = this.hp / this.maxHp;
        const barY = drawY - (35 * s);
        ctx.fillStyle = "#555";
        ctx.fillRect(pos.x - (18 * s), barY, 36 * s, 6 * s);
        ctx.fillStyle = hpPct > 0.5 ? "#2ecc71" : "#e74c3c";
        ctx.fillRect(pos.x - (18 * s), barY, (36 * s) * hpPct, 6 * s);
    }
}

class Projectile {
    constructor(x, y, target, dmg, team) {
        this.x = x; this.y = y; this.target = target;
        this.damage = dmg; this.team = team; this.speed = 12; this.hit = false;
        this.tx = target.x || (team === 'player' ? Game.pathPixels[0].x : Game.pathPixels[Game.pathPixels.length-1].x);
        this.ty = target.y || (team === 'player' ? Game.pathPixels[0].y : Game.pathPixels[Game.pathPixels.length-1].y);
        if(target.visualHeight) this.ty -= target.visualHeight;
    }

    update() {
        if (this.target && !this.target.dead) {
            this.tx = this.target.x || this.tx;
            this.ty = (this.target.y || this.ty) - (this.target.visualHeight || 30);
        }
        const dx = this.tx - this.x; const dy = this.ty - this.y;
        const dist = Math.hypot(dx, dy);
        if (dist <= this.speed) {
            this.hit = true; Game.createEffect(this.tx, this.ty, 'hit'); AudioSys.sfx.hit();
            if (this.target.type === 'base') {
                if (this.target.team === 'player') Game.gameState.baseHpPlayer -= this.damage;
                else Game.gameState.baseHpEnemy -= this.damage;
            } else if (this.target.takeDamage) { this.target.takeDamage(this.damage, Game); }
        } else { this.x += (dx/dist) * this.speed; this.y += (dy/dist) * this.speed; }
    }

    draw(ctx, camera) {
        const pos = camera.toScreen(this.x, this.y);
        const s = pos.scale;
        ctx.fillStyle = this.team === 'player' ? '#3498db' : '#e74c3c';
        ctx.beginPath();
        ctx.arc(pos.x, pos.y, 6 * s, 0, Math.PI*2);
        ctx.fill();
    }
}

class Particle {
    constructor(x, y, color) {
        this.x = x; this.y = y; this.color = color;
        this.vx = (Math.random()-0.5)*6; this.vy = (Math.random()-0.5)*6;
        this.life = 1.0; this.gravity = 0.2;
    }
    update() { this.x += this.vx; this.y += this.vy; this.vy += this.gravity; this.life -= 0.05; }
    draw(ctx, camera) {
        const pos = camera.toScreen(this.x, this.y);
        const s = pos.scale;
        ctx.globalAlpha = Math.max(0, this.life);
        ctx.fillStyle = this.color;
        ctx.beginPath(); ctx.arc(pos.x, pos.y, 4 * s, 0, Math.PI*2); ctx.fill();
        ctx.globalAlpha = 1;
    }
}

const Game = new GameEngine();

</script>
</body>
</html>
