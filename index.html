<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>‰∏âÂúãÁ≠ñÁï•ÊîªÈò≤Êà∞ (ËßíËâ≤ÊîæÂ§ßÁâà)</title>
    <style>
        :root {
            --primary-color: #f39c12; 
            --secondary-color: #c0392b; 
            --player-color: #2980b9;  
            --enemy-color: #c0392b;   
            --bg-color: #fcf3cf;
            --ui-bg: rgba(255, 255, 255, 0.95);
        }

        body {
            margin: 0; padding: 0;
            font-family: "Microsoft JhengHei", "Heiti TC", sans-serif;
            background-color: #000;
            display: flex; justify-content: center; align-items: center;
            height: 100vh; width: 100vw; overflow: hidden; user-select: none;
            touch-action: none;
        }

        #game-wrapper {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #game-container {
            position: absolute; 
            width: 1200px; height: 800px;
            background-color: #2c3e50; 
            box-shadow: 0 0 50px rgba(0,0,0,0.8);
            border-radius: 12px; overflow: hidden;
            display: none; cursor: grab;
            transform-origin: center center;
        }
        
        #game-container:active { cursor: grabbing; }

        canvas { display: block; }

        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10;
        }

        .hud-panel {
            position: absolute; background: var(--ui-bg); border: 2px solid var(--primary-color);
            border-radius: 12px; padding: 5px; pointer-events: auto; color: #2c3e50;
            font-weight: bold; box-shadow: 0 4px 10px rgba(0,0,0,0.3); backdrop-filter: blur(5px);
        }

        /* Top Bar */
        #top-bar {
            top: 10px; left: 50%; transform: translateX(-50%); width: 95%; height: 50px;
            display: flex; justify-content: space-between; align-items: center; font-size: 16px;
            border-radius: 25px; padding: 0 15px; box-sizing: border-box;
        }

        .hp-bar-container {
            width: 200px; height: 16px; background: #34495e; border-radius: 10px;
            overflow: hidden; border: 2px solid #fff; position: relative; margin: 0 5px;
        }
        .hp-bar-fill { height: 100%; transition: width 0.2s; position: relative; }

        /* Camera Controls (Right) */
        #cam-controls {
            position: absolute; right: 15px; top: 80px; display: flex; flex-direction: column; gap: 8px; pointer-events: auto;
        }
        .cam-btn {
            width: 40px; height: 40px; border-radius: 50%; border: 2px solid #fff;
            background: rgba(44, 62, 80, 0.9); color: white; font-size: 20px; cursor: pointer;
            display: flex; align-items: center; justify-content: center; transition: 0.2s;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }
        .cam-btn:hover { background: var(--primary-color); transform: scale(1.1); }

        /* Upgrade Controls (Left) */
        #upgrade-controls {
            position: absolute; left: 15px; bottom: 140px; 
            display: flex; flex-direction: column; gap: 8px; pointer-events: auto;
            align-items: center;
        }
        
        .upgrade-btn {
            width: 80px; height: 80px; border-radius: 50%; border: 4px solid gold;
            background: radial-gradient(circle, #f1c40f, #d35400); 
            color: white; cursor: pointer;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            transition: 0.2s;
            box-shadow: 0 4px 10px rgba(0,0,0,0.5);
            text-shadow: 1px 1px 2px black;
            animation: pulse 2s infinite;
        }
        .upgrade-btn:active { transform: scale(0.95); }
        .upgrade-btn.disabled { filter: grayscale(100%); opacity: 0.7; animation: none; border-color: #7f8c8d; background: #95a5a6; cursor: not-allowed; }
        
        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(241, 196, 15, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(241, 196, 15, 0); }
            100% { box-shadow: 0 0 0 0 rgba(241, 196, 15, 0); }
        }

        /* Bottom Bar */
        #bottom-bar {
            bottom: 10px; left: 50%; transform: translateX(-50%); 
            display: flex; gap: 6px;
            padding: 8px 15px; width: auto; max-width: 98%; justify-content: center;
            border-radius: 15px; overflow-x: auto; overflow-y: hidden;
            z-index: 100; white-space: nowrap;
        }

        .unit-btn {
            width: 65px; height: 85px; 
            border: 2px solid #bdc3c7; border-radius: 8px;
            background: linear-gradient(to bottom, #fff, #f0f3f4); cursor: pointer;
            display: inline-flex; flex-direction: column; align-items: center; justify-content: center;
            transition: all 0.1s; position: relative; box-shadow: 0 3px 0 #95a5a6; flex-shrink: 0;
        }
        .unit-btn:hover { transform: translateY(-2px); border-color: var(--primary-color); }
        .unit-btn:active { transform: translateY(4px); box-shadow: 0 0 0 #95a5a6; }
        .unit-btn.disabled { filter: grayscale(100%); opacity: 0.6; cursor: not-allowed; background: #e0e0e0; }
        
        .unit-btn[id="btn-general"] { border-color: gold; background: linear-gradient(to bottom, #fcf3cf, #f9e79f); box-shadow: 0 3px 0 #d4ac0d; }
        
        .unit-img-preview { width: 40px; height: 40px; object-fit: contain; margin-bottom: 2px; filter: drop-shadow(1px 1px 1px rgba(0,0,0,0.2)); }
        .unit-name { font-size: 11px; font-weight: 800; color: #2c3e50; margin-bottom: 1px;}
        .unit-cost { background: gold; color: #d35400; padding: 1px 4px; border-radius: 4px; font-size: 10px; font-weight: bold; border: 1px solid #d35400;}
        .hotkey { position: absolute; top: 2px; right: 4px; font-size: 9px; color: #7f8c8d; font-weight: bold; }
        .limit-badge {
            position: absolute; top: 0; left: 0; background: #c0392b; color: white;
            font-size: 9px; padding: 1px 4px; border-radius: 6px 0 6px 0; display: none;
        }

        /* Screens */
        #login-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: url('https://raw.githubusercontent.com/btosichen/2026-Tower-Defense-Games/23e73bd815ab029e43fc9728641e0358131555c6/Gemini_Generated_Image_9bni789bni789bni.png') no-repeat center center;
            background-size: cover;
            display: flex; flex-direction: column;
            justify-content: center; align-items: center;
            color: white; z-index: 200;
        }

        #result-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(44, 62, 80, 0.98);
            display: flex; flex-direction: column;
            justify-content: center; align-items: center;
            color: white; z-index: 200;
        }
        
        .panel-box {
            background: rgba(255, 255, 255, 0.95); 
            padding: 30px; border-radius: 20px;
            text-align: center; color: #2c3e50;
            border: 4px solid var(--primary-color);
            width: 600px;
            box-shadow: 0 20px 50px rgba(0,0,0,0.8);
            max-width: 90%;
            backdrop-filter: blur(10px);
        }

        .char-selection { display: flex; justify-content: center; gap: 20px; margin: 20px 0; flex-wrap: wrap;}
        .char-card {
            width: 140px; padding: 10px; border: 2px solid #ddd; border-radius: 12px;
            cursor: pointer; transition: all 0.3s; background: #fff; position: relative;
        }
        .char-card:hover { transform: translateY(-5px); box-shadow: 0 10px 20px rgba(0,0,0,0.2); }
        .char-card.selected {
            border-color: var(--secondary-color); background: #fadbd8;
            box-shadow: 0 0 0 3px rgba(192, 57, 43, 0.3); transform: scale(1.05);
        }
        .char-img { width: 100%; height: 100px; object-fit: contain; margin-bottom: 5px; }
        .char-desc { font-size: 13px; color: #555; line-height: 1.3;}

        input {
            padding: 12px; font-size: 18px; width: 70%;
            margin: 15px 0; text-align: center; border: 2px solid #bdc3c7; border-radius: 8px;
        }
        button.start-btn {
            background: var(--secondary-color); color: white; border: none;
            padding: 12px 50px; font-size: 22px; border-radius: 30px;
            cursor: pointer; transition: 0.3s; box-shadow: 0 5px 0 #922b21;
        }
        button.start-btn:hover { transform: translateY(-3px); box-shadow: 0 8px 0 #922b21; background: #e74c3c; }

        #message-area {
            position: absolute; top: 40%; left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.85); color: #fff;
            padding: 15px 40px; border-radius: 50px;
            font-size: 28px; font-weight: bold;
            display: none; pointer-events: none;
            z-index: 150; border: 3px solid gold;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            white-space: nowrap;
        }
        
        #avatar-display {
            width: 40px; height: 40px; border-radius: 50%; border: 2px solid white;
            margin-right: 10px; background: #fff; object-fit: contain; box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }
    </style>
</head>
<body>

    <div id="game-wrapper">
        <div id="login-screen">
            <div class="panel-box">
                <h1 style="font-size: 32px; margin-bottom: 10px; text-shadow: 2px 2px 0 #ddd;">‚öîÔ∏è ‰∏âÂúãÁ≠ñÁï•ÊîªÈò≤Êà∞</h1>
                <p style="color: #7f8c8d; font-size: 16px;">Ë´ãÈÅ∏ÊìáÊÇ®ÁöÑÊåáÊèÆÂÆò</p>
                
                <div class="char-selection">
                    <div class="char-card" onclick="Game.selectCharacter(1, this)">
                        <img src="https://raw.githubusercontent.com/btosichen/2026-Tower-Defense-Games/73d914672748f372cbd42737a5025b071972627a/logo-1-0-0.png" class="char-img">
                        <div style="font-weight:bold; font-size:18px; color: #2980b9;">ÈæçÂ∞áËªç</div>
                        <div class="char-desc">ÈéÆÂÆàÊù±Êñπ<br>Áî±Âè≥ÊîªÂ∑¶</div>
                    </div>
                    <div class="char-card" onclick="Game.selectCharacter(2, this)">
                        <img src="https://raw.githubusercontent.com/btosichen/2026-Tower-Defense-Games/73d914672748f372cbd42737a5025b071972627a/logo-2-0-0.png" class="char-img">
                        <div style="font-weight:bold; font-size:18px; color: #c0392b;">ËôéÂÖÉÂ∏•</div>
                        <div class="char-desc">ÈéÆÂÆàË•øÊñπ<br>Áî±Â∑¶ÊîªÂè≥</div>
                    </div>
                </div>

                <input type="text" id="player-name" placeholder="Ë´ãËº∏ÂÖ•Â∞áËªçÂ§ßÂêç" maxlength="10">
                <br>
                <button class="start-btn" onclick="Game.initLogin()">Âá∫ÂæÅ</button>
                <p id="loading-text" style="color: #e67e22; font-size: 14px; margin-top: 15px; font-weight: bold;">Ê≠£Âú®ÂæµÂè¨ÂÖµÈ¶¨...</p>
            </div>
        </div>

        <div id="game-container">
            <canvas id="gameCanvas" width="1200" height="800"></canvas>
            
            <div id="ui-layer">
                <div id="top-bar" class="hud-panel">
                    <div style="display:flex; align-items:center;">
                        <span style="color:var(--enemy-color); margin-right:5px; font-size:14px;">üö© ÊïµÁáü</span>
                        <div class="hp-bar-container">
                            <div id="enemy-hp-bar" class="hp-bar-fill" style="width: 100%; background: linear-gradient(to right, #e74c3c, #c0392b);"></div>
                        </div>
                    </div>

                    <div style="text-align:center; min-width: 120px;">
                        <div id="wave-info" style="font-size:20px; color:var(--primary-color); font-weight:900; text-shadow: 1px 1px 0 #333;">Á¨¨ 1 Èóú</div>
                        <div style="font-size:16px; margin-top:2px; background:rgba(0,0,0,0.05); padding:2px 10px; border-radius:15px; display:inline-block;">
                            üí∞ <span id="gold" style="color:#d35400;">0</span>
                        </div>
                    </div>

                    <div style="display:flex; align-items:center;">
                        <span id="enemy-stats-hint" style="font-size:10px;color:#e74c3c; margin-right:5px;"></span>
                        <div class="hp-bar-container">
                            <div id="player-hp-bar" class="hp-bar-fill" style="width: 100%; background: linear-gradient(to right, #3498db, #2980b9);"></div>
                        </div>
                        <span style="color:var(--player-color); margin-left:5px; font-size:14px;">üõ°Ô∏è ÊàëÂüé</span>
                        <img id="avatar-display" src="" style="display:none; margin-left:5px; margin-right:0;">
                    </div>
                </div>

                <div id="cam-controls">
                    <div class="cam-btn" onclick="Game.camera.zoomIn()" title="ÊîæÂ§ß (+)">‚ûï</div>
                    <div class="cam-btn" onclick="Game.camera.zoomOut()" title="Á∏ÆÂ∞è (-)">‚ûñ</div>
                    <div class="cam-btn" onclick="Game.camera.rotate(-0.1)" title="Â∑¶ÊóãËΩâ (Q)">‚Ü∫</div>
                    <div class="cam-btn" onclick="Game.camera.rotate(0.1)" title="Âè≥ÊóãËΩâ (E)">‚Üª</div>
                    <div class="cam-btn" onclick="Game.camera.reset()" title="ÈáçÁΩÆË¶ñËßí (R)">üéØ</div>
                </div>

                <!-- ÂçáÁ¥öÊåâÈàïÂçÄ -->
                <div id="upgrade-controls">
                    <div class="upgrade-btn" id="btn-upgrade" onclick="Game.upgradeArmy()" title="ÂÖ®ËªçÂçáÁ¥ö">
                        <span style="font-size:24px;">‚öîÔ∏è</span>
                        <span style="font-size:14px; font-weight:bold;">Lv.<span id="army-lvl">1</span></span>
                        <span style="font-size:10px;" id="upgrade-cost">$500</span>
                    </div>
                </div>

                <div id="message-area">Êà∞È¨•ÈñãÂßãÔºÅ</div>
                
                <div id="bottom-bar" class="hud-panel"></div>
            </div>
        </div>

        <div id="result-screen" style="display: none;">
            <div class="panel-box">
                <h1 id="end-title" style="font-size: 40px;">Êà∞ÂΩπÁµêÊùü</h1>
                <p id="end-reason" style="font-size: 18px; color: #555;">...</p>
                <div style="text-align:left; margin: 30px 0; font-size: 18px; background: #f9f9f9; padding: 20px; border-radius: 10px;">
                    <div style="margin-bottom: 10px;">üèÖ Á∏ΩÂàÜÔºö<span id="final-score" style="font-weight:bold; color:var(--primary-color);">0</span></div>
                    <div>‚è±Ô∏è ËÄóÊôÇÔºö<span id="final-time" style="font-weight:bold;">0s</span></div>
                </div>
                <button class="start-btn" onclick="location.reload()">ÂÜçÊà∞‰∏ÄÂ†¥</button>
            </div>
        </div>
    </div>

<script>
const ASSETS = {
    chars: {
        1: "https://raw.githubusercontent.com/btosichen/2026-Tower-Defense-Games/73d914672748f372cbd42737a5025b071972627a/logo-1-0-0.png",
        2: "https://raw.githubusercontent.com/btosichen/2026-Tower-Defense-Games/73d914672748f372cbd42737a5025b071972627a/logo-2-0-0.png"
    },
    backgrounds: [
        "https://raw.githubusercontent.com/btosichen/2026-Tower-Defense-Games/d1541125592a5f3ca60a7ba19a3ddc42cce65421/bg-0.png",
        "https://raw.githubusercontent.com/btosichen/2026-Tower-Defense-Games/d1541125592a5f3ca60a7ba19a3ddc42cce65421/bg-1.png",
        "https://raw.githubusercontent.com/btosichen/2026-Tower-Defense-Games/d1541125592a5f3ca60a7ba19a3ddc42cce65421/bg-2.png",
        "https://raw.githubusercontent.com/btosichen/2026-Tower-Defense-Games/d1541125592a5f3ca60a7ba19a3ddc42cce65421/bg-3.png",
        "https://raw.githubusercontent.com/btosichen/2026-Tower-Defense-Games/d1541125592a5f3ca60a7ba19a3ddc42cce65421/bg-4.png",
        "https://raw.githubusercontent.com/btosichen/2026-Tower-Defense-Games/d1541125592a5f3ca60a7ba19a3ddc42cce65421/bg-5.png",
        "https://raw.githubusercontent.com/btosichen/2026-Tower-Defense-Games/d1541125592a5f3ca60a7ba19a3ddc42cce65421/bg-6.png",
        "https://raw.githubusercontent.com/btosichen/2026-Tower-Defense-Games/d1541125592a5f3ca60a7ba19a3ddc42cce65421/bg-7.png",
        "https://raw.githubusercontent.com/btosichen/2026-Tower-Defense-Games/d1541125592a5f3ca60a7ba19a3ddc42cce65421/bg-8.png",
        "https://raw.githubusercontent.com/btosichen/2026-Tower-Defense-Games/d1541125592a5f3ca60a7ba19a3ddc42cce65421/bg-9.png"
    ],
    f1: {
        castle: "https://raw.githubusercontent.com/btosichen/2026-Tower-Defense-Games/ac4b7a1f6d922e4765e29eef26384cd26bd7afd8/logo-1-0%20(90%20x%2090%20%E5%83%8F%E7%B4%A0).png",
        sword: "https://raw.githubusercontent.com/btosichen/2026-Tower-Defense-Games/ac4b7a1f6d922e4765e29eef26384cd26bd7afd8/logo-1-1%20(50%20x%2050%20%E5%83%8F%E7%B4%A0).png",
        bow: "https://raw.githubusercontent.com/btosichen/2026-Tower-Defense-Games/ac4b7a1f6d922e4765e29eef26384cd26bd7afd8/logo-1-2(50%20x%2050%20%E5%83%8F%E7%B4%A0).png",
        spear: "https://raw.githubusercontent.com/btosichen/2026-Tower-Defense-Games/ac4b7a1f6d922e4765e29eef26384cd26bd7afd8/logo-1-3(50%20x%2050%20%E5%83%8F%E7%B4%A0).png",
        cavalry: "https://raw.githubusercontent.com/btosichen/2026-Tower-Defense-Games/ac4b7a1f6d922e4765e29eef26384cd26bd7afd8/logo-1-4(50%20x%2050%20%E5%83%8F%E7%B4%A0).png",
        vanguard: "https://raw.githubusercontent.com/btosichen/2026-Tower-Defense-Games/ac4b7a1f6d922e4765e29eef26384cd26bd7afd8/logo-1-5(50%20x%2050%20%E5%83%8F%E7%B4%A0).png",
        vice: "https://raw.githubusercontent.com/btosichen/2026-Tower-Defense-Games/ac4b7a1f6d922e4765e29eef26384cd26bd7afd8/logo-1-6(50%20x%2050%20%E5%83%8F%E7%B4%A0).png",
        general: "https://raw.githubusercontent.com/btosichen/2026-Tower-Defense-Games/ac4b7a1f6d922e4765e29eef26384cd26bd7afd8/logo-1-7(50%20x%2050%20%E5%83%8F%E7%B4%A0).png",
        advisor: "https://raw.githubusercontent.com/btosichen/2026-Tower-Defense-Games/ac4b7a1f6d922e4765e29eef26384cd26bd7afd8/logo-1-8(50%20x%2050%20%E5%83%8F%E7%B4%A0).png"
    },
    f2: {
        castle: "https://raw.githubusercontent.com/btosichen/2026-Tower-Defense-Games/ac4b7a1f6d922e4765e29eef26384cd26bd7afd8/logo-2-0%20(90%20x%2090%20%E5%83%8F%E7%B4%A0).png",
        sword: "https://raw.githubusercontent.com/btosichen/2026-Tower-Defense-Games/ac4b7a1f6d922e4765e29eef26384cd26bd7afd8/logo-2-1(50%20x%2050%20%E5%83%8F%E7%B4%A0).png",
        bow: "https://raw.githubusercontent.com/btosichen/2026-Tower-Defense-Games/ac4b7a1f6d922e4765e29eef26384cd26bd7afd8/logo-2-2(50%20x%2050%20%E5%83%8F%E7%B4%A0).png",
        spear: "https://raw.githubusercontent.com/btosichen/2026-Tower-Defense-Games/ac4b7a1f6d922e4765e29eef26384cd26bd7afd8/logo-2-3(50%20x%2050%20%E5%83%8F%E7%B4%A0).png",
        cavalry: "https://raw.githubusercontent.com/btosichen/2026-Tower-Defense-Games/ac4b7a1f6d922e4765e29eef26384cd26bd7afd8/logo-2-4(50%20x%2050%20%E5%83%8F%E7%B4%A0).png",
        vanguard: "https://raw.githubusercontent.com/btosichen/2026-Tower-Defense-Games/ac4b7a1f6d922e4765e29eef26384cd26bd7afd8/logo-2-5(50%20x%2050%20%E5%83%8F%E7%B4%A0).png",
        vice: "https://raw.githubusercontent.com/btosichen/2026-Tower-Defense-Games/ac4b7a1f6d922e4765e29eef26384cd26bd7afd8/logo-2-6(50%20x%2050%20%E5%83%8F%E7%B4%A0).png",
        general: "https://raw.githubusercontent.com/btosichen/2026-Tower-Defense-Games/ac4b7a1f6d922e4765e29eef26384cd26bd7afd8/logo-2-7(50%20x%2050%20%E5%83%8F%E7%B4%A0).png",
        advisor: "https://raw.githubusercontent.com/btosichen/2026-Tower-Defense-Games/ac4b7a1f6d922e4765e29eef26384cd26bd7afd8/logo-2-8(50%20x%2050%20%E5%83%8F%E7%B4%A0).png"
    },
    images: {} 
};

const SecureConfig = (function() {
    const _units = {
        sword:    { name: 'ÂàÄÂÖµ',   cost: 50,  hp: 120, atk: 15, range: 40,  speed: 2.5, type: 'melee', cd: 60 },
        bow:      { name: 'ÂºìÂÖµ',   cost: 120, hp: 80,  atk: 25, range: 250, speed: 2.5, type: 'ranged', cd: 80 },
        spear:    { name: 'ÊßçÂÖµ',   cost: 200, hp: 180, atk: 40, range: 70,  speed: 2.0, type: 'melee', cd: 100 },
        cavalry:  { name: 'È®éÂÖµ',   cost: 280, hp: 220, atk: 45, range: 40,  speed: 5.0, type: 'melee', cd: 120 },
        vanguard: { name: 'ÂâçÈãí',   cost: 350, hp: 300, atk: 55, range: 40,  speed: 3.5, type: 'melee', cd: 150 },
        vice:     { name: 'ÂâØÂ∞áËªç', cost: 500, hp: 600, atk: 70, range: 50,  speed: 1.5, type: 'melee', cd: 300 },
        advisor:  { name: 'ÂúãÂ∏´',   cost: 800, hp: 200, atk: 100, range: 300, speed: 1.5, type: 'magic', cd: 400 },
        general:  { name: 'Â§ßÂ∞áËªç', cost: 1500, hp: 2000,atk: 200, range: 60, speed: 1.2, type: 'melee', cd: 600, limit: 1 }
    };
    
    const _levels = Array.from({length: 10}, (_, i) => ({
        enemySpawnRate: Math.max(60, 180 - i * 12),
        goldRate: 1 + i * 0.5,
        enemyTypes: i < 1 ? ['sword', 'sword', 'spear'] :
                    i < 3 ? ['sword', 'bow', 'spear', 'cavalry'] :
                    i < 6 ? ['spear', 'bow', 'cavalry', 'vanguard', 'vice'] :
                    i < 8 ? ['vanguard', 'vice', 'advisor'] :
                            ['vice', 'advisor', 'general'],
        statsMultiplier: 1 + i,
        speedMultiplier: 1 + (i * 0.1)
    }));

    Object.freeze(_units);
    Object.freeze(_levels);

    return {
        getUnitTypes: () => _units,
        getLevels: () => _levels
    };
})();

const CONFIG = {
    gridSize: 80, width: 15, height: 10,
    gasUrl: 'https://script.google.com/macros/s/AKfycbwqZFv8Jzk4A1ERYbzljRudebPBTlBn4OcSsFWfWBGLTIKGSMDEd3focinsGovte4c9/exec'
};

const MAPS = [
    [{x:0,y:2}, {x:3,y:2}, {x:3,y:7}, {x:8,y:7}, {x:8,y:2}, {x:12,y:2}, {x:12,y:6}, {x:14,y:6}],
    [{x:0,y:1}, {x:2,y:1}, {x:2,y:8}, {x:12,y:8}, {x:12,y:1}, {x:14,y:1}],
    [{x:0,y:8}, {x:2,y:8}, {x:2,y:2}, {x:5,y:2}, {x:5,y:8}, {x:8,y:8}, {x:8,y:2}, {x:11,y:2}, {x:11,y:8}, {x:14,y:8}],
    [{x:0,y:5}, {x:4,y:5}, {x:4,y:3}, {x:10,y:3}, {x:10,y:6}, {x:14,y:6}],
    [{x:0,y:0}, {x:13,y:0}, {x:13,y:8}, {x:2,y:8}, {x:2,y:3}, {x:10,y:3}, {x:10,y:5}, {x:14,y:5}],
    [{x:0,y:9}, {x:3,y:9}, {x:3,y:6}, {x:6,y:6}, {x:6,y:3}, {x:9,y:3}, {x:9,y:0}, {x:14,y:0}],
    [{x:0,y:2}, {x:14,y:2}, {x:14,y:5}, {x:0,y:5}, {x:0,y:8}, {x:14,y:8}],
    [{x:0,y:1}, {x:6,y:1}, {x:6,y:5}, {x:8,y:5}, {x:8,y:9}, {x:14,y:9}],
    [{x:0,y:4}, {x:1,y:4}, {x:1,y:9}, {x:13,y:9}, {x:13,y:1}, {x:1,y:1}, {x:1,y:4}, {x:14,y:4}],
    [{x:0,y:0}, {x:0,y:9}, {x:3,y:9}, {x:3,y:2}, {x:6,y:2}, {x:6,y:7}, {x:9,y:7}, {x:9,y:1}, {x:12,y:1}, {x:12,y:8}, {x:14,y:8}]
];

const ImageLoader = {
    loadAll: function(callback) {
        let loaded = 0;
        const total = 28; 
        const checkLoad = () => {
            loaded++;
            if (loaded >= total && callback) callback();
        };
        for (let key in ASSETS.f1) {
            const img = new Image(); img.src = ASSETS.f1[key];
            img.onload = checkLoad; img.onerror = checkLoad;
            ASSETS.images[`f1_${key}`] = img;
        }
        for (let key in ASSETS.f2) {
            const img = new Image(); img.src = ASSETS.f2[key];
            img.onload = checkLoad; img.onerror = checkLoad;
            ASSETS.images[`f2_${key}`] = img;
        }
        ASSETS.backgrounds.forEach((url, index) => {
            const img = new Image(); img.src = url;
            img.onload = checkLoad; img.onerror = checkLoad;
            ASSETS.images[`bg_${index}`] = img;
        });
        setTimeout(() => { if (loaded < total && callback) callback(); }, 3000);
    }
};

const AudioSys = {
    ctx: null,
    init: function() {
        if (!this.ctx) { this.ctx = new (window.AudioContext || window.webkitAudioContext)(); }
        if (this.ctx.state === 'suspended') this.ctx.resume();
    },
    playTone: function(freq, type, duration, vol = 0.1) {
        if (!this.ctx) return;
        const osc = this.ctx.createOscillator(); const gain = this.ctx.createGain();
        osc.type = type; osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
        gain.gain.setValueAtTime(vol, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
        osc.connect(gain); gain.connect(this.ctx.destination);
        osc.start(); osc.stop(this.ctx.currentTime + duration);
    },
    sfx: {
        spawn: () => AudioSys.playTone(400, 'triangle', 0.1, 0.1),
        attack_melee: () => AudioSys.playTone(100, 'sawtooth', 0.1, 0.05),
        attack_range: () => AudioSys.playTone(800, 'sine', 0.1, 0.05),
        hit: () => AudioSys.playTone(150, 'square', 0.1, 0.05),
        spell: () => { if(AudioSys.ctx) [600, 500, 400].forEach((f, i) => setTimeout(() => AudioSys.playTone(f, 'sine', 0.3, 0.1), i * 100)); },
        win_level: () => { if(AudioSys.ctx) [440, 554, 659].forEach((f, i) => setTimeout(() => AudioSys.playTone(f, 'square', 0.4, 0.1), i * 100)); },
        game_over: () => { if(AudioSys.ctx) [300, 250, 200].forEach((f, i) => setTimeout(() => AudioSys.playTone(f, 'sawtooth', 0.5, 0.1), i * 300)); }
    }
};

class Camera {
    constructor(width, height) {
        this.width = width; this.height = height;
        this.x = width / 2; this.y = height / 2;
        this.zoom = 1; this.angle = 0; this.dragStart = null;
    }
    toScreen(x, y) {
        let dx = x - this.x; let dy = y - this.y;
        let cos = Math.cos(this.angle); let sin = Math.sin(this.angle);
        let rx = dx * cos - dy * sin; let ry = dx * sin + dy * cos;
        return { x: this.width / 2 + rx * this.zoom, y: this.height / 2 + ry * this.zoom, scale: this.zoom };
    }
    zoomIn() { this.zoom = Math.min(this.zoom * 1.1, 3); }
    zoomOut() { this.zoom = Math.max(this.zoom / 1.1, 0.5); }
    rotate(rad) { this.angle += rad; }
    reset() { this.zoom = 1; this.angle = 0; this.x = this.width/2; this.y = this.height/2; }
    handleMouseDown(e) { this.dragStart = { x: e.clientX, y: e.clientY, camX: this.x, camY: this.y }; }
    handleMouseMove(e) {
        if (!this.dragStart) return;
        const dx = (e.clientX - this.dragStart.x) / this.zoom;
        const dy = (e.clientY - this.dragStart.y) / this.zoom;
        let cos = Math.cos(-this.angle); let sin = Math.sin(-this.angle);
        this.x = this.dragStart.camX - (dx * cos - dy * sin);
        this.y = this.dragStart.camY - (dx * sin + dy * cos);
    }
    handleMouseUp() { this.dragStart = null; }
    handleWheel(e) { e.preventDefault(); if (e.deltaY < 0) this.zoomIn(); else this.zoomOut(); }
}

class GameEngine {
    #gold = 0; #score = 0; #levelScores = new Array(10).fill(0);
    #baseHpPlayer = 1000; #baseHpEnemy = 1000; #playerUnitCounts = {};
    #checksum = 0;

    constructor() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.player = { name: '', id: '' };
        this.camera = new Camera(1200, 800);
        this.selectedAvatar = null; 
        this.playerFaction = 1;
        this.enemyFaction = 2;
        this.playerLevel = 1; 
        
        this.level = 0; this.isGameOver = false;
        this.enemySpawnTimer = 0; this.isLevelTransitioning = false;
        this.maxBaseHp = 1000;

        this.units = []; this.projectiles = []; this.particles = []; this.pathPixels = [];
        this.lastTime = 0;
        this.cooldowns = {}; 
        
        window.addEventListener('resize', () => this.handleResize());
        this.handleResize();

        ImageLoader.loadAll(() => {
            document.getElementById('loading-text').innerText = "ÂÖµÈ¶¨Â∑≤ÂÇôÈΩäÔºåË´ãÈÅ∏ÊìáÊåáÊèÆÂÆòÔºÅ";
        });

        const container = document.getElementById('game-container');
        container.addEventListener('mousedown', e => this.camera.handleMouseDown(e));
        window.addEventListener('mousemove', e => this.camera.handleMouseMove(e));
        window.addEventListener('mouseup', () => this.camera.handleMouseUp());
        container.addEventListener('wheel', e => this.camera.handleWheel(e));
        
        document.addEventListener('keydown', e => {
            if (e.key === 'q' || e.key === 'Q') this.camera.rotate(-0.1);
            if (e.key === 'e' || e.key === 'E') this.camera.rotate(0.1);
            if (e.key === 'r' || e.key === 'R') this.camera.reset();
        });
        
        this.#updateChecksum();
    }

    handleResize() {
        const container = document.getElementById('game-container');
        const targetW = 1200; const targetH = 800;
        const winW = window.innerWidth; const winH = window.innerHeight;
        const scale = Math.min(winW / targetW, winH / targetH) * 0.98;
        container.style.transform = `scale(${scale})`;
    }

    getGold() { return this.#gold; }
    getScore() { return this.#score; }
    getHpPlayer() { return this.#baseHpPlayer; }
    getHpEnemy() { return this.#baseHpEnemy; }
    getUnitCount(key) { return this.#playerUnitCounts[key] || 0; }

    #updateChecksum() { this.#checksum = this.#gold + (this.#score * 1.5) + 42; }
    #verifyIntegrity() {
        if (this.#checksum !== (this.#gold + (this.#score * 1.5) + 42)) {
            alert("ÂÅµÊ∏¨Âà∞Áï∞Â∏∏Êï∏ÊìöÔºÅÈÅäÊà≤ÁµÇÊ≠¢„ÄÇ"); this.isGameOver = true; return false;
        }
        return true;
    }

    addGold(amount) { if (!this.#verifyIntegrity()) return; this.#gold += amount; this.#updateChecksum(); }
    addScore(amount) { if (!this.#verifyIntegrity()) return; this.#score += amount; this.#updateChecksum(); }
    modifyHp(target, amount) { if (target === 'player') this.#baseHpPlayer += amount; else this.#baseHpEnemy += amount; }
    resetUnitCounts() { this.#playerUnitCounts = {}; }
    incrementUnitCount(key) { this.#playerUnitCounts[key] = (this.#playerUnitCounts[key] || 0) + 1; }
    decrementUnitCount(key) { if(this.#playerUnitCounts[key] > 0) this.#playerUnitCounts[key]--; }

    createUnitButtons() {
        const bar = document.getElementById('bottom-bar');
        if(!bar) return; 
        bar.innerHTML = '';
        const types = SecureConfig.getUnitTypes();
        const keys = Object.keys(types);
        this.cooldowns = {}; 
        
        keys.forEach((key, index) => {
            const u = types[key];
            const div = document.createElement('div');
            div.className = 'unit-btn';
            div.id = `btn-${key}`;
            div.onclick = () => this.spawnPlayerUnit(key);
            
            const imgSrc = ASSETS.images[`f${this.playerFaction}_${key}`]?.src || "";
            
            div.innerHTML = `
                <span class="hotkey">${index+1}</span>
                <div class="limit-badge" id="limit-${key}">Èôê1</div>
                <img src="${imgSrc}" class="unit-img-preview" onerror="this.src=''">
                <div class="unit-name">${u.name}</div>
                <div class="unit-cost">$${u.cost}</div>
                <div class="cooldown-overlay" style="position:absolute;bottom:0;left:0;width:100%;height:0%;background:rgba(0,0,0,0.5);transition:height 0.1s;"></div>
            `;
            bar.appendChild(div);
            this.cooldowns[key] = 0;
            if (u.limit) div.querySelector('.limit-badge').style.display = 'block';
        });
    }

    selectCharacter(id, el) {
        this.selectedAvatar = id;
        document.querySelectorAll('.char-card').forEach(c => c.classList.remove('selected'));
        el.classList.add('selected');
    }

    initLogin() {
        if (!this.selectedAvatar) return alert("Ë´ãÂÖàÈÅ∏Êìá‰∏Ä‰ΩçÊåáÊèÆÂÆòÔºÅ");
        const name = document.getElementById('player-name').value.trim();
        if (!name) return alert("Ë´ãËº∏ÂÖ•Â§ßÂêçÔºÅ");
        
        this.player.name = name; this.player.id = 'ID_' + Date.now(); this.player.startTime = Date.now();
        AudioSys.init();
        
        this.playerFaction = this.selectedAvatar;
        this.enemyFaction = (this.selectedAvatar === 1) ? 2 : 1;
        
        const avatarImg = document.getElementById('avatar-display');
        avatarImg.src = ASSETS.chars[this.selectedAvatar];
        avatarImg.style.display = 'block';

        document.getElementById('login-screen').style.display = 'none';
        document.getElementById('game-container').style.display = 'block';
        
        this.handleResize();
        this.createUnitButtons();
        this.startLevel(0);
        this.gameLoop(0);
    }

    startLevel(lvl) {
        this.isLevelTransitioning = false;
        if (lvl > 0) {
            let prevTotal = 0;
            for(let i=0; i<lvl; i++) prevTotal += this.#levelScores[i];
            this.#levelScores[lvl-1] = this.#score - prevTotal;
        }
        const levels = SecureConfig.getLevels();
        if (lvl >= levels.length) { 
            let prevTotal = 0;
            for(let i=0; i<9; i++) prevTotal += this.#levelScores[i];
            this.#levelScores[9] = this.#score - prevTotal;
            AudioSys.sfx.win_level(); 
            return this.endGame(true, "Â§©‰∏ãÁµ±‰∏ÄÔºÅ‰∏âÂúãÊ≠∏‰∏ÄÔºÅ"); 
        }
        
        this.level = lvl;
        this.camera.reset(); 
        
        const mapPoints = MAPS[lvl % MAPS.length];
        this.pathPixels = mapPoints.map(p => ({
            x: p.x * CONFIG.gridSize + CONFIG.gridSize/2,
            y: p.y * CONFIG.gridSize + CONFIG.gridSize/2
        }));

        const lvlConfig = levels[lvl];
        this.maxBaseHp = 1000 + (lvl * 1000); 
        this.#baseHpEnemy = this.maxBaseHp * lvlConfig.statsMultiplier; 
        this.#baseHpPlayer = 1000 + (lvl * 200);
        
        if (lvl === 0) {
            this.#gold = 1000;
            this.#updateChecksum();
        } else {
            const bonus = 1000 + (lvl * 500);
            this.addGold(bonus);
            this.showMessage(`Áç≤ÂæóÂá±ÊóãÁçéÈáë $${bonus}ÔºÅ`, false);
        }

        this.units = []; this.projectiles = []; this.particles = []; this.enemySpawnTimer = 0;
        this.resetUnitCounts();
        
        this.updateUI();
        document.getElementById('enemy-stats-hint').innerText = `(Âº∑Â∫¶: ${Math.round(lvlConfig.statsMultiplier * 100)}%)`;
        setTimeout(() => { AudioSys.sfx.win_level(); this.showMessage(`Á¨¨ ${lvl+1} Èóú - ÈÄ≤ÊîªÔºÅ`); }, 500);
    }

    upgradeArmy() {
        const cost = 500 * Math.pow(2, this.playerLevel - 1); 
        if (this.#gold < cost) {
            this.showMessage("ËªçË≤ª‰∏çË∂≥ÔºÅ", true);
            return;
        }
        
        this.addGold(-cost);
        this.playerLevel++;
        
        const hpRatio = 1.2; 
        const atkRatio = 1.2; 
        const spdRatio = 1.05; 

        this.units.forEach(u => {
            if (u.team === 'player') {
                u.maxHp *= hpRatio;
                u.hp *= hpRatio; 
                u.atk *= atkRatio;
                u.speed *= spdRatio;
                this.createEffect(u.x, u.y, 'hit'); 
            }
        });

        this.showMessage(`ÂÖ®ËªçÁ™ÅÊìäÔºÅÁ≠âÁ¥ö ${this.playerLevel}`, false);
        AudioSys.sfx.win_level();
        this.updateUI();
    }

    spawnPlayerUnit(typeKey) {
        if (this.isLevelTransitioning || this.isGameOver) return;
        const types = SecureConfig.getUnitTypes();
        const data = types[typeKey];
        if (this.#gold < data.cost) return this.showMessage("ËªçË≤ª‰∏çË∂≥", true);
        if (this.cooldowns[typeKey] > 0) return;
        if (data.limit && this.getUnitCount(typeKey) >= data.limit) {
            return this.showMessage(`Êà∞Â†¥Âè™ËÉΩÊúâ‰∏Ä‰Ωç${data.name}ÔºÅ`, true);
        }

        this.addGold(-data.cost); 
        this.cooldowns[typeKey] = data.cd; 
        this.incrementUnitCount(typeKey);
        
        AudioSys.sfx.spawn();
        
        const spawnIdx = (this.playerFaction === 1) ? this.pathPixels.length - 1 : 0;
        const startNode = this.pathPixels[spawnIdx];
        
        const statsMult = Math.pow(1.2, this.playerLevel - 1);
        const speedMult = Math.pow(1.05, this.playerLevel - 1);

        this.units.push(new Unit(startNode.x, startNode.y, 'player', typeKey, spawnIdx, statsMult, speedMult, this.playerFaction));
        this.updateUI();
    }

    spawnEnemyUnit() {
        if (this.isLevelTransitioning) return;
        const levels = SecureConfig.getLevels();
        const lvlData = levels[this.level];
        const types = lvlData.enemyTypes;
        const randType = types[Math.floor(Math.random() * types.length)];
        
        const spawnIdx = (this.playerFaction === 1) ? 0 : this.pathPixels.length - 1;
        const startNode = this.pathPixels[spawnIdx];
        
        this.units.push(new Unit(startNode.x, startNode.y, 'enemy', randType, spawnIdx, lvlData.statsMultiplier, lvlData.speedMultiplier, this.enemyFaction));
    }

    gameLoop(timestamp) {
        if (this.isGameOver) return;
        if (!this.lastTime) this.lastTime = timestamp;
        const dt = timestamp - this.lastTime;
        if (dt > 16) { this.update(); this.draw(); this.lastTime = timestamp; }
        requestAnimationFrame((t) => this.gameLoop(t));
    }

    update() {
        const levels = SecureConfig.getLevels();
        const lvlData = levels[this.level];
        if (!this.isLevelTransitioning) {
            this.addGold(lvlData.goldRate * 0.5); 
            if (this.#gold > 50000) { this.#gold = 50000; this.#updateChecksum(); }
        }

        this.enemySpawnTimer++;
        if (this.enemySpawnTimer > lvlData.enemySpawnRate) {
            this.spawnEnemyUnit();
            this.enemySpawnTimer = 0;
        }

        const unitTypes = SecureConfig.getUnitTypes();
        for (let key in this.cooldowns) {
            if (this.cooldowns[key] > 0) this.cooldowns[key]--;
            const btn = document.getElementById(`btn-${key}`);
            if(btn) {
                const overlay = btn.querySelector('.cooldown-overlay');
                const percent = (this.cooldowns[key] / unitTypes[key].cd) * 100;
                overlay.style.height = `${percent}%`;
                const data = unitTypes[key];
                const isLimited = data.limit && this.getUnitCount(key) >= data.limit;
                if((percent <= 0 && this.#gold < data.cost) || isLimited) btn.classList.add('disabled');
                else btn.classList.remove('disabled');
            }
        }

        this.units.sort((a, b) => a.y - b.y);
        for (let i = this.units.length - 1; i >= 0; i--) {
            const u = this.units[i];
            u.update(this);
            if (u.dead) {
                if (u.team === 'player') this.decrementUnitCount(u.typeKey);
                this.units.splice(i, 1);
                if (u.team === 'enemy') {
                    const bounty = unitTypes[u.typeKey].cost * 0.3 * lvlData.statsMultiplier;
                    this.addGold(bounty);
                    this.addScore(10 * (this.level + 1));
                }
            }
        }

        for (let i = this.projectiles.length - 1; i >= 0; i--) {
            const p = this.projectiles[i];
            p.update();
            if (p.hit) this.projectiles.splice(i, 1);
        }

        this.particles = this.particles.filter(p => p.life > 0);
        this.particles.forEach(p => p.update());
        this.updateUI();

        if (this.#baseHpPlayer <= 0 && !this.isGameOver) {
            AudioSys.sfx.game_over(); this.endGame(false, "ÂüéÊ±†Èô∑ËêΩÔºåÂãùÊïó‰πÉÂÖµÂÆ∂Â∏∏‰∫ã...");
        }
        if (this.#baseHpEnemy <= 0 && !this.isLevelTransitioning) {
            this.#baseHpEnemy = 0; this.isLevelTransitioning = true;
            AudioSys.sfx.win_level(); this.showMessage("ÊïµÁáüÊîªÁ†¥ÔºÅÂÖ®ËªçÊï¥ÂÇô...", false);
            this.units.forEach(u => u.state = 'move');
            setTimeout(() => { this.startLevel(this.level + 1); }, 3000);
        }
    }

    draw() {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this.drawBackground(); 
        this.drawPath();
        
        const start = this.pathPixels[0];
        const end = this.pathPixels[this.pathPixels.length-1];
        
        if (this.playerFaction === 1) {
            this.drawCastle(start.x, start.y, 'enemy', `ÊïµÁáü Lv.${this.level+1}`);
            this.drawCastle(end.x, end.y, 'player', "ÊàëÂüé");
        } else {
            this.drawCastle(start.x, start.y, 'player', "ÊàëÂüé");
            this.drawCastle(end.x, end.y, 'enemy', `ÊïµÁáü Lv.${this.level+1}`);
        }

        this.units.forEach(u => u.draw(this.ctx, this.camera));
        this.projectiles.forEach(p => p.draw(this.ctx, this.camera));
        this.particles.forEach(p => p.draw(this.ctx, this.camera));
    }

    drawBackground() {
        this.ctx.save();
        this.ctx.translate(this.camera.width / 2, this.camera.height / 2);
        this.ctx.scale(this.camera.zoom, this.camera.zoom);
        this.ctx.rotate(this.camera.angle);
        this.ctx.translate(-this.camera.x, -this.camera.y);
        const bgImg = ASSETS.images[`bg_${this.level}`];
        if (bgImg) this.ctx.drawImage(bgImg, 0, 0, 1200, 800);
        else { this.ctx.fillStyle = "#a9dfbf"; this.ctx.fillRect(0, 0, 1200, 800); }
        this.ctx.strokeStyle = "rgba(0,0,0,0.5)"; this.ctx.lineWidth = 5; this.ctx.strokeRect(0, 0, 1200, 800);
        this.ctx.restore();
    }

    drawPath() {
        this.ctx.lineCap = 'round'; this.ctx.lineJoin = 'round';
        this.ctx.lineWidth = 70 * this.camera.zoom; this.ctx.strokeStyle = 'rgba(230, 208, 206, 0.7)'; 
        this.ctx.beginPath();
        if (this.pathPixels.length > 0) {
            const start = this.camera.toScreen(this.pathPixels[0].x, this.pathPixels[0].y);
            this.ctx.moveTo(start.x, start.y);
            for (let i = 1; i < this.pathPixels.length; i++) {
                const p = this.camera.toScreen(this.pathPixels[i].x, this.pathPixels[i].y);
                this.ctx.lineTo(p.x, p.y);
            }
        }
        this.ctx.stroke();
    }

    drawCastle(wx, wy, type, label) {
        const pos = this.camera.toScreen(wx, wy); const s = pos.scale;
        this.ctx.fillStyle = "rgba(0,0,0,0.3)";
        this.ctx.beginPath(); this.ctx.ellipse(pos.x, pos.y, 40 * s, 20 * s, 0, 0, Math.PI * 2); this.ctx.fill();
        
        let faction = 1;
        if (type === 'player') faction = this.playerFaction;
        else faction = this.enemyFaction;
        
        const imgKey = `f${faction}_castle`;
        const img = ASSETS.images[imgKey];
        if (img) {
            const size = 100 * s;
            this.ctx.drawImage(img, pos.x - size/2, pos.y - size, size, size);
        }
        this.drawText(pos.x, pos.y - 110 * s, label, `${20 * s}px Arial`, "#fff");
    }

    drawText(x, y, text, font, color) {
        this.ctx.font = font; this.ctx.fillStyle = color;
        this.ctx.textAlign = "center"; this.ctx.shadowColor = "rgba(0,0,0,0.8)";
        this.ctx.shadowBlur = 4; this.ctx.fillText(text, x, y); this.ctx.shadowBlur = 0;
    }

    updateUI() {
        document.getElementById('gold').innerText = Math.floor(this.#gold);
        document.getElementById('wave-info').innerText = `Á¨¨ ${this.level + 1} Èóú`;
        const pPct = Math.max(0, (this.#baseHpPlayer / (1000 + this.level * 200)) * 100);
        document.getElementById('player-hp-bar').style.width = `${pPct}%`;
        const levels = SecureConfig.getLevels();
        const enemyMaxHp = (1000 + (this.level * 1000)) * levels[this.level].statsMultiplier;
        const ePct = Math.max(0, (this.#baseHpEnemy / enemyMaxHp) * 100);
        document.getElementById('enemy-hp-bar').style.width = `${ePct}%`;
        
        // Êõ¥Êñ∞ÂçáÁ¥öÊåâÈàï
        const nextCost = 500 * Math.pow(2, this.playerLevel - 1);
        document.getElementById('army-lvl').innerText = this.playerLevel;
        document.getElementById('upgrade-cost').innerText = '$' + nextCost;
        const upgBtn = document.getElementById('btn-upgrade');
        if (this.#gold < nextCost) upgBtn.classList.add('disabled'); else upgBtn.classList.remove('disabled');
    }

    showMessage(msg, isWarning = false) {
        const el = document.getElementById('message-area'); el.innerText = msg;
        el.style.color = isWarning ? '#e74c3c' : '#fff'; el.style.borderColor = isWarning ? '#e74c3c' : 'gold';
        el.style.display = 'block'; el.style.opacity = 1;
        if(this.msgTimeout) clearTimeout(this.msgTimeout);
        this.msgTimeout = setTimeout(() => { el.style.display = 'none'; }, 1500);
    }

    createEffect(x, y, type) {
        let color = 'white'; if (type === 'hit') color = 'orange'; if (type === 'blood') color = 'red';
        for(let i=0; i<6; i++) this.particles.push(new Particle(x, y, color));
    }

    endGame(isWin, reason) {
        this.isGameOver = true;
        document.getElementById('result-screen').style.display = 'flex';
        document.getElementById('end-title').innerText = isWin ? "üèÜ Â§ßÁç≤ÂÖ®Âãù" : "üíÄ Êà∞Êïó";
        document.getElementById('end-title').style.color = isWin ? "gold" : "#e74c3c";
        document.getElementById('end-reason').innerText = reason;
        const duration = Math.floor((Date.now() - this.player.startTime)/1000);
        document.getElementById('final-score').innerText = this.#score;
        document.getElementById('final-time').innerText = duration + "s";
        this.sendToGas(duration);
    }

    sendToGas(duration) {
        if(CONFIG.gasUrl.includes("exec")) {
            const data = { 
                name: this.player.name, 
                id: this.player.id, 
                totalScore: this.#score, 
                levelScores: this.#levelScores, 
                duration: duration, 
                date: new Date().toISOString() 
            };
            fetch(CONFIG.gasUrl, { method: 'POST', mode: 'no-cors', headers: {'Content-Type': 'application/json'}, body: JSON.stringify(data) }).catch(e => console.error(e));
        }
    }
}

class Unit {
    constructor(x, y, team, typeKey, pathIdx, statsMult = 1, speedMult = 1, faction = 1) {
        this.x = x; this.y = y; this.team = team; this.typeKey = typeKey;
        this.faction = faction;
        const types = SecureConfig.getUnitTypes();
        const data = types[typeKey];
        
        this.name = data.name; this.maxHp = data.hp * statsMult; this.hp = this.maxHp;
        this.atk = data.atk * statsMult; this.range = data.range; this.speed = data.speed * speedMult;
        this.attackType = data.type; this.cd = data.cd;
        this.pathIndex = pathIdx; this.state = 'move'; this.attackCooldown = 0; this.dead = false;
        this.bounce = 0;
        this.imgKey = `f${faction}_${typeKey}`;
    }
    update(game) {
        if (this.dead) return;
        if (this.attackCooldown > 0) this.attackCooldown--;
        let target = this.findTarget(game);
        if (target) {
            this.state = 'attack';
            if (this.attackCooldown <= 0) { this.attack(target, game); this.attackCooldown = 60; }
        } else {
            this.state = 'move'; this.move(game);
        }
        if (this.state === 'move') this.bounce = Math.abs(Math.sin(Date.now() / 150)) * 5; else this.bounce = 0;
    }
    findTarget(game) {
        for (let u of game.units) {
            if (u.team !== this.team && !u.dead) {
                const dist = Math.hypot(u.x - this.x, u.y - this.y);
                if (dist <= this.range) return u;
            }
        }
        let baseDist = 9999;
        
        let enemyBaseIdx = -1;
        if (this.team === 'player') {
            enemyBaseIdx = (game.playerFaction === 1) ? 0 : game.pathPixels.length - 1;
        } else {
            enemyBaseIdx = (game.playerFaction === 1) ? game.pathPixels.length - 1 : 0;
        }
        
        const base = game.pathPixels[enemyBaseIdx];
        baseDist = Math.hypot(base.x - this.x, base.y - this.y);
        if (baseDist <= this.range) return { type: 'base', team: (this.team === 'player' ? 'enemy' : 'player') };
        
        return null;
    }
    attack(target, game) {
        if (this.attackType === 'ranged' || this.attackType === 'magic') {
            // Projectile y offset adjusted for bigger units
            game.projectiles.push(new Projectile(this.x, this.y - 60, target, this.atk, this.team, this.attackType));
            if(this.attackType === 'magic') AudioSys.sfx.spell(); else AudioSys.sfx.attack_range();
        } else {
            game.createEffect(target.x || this.x, target.y || this.y, 'hit');
            AudioSys.sfx.attack_melee();
            if (target.type === 'base') {
                game.modifyHp(target.team, -this.atk); 
                game.createEffect(this.x, this.y, 'hit'); 
            } else { target.takeDamage(this.atk, game); }
        }
    }
    move(game) {
        let targetIdx = -1;
        
        if (this.team === 'player') {
            targetIdx = (game.playerFaction === 1) ? 0 : game.pathPixels.length - 1;
        } else {
            targetIdx = (game.playerFaction === 1) ? game.pathPixels.length - 1 : 0;
        }
        
        if (this.pathIndex === targetIdx) return; 
        
        let nextIdx = this.pathIndex;
        if (this.pathIndex < targetIdx) nextIdx++;
        else nextIdx--;
        
        const targetNode = game.pathPixels[nextIdx];
        const dx = targetNode.x - this.x; const dy = targetNode.y - this.y;
        const dist = Math.hypot(dx, dy);
        if (dist <= this.speed) { this.x = targetNode.x; this.y = targetNode.y; this.pathIndex = nextIdx; }
        else { this.x += (dx / dist) * this.speed; this.y += (dy / dist) * this.speed; }
    }
    takeDamage(amount, game) {
        this.hp -= amount; game.createEffect(this.x, this.y - 50, 'blood');
        if (this.hp <= 0) { this.dead = true; AudioSys.sfx.hit(); }
    }
    draw(ctx, camera) {
        const pos = camera.toScreen(this.x, this.y); 
        const s = pos.scale;
        
        const scaleFactor = 2.0; // ÊîæÂ§ßÂÄçÁéá
        const bounceOffset = this.bounce * s;

        // ËÖ≥Â∫ïÈô∞ÂΩ± (Á®çÂæÆÊîæÂ§ß‰∏ÄÈªû)
        ctx.fillStyle = "rgba(0,0,0,0.3)"; 
        ctx.beginPath();
        // ÂéüÊú¨ 15, 8 -> ÊîæÂ§ßÂæå 25, 12
        ctx.ellipse(pos.x, pos.y, 25 * s, 12 * s, 0, 0, Math.PI*2); 
        ctx.fill();

        const img = ASSETS.images[this.imgKey];
        if (img) {
            // ÂéüÊú¨ size = 50 * s -> ÊîæÂ§ßÂà∞ 100 * s
            const size = 100 * s; 
            // Áπ™Ë£ΩÂúñÁâá: xÁΩÆ‰∏≠, yË≤ºÈΩäËÖ≥Â∫ï (pos.y)
            ctx.drawImage(img, pos.x - size/2, pos.y - size - bounceOffset, size, size);
        } else {
            // Fallback
            ctx.fillStyle = this.team === 'player' ? 'blue' : 'red';
            ctx.beginPath(); ctx.arc(pos.x, pos.y - 20*s, 20*s, 0, Math.PI*2); ctx.fill();
        }

        // Ë°ÄÊ¢ù (‰ΩçÁΩÆÂæÄ‰∏äÁßª)
        const hpPct = this.hp / this.maxHp; 
        const barY = pos.y - (115 * s) - bounceOffset;
        
        // Ë°ÄÊ¢ùÂØ¨Â∫¶‰πüÁ®çÂæÆÊîæÂ§ß
        const barW = 60 * s;
        const barH = 6 * s;
        const barX = pos.x - barW / 2;

        ctx.fillStyle = "#555"; 
        ctx.fillRect(barX, barY, barW, barH);
        
        ctx.fillStyle = hpPct > 0.5 ? "#2ecc71" : "#e74c3c";
        ctx.fillRect(barX, barY, barW * hpPct, barH);
    }
}

class Projectile {
    constructor(x, y, target, dmg, team, type = 'ranged') {
        this.x = x; this.y = y; this.target = target;
        this.damage = dmg; this.team = team; this.speed = 12; this.hit = false;
        this.type = type;
        
        if (target && target.type !== 'base') {
            this.tx = target.x;
            this.ty = target.y - 50; // Adjusted for bigger units
        } else {
            let targetBaseIdx = 0;
            if (team === 'player') {
                targetBaseIdx = (Game.playerFaction === 1) ? 0 : Game.pathPixels.length - 1;
            } else {
                targetBaseIdx = (Game.playerFaction === 1) ? Game.pathPixels.length - 1 : 0;
            }
            const base = Game.pathPixels[targetBaseIdx];
            this.tx = base.x;
            this.ty = base.y - 50;
        }
    }
    update() {
        if (this.target && !this.target.dead && this.target.type !== 'base') { 
            this.tx = this.target.x; this.ty = this.target.y - 50; 
        }
        const dx = this.tx - this.x; const dy = this.ty - this.y; const dist = Math.hypot(dx, dy);
        if (dist <= this.speed) {
            this.hit = true; Game.createEffect(this.tx, this.ty, 'hit'); AudioSys.sfx.hit();
            if (this.type === 'magic') {
                const splashRange = 100; Game.createEffect(this.tx, this.ty, 'hit');
                if (this.target.type !== 'base') {
                    Game.units.forEach(u => {
                        if (u.team !== this.team && !u.dead) {
                            if (Math.hypot(u.x - this.tx, u.y - 50 - this.ty) < splashRange) u.takeDamage(this.damage * 0.5, Game);
                        }
                    });
                }
            }
            if (this.target.type === 'base') {
                Game.modifyHp(this.target.team, -this.damage); 
            } else if (this.target.takeDamage) { this.target.takeDamage(this.damage, Game); }
        } else { this.x += (dx/dist) * this.speed; this.y += (dy/dist) * this.speed; }
    }
    draw(ctx, camera) {
        const pos = camera.toScreen(this.x, this.y); const s = pos.scale;
        ctx.fillStyle = this.team === 'player' ? '#3498db' : '#e74c3c';
        if (this.type === 'magic') ctx.fillStyle = '#9b59b6';
        ctx.beginPath(); ctx.arc(pos.x, pos.y, (this.type === 'magic' ? 8 : 5) * s, 0, Math.PI*2); ctx.fill();
    }
}

class Particle {
    constructor(x, y, color) {
        this.x = x; this.y = y; this.color = color;
        this.vx = (Math.random()-0.5)*6; this.vy = (Math.random()-0.5)*6;
        this.life = 1.0; this.gravity = 0.2;
    }
    update() { this.x += this.vx; this.y += this.vy; this.vy += this.gravity; this.life -= 0.05; }
    draw(ctx, camera) {
        const pos = camera.toScreen(this.x, this.y); const s = pos.scale;
        ctx.globalAlpha = Math.max(0, this.life); ctx.fillStyle = this.color;
        ctx.beginPath(); ctx.arc(pos.x, pos.y, 4 * s, 0, Math.PI*2); ctx.fill(); ctx.globalAlpha = 1;
    }
}

const Game = new GameEngine();

</script>
</body>
</html>
