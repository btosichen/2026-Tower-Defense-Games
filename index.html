<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ä¸‰åœ‹ç­–ç•¥æ”»é˜²æˆ° (v0128)</title>
    <style>
        :root {
            --primary-color: #f39c12; 
            --secondary-color: #c0392b; 
            --player-color: #2980b9;  
            --enemy-color: #c0392b;   
            --bg-color: #fcf3cf;
            --ui-bg: rgba(255, 255, 255, 0.95);
        }

        body {
            margin: 0; padding: 0;
            font-family: "Microsoft JhengHei", "Heiti TC", sans-serif;
            background-color: #2c3e50;
            display: flex; justify-content: center; align-items: center;
            height: 100vh; overflow: hidden; user-select: none;
        }

        #game-container {
            position: relative; width: 1200px; height: 800px;
            background-color: #2c3e50; 
            box-shadow: 0 0 50px rgba(0,0,0,0.8);
            border-radius: 12px; overflow: hidden;
            display: none; cursor: grab;
        }
        
        #game-container:active { cursor: grabbing; }
        
        @media (max-width: 1220px), (max-height: 820px) { #game-container { transform: scale(0.8); } }
        @media (max-width: 980px) { #game-container { transform: scale(0.6); } }

        canvas { display: block; }

        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10;
        }

        .hud-panel {
            position: absolute; background: var(--ui-bg); border: 3px solid var(--primary-color);
            border-radius: 12px; padding: 8px; pointer-events: auto; color: #2c3e50;
            font-weight: bold; box-shadow: 0 6px 15px rgba(0,0,0,0.3); backdrop-filter: blur(5px);
        }

        /* Top Bar */
        #top-bar {
            top: 15px; left: 50%; transform: translateX(-50%); width: 92%; height: 60px;
            display: flex; justify-content: space-between; align-items: center; font-size: 18px;
            border-radius: 30px;
        }

        .hp-bar-container {
            width: 250px; height: 20px; background: #34495e; border-radius: 10px;
            overflow: hidden; border: 2px solid #fff; position: relative; margin: 0 10px;
        }
        .hp-bar-fill { height: 100%; transition: width 0.2s; position: relative; }

        /* Camera Controls */
        #cam-controls {
            position: absolute; right: 20px; top: 100px; display: flex; flex-direction: column; gap: 10px; pointer-events: auto;
        }
        .cam-btn {
            width: 45px; height: 45px; border-radius: 50%; border: 2px solid #fff;
            background: rgba(44, 62, 80, 0.9); color: white; font-size: 22px; cursor: pointer;
            display: flex; align-items: center; justify-content: center; transition: 0.2s;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }
        .cam-btn:hover { background: var(--primary-color); transform: scale(1.1); }

        /* Bottom Bar */
        #bottom-bar {
            bottom: 20px; left: 50%; transform: translateX(-50%); 
            display: flex; gap: 8px;
            padding: 12px 20px; width: auto; max-width: 95%; justify-content: center;
            border-radius: 20px; overflow-x: auto; overflow-y: hidden;
            z-index: 100; white-space: nowrap;
        }

        .unit-btn {
            width: 85px; height: 110px; border: 2px solid #bdc3c7; border-radius: 10px;
            background: linear-gradient(to bottom, #fff, #f0f3f4); cursor: pointer;
            display: inline-flex; flex-direction: column; align-items: center; justify-content: center;
            transition: all 0.1s; position: relative; box-shadow: 0 4px 0 #95a5a6; flex-shrink: 0;
        }
        .unit-btn:hover { transform: translateY(-2px); border-color: var(--primary-color); }
        .unit-btn:active { transform: translateY(4px); box-shadow: 0 0 0 #95a5a6; }
        .unit-btn.disabled { filter: grayscale(100%); opacity: 0.6; cursor: not-allowed; background: #e0e0e0; }
        
        .unit-btn[id="btn-general"] { border-color: gold; background: linear-gradient(to bottom, #fcf3cf, #f9e79f); box-shadow: 0 4px 0 #d4ac0d; }
        
        .unit-img-preview { width: 50px; height: 50px; object-fit: contain; margin-bottom: 4px; filter: drop-shadow(2px 2px 2px rgba(0,0,0,0.2)); }
        .unit-name { font-size: 13px; font-weight: 800; color: #2c3e50; }
        .unit-cost { background: gold; color: #d35400; padding: 2px 6px; border-radius: 6px; font-size: 12px; margin-top: 2px; font-weight: bold; border: 1px solid #d35400;}
        .hotkey { position: absolute; top: 3px; right: 6px; font-size: 10px; color: #7f8c8d; font-weight: bold; }
        .limit-badge {
            position: absolute; top: 0; left: 0; background: #c0392b; color: white;
            font-size: 10px; padding: 2px 5px; border-radius: 8px 0 8px 0; display: none;
        }

        /* Screens */
        #login-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: url('https://raw.githubusercontent.com/btosichen/2026-Tower-Defense-Games/23e73bd815ab029e43fc9728641e0358131555c6/Gemini_Generated_Image_9bni789bni789bni.png') no-repeat center center;
            background-size: cover;
            display: flex; flex-direction: column;
            justify-content: center; align-items: center;
            color: white; z-index: 200;
        }

        #result-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(44, 62, 80, 0.98);
            display: flex; flex-direction: column;
            justify-content: center; align-items: center;
            color: white; z-index: 200;
        }
        
        .panel-box {
            background: rgba(255, 255, 255, 0.95); 
            padding: 40px; border-radius: 20px;
            text-align: center; color: #2c3e50;
            border: 6px solid var(--primary-color);
            width: 650px;
            box-shadow: 0 20px 50px rgba(0,0,0,0.8);
            max-width: 95%;
            backdrop-filter: blur(10px);
        }

        .char-selection { display: flex; justify-content: center; gap: 30px; margin: 25px 0; }
        .char-card {
            width: 160px; padding: 15px; border: 3px solid #ddd; border-radius: 12px;
            cursor: pointer; transition: all 0.3s; background: #fff; position: relative;
        }
        .char-card:hover { transform: translateY(-5px); box-shadow: 0 10px 20px rgba(0,0,0,0.2); }
        .char-card.selected {
            border-color: var(--secondary-color); background: #fadbd8;
            box-shadow: 0 0 0 4px rgba(192, 57, 43, 0.3); transform: scale(1.05);
        }
        .char-img { width: 100%; height: 120px; object-fit: contain; margin-bottom: 10px; }
        .char-desc { font-size: 14px; color: #555; line-height: 1.4;}

        input {
            padding: 15px; font-size: 20px; width: 60%;
            margin: 20px 0; text-align: center; border: 2px solid #bdc3c7; border-radius: 8px;
        }
        button.start-btn {
            background: var(--secondary-color); color: white; border: none;
            padding: 15px 60px; font-size: 24px; border-radius: 40px;
            cursor: pointer; transition: 0.3s; box-shadow: 0 6px 0 #922b21;
        }
        button.start-btn:hover { transform: translateY(-3px); box-shadow: 0 9px 0 #922b21; background: #e74c3c; }

        #message-area {
            position: absolute; top: 40%; left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.85); color: #fff;
            padding: 15px 50px; border-radius: 50px;
            font-size: 32px; font-weight: bold;
            display: none; pointer-events: none;
            z-index: 150; border: 4px solid gold;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }
        
        #avatar-display {
            width: 50px; height: 50px; border-radius: 50%; border: 3px solid white;
            margin-right: 15px; background: #fff; object-fit: contain; box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }
    </style>
</head>
<body>

    <div id="login-screen">
        <div class="panel-box">
            <h1 style="font-size: 40px; margin-bottom: 10px; text-shadow: 2px 2px 0 #ddd;">âš”ï¸ ä¸‰åœ‹ç­–ç•¥æ”»é˜²æˆ°</h1>
            <p style="color: #7f8c8d; font-size: 18px;">è«‹é¸æ“‡æ‚¨çš„æŒ‡æ®å®˜</p>
            
            <div class="char-selection">
                <!-- é¾å°‡è» (è§’è‰²1) -->
                <div class="char-card" onclick="Game.selectCharacter(1, this)">
                    <img src="https://raw.githubusercontent.com/btosichen/2026-Tower-Defense-Games/73d914672748f372cbd42737a5025b071972627a/logo-1-0-0.png" class="char-img">
                    <div style="font-weight:bold; font-size:20px; color: #2980b9;">é¾å°‡è»</div>
                    <div class="char-desc">é®å®ˆæ±æ–¹<br>ç”±å³æ”»å·¦</div>
                </div>
                <!-- è™å…ƒå¸¥ (è§’è‰²2) -->
                <div class="char-card" onclick="Game.selectCharacter(2, this)">
                    <img src="https://raw.githubusercontent.com/btosichen/2026-Tower-Defense-Games/73d914672748f372cbd42737a5025b071972627a/logo-2-0-0.png" class="char-img">
                    <div style="font-weight:bold; font-size:20px; color: #c0392b;">è™å…ƒå¸¥</div>
                    <div class="char-desc">é®å®ˆè¥¿æ–¹<br>ç”±å·¦æ”»å³</div>
                </div>
            </div>

            <input type="text" id="player-name" placeholder="è«‹è¼¸å…¥å°‡è»å¤§å" maxlength="10">
            <br>
            <button class="start-btn" onclick="Game.initLogin()">å‡ºå¾</button>
            <p id="loading-text" style="color: #e67e22; font-size: 14px; margin-top: 15px; font-weight: bold;">æ­£åœ¨å¾µå¬å…µé¦¬...</p>
        </div>
    </div>

    <div id="game-container">
        <canvas id="gameCanvas" width="1200" height="800"></canvas>
        
        <div id="ui-layer">
            <div id="top-bar" class="hud-panel">
                <!-- å·¦å´ï¼šæ•µæ–¹ -->
                <div style="display:flex; align-items:center;">
                    <span style="color:var(--enemy-color); margin-right:10px;">ğŸš© æ•µç‡Ÿ</span>
                    <div class="hp-bar-container">
                        <div id="enemy-hp-bar" class="hp-bar-fill" style="width: 100%; background: linear-gradient(to right, #e74c3c, #c0392b);"></div>
                    </div>
                    <span id="enemy-stats-hint" style="font-size:12px;color:#e74c3c; margin-left:5px;"></span>
                </div>

                <div style="text-align:center; min-width: 150px;">
                    <div id="wave-info" style="font-size:24px; color:var(--primary-color); font-weight:900; text-shadow: 1px 1px 0 #333;">ç¬¬ 1 é—œ</div>
                    <div style="font-size:18px; margin-top:5px; background:rgba(0,0,0,0.05); padding:2px 15px; border-radius:15px; display:inline-block;">
                        ğŸ’° <span id="gold" style="color:#d35400;">0</span>
                    </div>
                </div>

                <!-- å³å´ï¼šæˆ‘æ–¹ -->
                <div style="display:flex; align-items:center;">
                    <img id="avatar-display" src="" style="display:none;">
                    <span style="color:var(--player-color); margin-right:10px;">ğŸ›¡ï¸ æˆ‘åŸ</span>
                    <div class="hp-bar-container">
                        <div id="player-hp-bar" class="hp-bar-fill" style="width: 100%; background: linear-gradient(to right, #3498db, #2980b9);"></div>
                    </div>
                </div>
            </div>

            <div id="cam-controls">
                <div class="cam-btn" onclick="Game.camera.zoomIn()" title="æ”¾å¤§ (+)">â•</div>
                <div class="cam-btn" onclick="Game.camera.zoomOut()" title="ç¸®å° (-)">â–</div>
                <div class="cam-btn" onclick="Game.camera.rotate(-0.1)" title="å·¦æ—‹è½‰ (Q)">â†º</div>
                <div class="cam-btn" onclick="Game.camera.rotate(0.1)" title="å³æ—‹è½‰ (E)">â†»</div>
                <div class="cam-btn" onclick="Game.camera.reset()" title="é‡ç½®è¦–è§’ (R)">ğŸ¯</div>
            </div>

            <div id="message-area">æˆ°é¬¥é–‹å§‹ï¼</div>
            <div id="bottom-bar" class="hud-panel"></div>
        </div>
    </div>

    <div id="result-screen" style="display: none;">
        <div class="panel-box">
            <h1 id="end-title" style="font-size: 48px;">æˆ°å½¹çµæŸ</h1>
            <p id="end-reason" style="font-size: 20px; color: #555;">...</p>
            <div style="text-align:left; margin: 30px 0; font-size: 20px; background: #f9f9f9; padding: 20px; border-radius: 10px;">
                <div style="margin-bottom: 10px;">ğŸ… ç¸½åˆ†ï¼š<span id="final-score" style="font-weight:bold; color:var(--primary-color);">0</span></div>
                <div>â±ï¸ è€—æ™‚ï¼š<span id="final-time" style="font-weight:bold;">0s</span></div>
            </div>
            <button class="start-btn" onclick="location.reload()">å†æˆ°ä¸€å ´</button>
        </div>
    </div>

<script>
/**
 * è³‡æºèˆ‡é…ç½®
 * é‡æ§‹ï¼šä¸å†å€åˆ† player/enemy åœ–ç‰‡ï¼Œè€Œæ˜¯å€åˆ† f1 (é¾) / f2 (è™)
 */
const ASSETS = {
    chars: {
        1: "https://raw.githubusercontent.com/btosichen/2026-Tower-Defense-Games/73d914672748f372cbd42737a5025b071972627a/logo-1-0-0.png",
        2: "https://raw.githubusercontent.com/btosichen/2026-Tower-Defense-Games/73d914672748f372cbd42737a5025b071972627a/logo-2-0-0.png"
    },
    backgrounds: [
        "https://raw.githubusercontent.com/btosichen/2026-Tower-Defense-Games/d1541125592a5f3ca60a7ba19a3ddc42cce65421/bg-0.png",
        "https://raw.githubusercontent.com/btosichen/2026-Tower-Defense-Games/d1541125592a5f3ca60a7ba19a3ddc42cce65421/bg-1.png",
        "https://raw.githubusercontent.com/btosichen/2026-Tower-Defense-Games/d1541125592a5f3ca60a7ba19a3ddc42cce65421/bg-2.png",
        "https://raw.githubusercontent.com/btosichen/2026-Tower-Defense-Games/d1541125592a5f3ca60a7ba19a3ddc42cce65421/bg-3.png",
        "https://raw.githubusercontent.com/btosichen/2026-Tower-Defense-Games/d1541125592a5f3ca60a7ba19a3ddc42cce65421/bg-4.png",
        "https://raw.githubusercontent.com/btosichen/2026-Tower-Defense-Games/d1541125592a5f3ca60a7ba19a3ddc42cce65421/bg-5.png",
        "https://raw.githubusercontent.com/btosichen/2026-Tower-Defense-Games/d1541125592a5f3ca60a7ba19a3ddc42cce65421/bg-6.png",
        "https://raw.githubusercontent.com/btosichen/2026-Tower-Defense-Games/d1541125592a5f3ca60a7ba19a3ddc42cce65421/bg-7.png",
        "https://raw.githubusercontent.com/btosichen/2026-Tower-Defense-Games/d1541125592a5f3ca60a7ba19a3ddc42cce65421/bg-8.png",
        "https://raw.githubusercontent.com/btosichen/2026-Tower-Defense-Games/d1541125592a5f3ca60a7ba19a3ddc42cce65421/bg-9.png"
    ],
    // é™£ç‡Ÿ 1ï¼šé¾å°‡è» (è—è‰²ç³»)
    f1: {
        castle: "https://raw.githubusercontent.com/btosichen/2026-Tower-Defense-Games/ac4b7a1f6d922e4765e29eef26384cd26bd7afd8/logo-1-0%20(90%20x%2090%20%E5%83%8F%E7%B4%A0).png",
        sword: "https://raw.githubusercontent.com/btosichen/2026-Tower-Defense-Games/ac4b7a1f6d922e4765e29eef26384cd26bd7afd8/logo-1-1%20(50%20x%2050%20%E5%83%8F%E7%B4%A0).png",
        bow: "https://raw.githubusercontent.com/btosichen/2026-Tower-Defense-Games/ac4b7a1f6d922e4765e29eef26384cd26bd7afd8/logo-1-2(50%20x%2050%20%E5%83%8F%E7%B4%A0).png",
        spear: "https://raw.githubusercontent.com/btosichen/2026-Tower-Defense-Games/ac4b7a1f6d922e4765e29eef26384cd26bd7afd8/logo-1-3(50%20x%2050%20%E5%83%8F%E7%B4%A0).png",
        cavalry: "https://raw.githubusercontent.com/btosichen/2026-Tower-Defense-Games/ac4b7a1f6d922e4765e29eef26384cd26bd7afd8/logo-1-4(50%20x%2050%20%E5%83%8F%E7%B4%A0).png",
        vanguard: "https://raw.githubusercontent.com/btosichen/2026-Tower-Defense-Games/ac4b7a1f6d922e4765e29eef26384cd26bd7afd8/logo-1-5(50%20x%2050%20%E5%83%8F%E7%B4%A0).png",
        vice: "https://raw.githubusercontent.com/btosichen/2026-Tower-Defense-Games/ac4b7a1f6d922e4765e29eef26384cd26bd7afd8/logo-1-6(50%20x%2050%20%E5%83%8F%E7%B4%A0).png",
        general: "https://raw.githubusercontent.com/btosichen/2026-Tower-Defense-Games/ac4b7a1f6d922e4765e29eef26384cd26bd7afd8/logo-1-7(50%20x%2050%20%E5%83%8F%E7%B4%A0).png",
        advisor: "https://raw.githubusercontent.com/btosichen/2026-Tower-Defense-Games/ac4b7a1f6d922e4765e29eef26384cd26bd7afd8/logo-1-8(50%20x%2050%20%E5%83%8F%E7%B4%A0).png"
    },
    // é™£ç‡Ÿ 2ï¼šè™å…ƒå¸¥ (ç´…è‰²ç³»)
    f2: {
        castle: "https://raw.githubusercontent.com/btosichen/2026-Tower-Defense-Games/ac4b7a1f6d922e4765e29eef26384cd26bd7afd8/logo-2-0%20(90%20x%2090%20%E5%83%8F%E7%B4%A0).png",
        sword: "https://raw.githubusercontent.com/btosichen/2026-Tower-Defense-Games/ac4b7a1f6d922e4765e29eef26384cd26bd7afd8/logo-2-1(50%20x%2050%20%E5%83%8F%E7%B4%A0).png",
        bow: "https://raw.githubusercontent.com/btosichen/2026-Tower-Defense-Games/ac4b7a1f6d922e4765e29eef26384cd26bd7afd8/logo-2-2(50%20x%2050%20%E5%83%8F%E7%B4%A0).png",
        spear: "https://raw.githubusercontent.com/btosichen/2026-Tower-Defense-Games/ac4b7a1f6d922e4765e29eef26384cd26bd7afd8/logo-2-3(50%20x%2050%20%E5%83%8F%E7%B4%A0).png",
        cavalry: "https://raw.githubusercontent.com/btosichen/2026-Tower-Defense-Games/ac4b7a1f6d922e4765e29eef26384cd26bd7afd8/logo-2-4(50%20x%2050%20%E5%83%8F%E7%B4%A0).png",
        vanguard: "https://raw.githubusercontent.com/btosichen/2026-Tower-Defense-Games/ac4b7a1f6d922e4765e29eef26384cd26bd7afd8/logo-2-5(50%20x%2050%20%E5%83%8F%E7%B4%A0).png",
        vice: "https://raw.githubusercontent.com/btosichen/2026-Tower-Defense-Games/ac4b7a1f6d922e4765e29eef26384cd26bd7afd8/logo-2-6(50%20x%2050%20%E5%83%8F%E7%B4%A0).png",
        general: "https://raw.githubusercontent.com/btosichen/2026-Tower-Defense-Games/ac4b7a1f6d922e4765e29eef26384cd26bd7afd8/logo-2-7(50%20x%2050%20%E5%83%8F%E7%B4%A0).png",
        advisor: "https://raw.githubusercontent.com/btosichen/2026-Tower-Defense-Games/ac4b7a1f6d922e4765e29eef26384cd26bd7afd8/logo-2-8(50%20x%2050%20%E5%83%8F%E7%B4%A0).png"
    },
    images: {} 
};

// å®‰å…¨è¨­å®š
const SecureConfig = (function() {
    const _units = {
        sword:    { name: 'åˆ€å…µ',   cost: 50,  hp: 120, atk: 15, range: 40,  speed: 2.5, type: 'melee', cd: 60 },
        bow:      { name: 'å¼“å…µ',   cost: 120, hp: 80,  atk: 25, range: 250, speed: 2.5, type: 'ranged', cd: 80 },
        spear:    { name: 'æ§å…µ',   cost: 200, hp: 180, atk: 40, range: 70,  speed: 2.0, type: 'melee', cd: 100 },
        cavalry:  { name: 'é¨å…µ',   cost: 280, hp: 220, atk: 45, range: 40,  speed: 5.0, type: 'melee', cd: 120 },
        vanguard: { name: 'å‰é‹’',   cost: 350, hp: 300, atk: 55, range: 40,  speed: 3.5, type: 'melee', cd: 150 },
        vice:     { name: 'å‰¯å°‡è»', cost: 500, hp: 600, atk: 70, range: 50,  speed: 1.5, type: 'melee', cd: 300 },
        advisor:  { name: 'åœ‹å¸«',   cost: 800, hp: 200, atk: 100, range: 300, speed: 1.5, type: 'magic', cd: 400 },
        general:  { name: 'å¤§å°‡è»', cost: 1500, hp: 2000,atk: 200, range: 60, speed: 1.2, type: 'melee', cd: 600, limit: 1 }
    };
    
    const _levels = Array.from({length: 10}, (_, i) => ({
        enemySpawnRate: Math.max(60, 180 - i * 12),
        goldRate: 1 + i * 0.5,
        enemyTypes: i < 1 ? ['sword', 'sword', 'spear'] :
                    i < 3 ? ['sword', 'bow', 'spear', 'cavalry'] :
                    i < 6 ? ['spear', 'bow', 'cavalry', 'vanguard', 'vice'] :
                    i < 8 ? ['vanguard', 'vice', 'advisor'] :
                            ['vice', 'advisor', 'general'],
        statsMultiplier: 1 + i,
        speedMultiplier: 1 + (i * 0.1)
    }));

    Object.freeze(_units);
    Object.freeze(_levels);

    return {
        getUnitTypes: () => _units,
        getLevels: () => _levels
    };
})();

const CONFIG = {
    gridSize: 80, width: 15, height: 10,
    gasUrl: 'https://script.google.com/macros/s/AKfycbwqZFv8Jzk4A1ERYbzljRudebPBTlBn4OcSsFWfWBGLTIKGSMDEd3focinsGovte4c9/exec'
};

const MAPS = [
    [{x:0,y:2}, {x:3,y:2}, {x:3,y:7}, {x:8,y:7}, {x:8,y:2}, {x:12,y:2}, {x:12,y:6}, {x:14,y:6}],
    [{x:0,y:1}, {x:2,y:1}, {x:2,y:8}, {x:12,y:8}, {x:12,y:1}, {x:14,y:1}],
    [{x:0,y:8}, {x:2,y:8}, {x:2,y:2}, {x:5,y:2}, {x:5,y:8}, {x:8,y:8}, {x:8,y:2}, {x:11,y:2}, {x:11,y:8}, {x:14,y:8}],
    [{x:0,y:5}, {x:4,y:5}, {x:4,y:3}, {x:10,y:3}, {x:10,y:6}, {x:14,y:6}],
    [{x:0,y:0}, {x:13,y:0}, {x:13,y:8}, {x:2,y:8}, {x:2,y:3}, {x:10,y:3}, {x:10,y:5}, {x:14,y:5}],
    [{x:0,y:9}, {x:3,y:9}, {x:3,y:6}, {x:6,y:6}, {x:6,y:3}, {x:9,y:3}, {x:9,y:0}, {x:14,y:0}],
    [{x:0,y:2}, {x:14,y:2}, {x:14,y:5}, {x:0,y:5}, {x:0,y:8}, {x:14,y:8}],
    [{x:0,y:1}, {x:6,y:1}, {x:6,y:5}, {x:8,y:5}, {x:8,y:9}, {x:14,y:9}],
    [{x:0,y:4}, {x:1,y:4}, {x:1,y:9}, {x:13,y:9}, {x:13,y:1}, {x:1,y:1}, {x:1,y:4}, {x:14,y:4}],
    [{x:0,y:0}, {x:0,y:9}, {x:3,y:9}, {x:3,y:2}, {x:6,y:2}, {x:6,y:7}, {x:9,y:7}, {x:9,y:1}, {x:12,y:1}, {x:12,y:8}, {x:14,y:8}]
];

const ImageLoader = {
    loadAll: function(callback) {
        let loaded = 0;
        const total = 28; 
        const checkLoad = () => {
            loaded++;
            if (loaded >= total && callback) callback();
        };
        // è¼‰å…¥é™£ç‡Ÿ1 (é¾)
        for (let key in ASSETS.f1) {
            const img = new Image(); img.src = ASSETS.f1[key];
            img.onload = checkLoad; img.onerror = checkLoad;
            ASSETS.images[`f1_${key}`] = img;
        }
        // è¼‰å…¥é™£ç‡Ÿ2 (è™)
        for (let key in ASSETS.f2) {
            const img = new Image(); img.src = ASSETS.f2[key];
            img.onload = checkLoad; img.onerror = checkLoad;
            ASSETS.images[`f2_${key}`] = img;
        }
        ASSETS.backgrounds.forEach((url, index) => {
            const img = new Image(); img.src = url;
            img.onload = checkLoad; img.onerror = checkLoad;
            ASSETS.images[`bg_${index}`] = img;
        });
        
        setTimeout(() => {
            if (loaded < total && callback) {
                console.warn("éƒ¨åˆ†åœ–ç‰‡è¼‰å…¥å¤±æ•—ï¼Œå¼·åˆ¶å•Ÿå‹•ä»‹é¢");
                callback();
            }
        }, 3000);
    }
};

const AudioSys = {
    ctx: null,
    init: function() {
        if (!this.ctx) { this.ctx = new (window.AudioContext || window.webkitAudioContext)(); }
        if (this.ctx.state === 'suspended') this.ctx.resume();
    },
    playTone: function(freq, type, duration, vol = 0.1) {
        if (!this.ctx) return;
        const osc = this.ctx.createOscillator(); const gain = this.ctx.createGain();
        osc.type = type; osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
        gain.gain.setValueAtTime(vol, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
        osc.connect(gain); gain.connect(this.ctx.destination);
        osc.start(); osc.stop(this.ctx.currentTime + duration);
    },
    sfx: {
        spawn: () => AudioSys.playTone(400, 'triangle', 0.1, 0.1),
        attack_melee: () => AudioSys.playTone(100, 'sawtooth', 0.1, 0.05),
        attack_range: () => AudioSys.playTone(800, 'sine', 0.1, 0.05),
        hit: () => AudioSys.playTone(150, 'square', 0.1, 0.05),
        spell: () => { if(AudioSys.ctx) [600, 500, 400].forEach((f, i) => setTimeout(() => AudioSys.playTone(f, 'sine', 0.3, 0.1), i * 100)); },
        win_level: () => { if(AudioSys.ctx) [440, 554, 659].forEach((f, i) => setTimeout(() => AudioSys.playTone(f, 'square', 0.4, 0.1), i * 100)); },
        game_over: () => { if(AudioSys.ctx) [300, 250, 200].forEach((f, i) => setTimeout(() => AudioSys.playTone(f, 'sawtooth', 0.5, 0.1), i * 300)); }
    }
};

class Camera {
    constructor(width, height) {
        this.width = width; this.height = height;
        this.x = width / 2; this.y = height / 2;
        this.zoom = 1; this.angle = 0; this.dragStart = null;
    }
    toScreen(x, y) {
        let dx = x - this.x; let dy = y - this.y;
        let cos = Math.cos(this.angle); let sin = Math.sin(this.angle);
        let rx = dx * cos - dy * sin; let ry = dx * sin + dy * cos;
        return { x: this.width / 2 + rx * this.zoom, y: this.height / 2 + ry * this.zoom, scale: this.zoom };
    }
    zoomIn() { this.zoom = Math.min(this.zoom * 1.1, 3); }
    zoomOut() { this.zoom = Math.max(this.zoom / 1.1, 0.5); }
    rotate(rad) { this.angle += rad; }
    reset() { this.zoom = 1; this.angle = 0; this.x = this.width/2; this.y = this.height/2; }
    handleMouseDown(e) { this.dragStart = { x: e.clientX, y: e.clientY, camX: this.x, camY: this.y }; }
    handleMouseMove(e) {
        if (!this.dragStart) return;
        const dx = (e.clientX - this.dragStart.x) / this.zoom;
        const dy = (e.clientY - this.dragStart.y) / this.zoom;
        let cos = Math.cos(-this.angle); let sin = Math.sin(-this.angle);
        this.x = this.dragStart.camX - (dx * cos - dy * sin);
        this.y = this.dragStart.camY - (dx * sin + dy * cos);
    }
    handleMouseUp() { this.dragStart = null; }
    handleWheel(e) { e.preventDefault(); if (e.deltaY < 0) this.zoomIn(); else this.zoomOut(); }
}

class GameEngine {
    #gold = 0; #score = 0; #levelScores = new Array(10).fill(0);
    #baseHpPlayer = 1000; #baseHpEnemy = 1000; #playerUnitCounts = {};
    #checksum = 0;

    constructor() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.player = { name: '', id: '' };
        this.camera = new Camera(1200, 800);
        this.selectedAvatar = null; // 1=é¾(F1), 2=è™(F2)
        this.playerFaction = 1;
        this.enemyFaction = 2;
        
        this.level = 0; this.isGameOver = false;
        this.enemySpawnTimer = 0; this.isLevelTransitioning = false;
        this.maxBaseHp = 1000;

        this.units = []; this.projectiles = []; this.particles = []; this.pathPixels = [];
        this.lastTime = 0;
        this.cooldowns = {}; 
        
        ImageLoader.loadAll(() => {
            document.getElementById('loading-text').innerText = "å…µé¦¬å·²å‚™é½Šï¼Œè«‹é¸æ“‡æŒ‡æ®å®˜ï¼";
        });

        const container = document.getElementById('game-container');
        container.addEventListener('mousedown', e => this.camera.handleMouseDown(e));
        window.addEventListener('mousemove', e => this.camera.handleMouseMove(e));
        window.addEventListener('mouseup', () => this.camera.handleMouseUp());
        container.addEventListener('wheel', e => this.camera.handleWheel(e));
        
        document.addEventListener('keydown', e => {
            if (e.key === 'q' || e.key === 'Q') this.camera.rotate(-0.1);
            if (e.key === 'e' || e.key === 'E') this.camera.rotate(0.1);
            if (e.key === 'r' || e.key === 'R') this.camera.reset();
        });
        
        this.#updateChecksum();
    }

    getGold() { return this.#gold; }
    getScore() { return this.#score; }
    getHpPlayer() { return this.#baseHpPlayer; }
    getHpEnemy() { return this.#baseHpEnemy; }
    getUnitCount(key) { return this.#playerUnitCounts[key] || 0; }

    #updateChecksum() { this.#checksum = this.#gold + (this.#score * 1.5) + 42; }
    #verifyIntegrity() {
        if (this.#checksum !== (this.#gold + (this.#score * 1.5) + 42)) {
            alert("åµæ¸¬åˆ°ç•°å¸¸æ•¸æ“šï¼éŠæˆ²çµ‚æ­¢ã€‚"); this.isGameOver = true; return false;
        }
        return true;
    }

    addGold(amount) { if (!this.#verifyIntegrity()) return; this.#gold += amount; this.#updateChecksum(); }
    addScore(amount) { if (!this.#verifyIntegrity()) return; this.#score += amount; this.#updateChecksum(); }
    modifyHp(target, amount) { if (target === 'player') this.#baseHpPlayer += amount; else this.#baseHpEnemy += amount; }
    resetUnitCounts() { this.#playerUnitCounts = {}; }
    incrementUnitCount(key) { this.#playerUnitCounts[key] = (this.#playerUnitCounts[key] || 0) + 1; }
    decrementUnitCount(key) { if(this.#playerUnitCounts[key] > 0) this.#playerUnitCounts[key]--; }

    createUnitButtons() {
        const bar = document.getElementById('bottom-bar');
        if(!bar) return; 
        bar.innerHTML = '';
        const types = SecureConfig.getUnitTypes();
        const keys = Object.keys(types);
        this.cooldowns = {}; 
        
        keys.forEach((key, index) => {
            const u = types[key];
            const div = document.createElement('div');
            div.className = 'unit-btn';
            div.id = `btn-${key}`;
            div.onclick = () => this.spawnPlayerUnit(key);
            
            // æ ¹æ“šé¸æ“‡çš„é™£ç‡Ÿé¡¯ç¤ºæŒ‰éˆ•åœ–ç‰‡
            const imgSrc = ASSETS.images[`f${this.playerFaction}_${key}`]?.src || "";
            
            div.innerHTML = `
                <span class="hotkey">${index+1}</span>
                <div class="limit-badge" id="limit-${key}">é™1</div>
                <img src="${imgSrc}" class="unit-img-preview" onerror="this.src=''">
                <div class="unit-name">${u.name}</div>
                <div class="unit-cost">$${u.cost}</div>
                <div class="cooldown-overlay" style="position:absolute;bottom:0;left:0;width:100%;height:0%;background:rgba(0,0,0,0.5);transition:height 0.1s;"></div>
            `;
            bar.appendChild(div);
            this.cooldowns[key] = 0;
            if (u.limit) div.querySelector('.limit-badge').style.display = 'block';
        });
        
        // é‡æ–°ç¶å®šéµç›¤äº‹ä»¶ï¼Œç§»é™¤èˆŠçš„
        // ç°¡å–®èµ·è¦‹ï¼Œé€™è£¡ä¸ç§»é™¤èˆŠçš„ï¼Œä½†è«‹æ³¨æ„ä¸è¦é‡è¤‡ç¶å®š
    }

    selectCharacter(id, el) {
        this.selectedAvatar = id;
        document.querySelectorAll('.char-card').forEach(c => c.classList.remove('selected'));
        el.classList.add('selected');
    }

    initLogin() {
        if (!this.selectedAvatar) return alert("è«‹å…ˆé¸æ“‡ä¸€ä½æŒ‡æ®å®˜ï¼");
        const name = document.getElementById('player-name').value.trim();
        if (!name) return alert("è«‹è¼¸å…¥å¤§åï¼");
        
        this.player.name = name; this.player.id = 'ID_' + Date.now(); this.player.startTime = Date.now();
        AudioSys.init();
        
        // è¨­å®šé™£ç‡Ÿ
        // 1=é¾(å³å¾€å·¦), 2=è™(å·¦å¾€å³)
        this.playerFaction = this.selectedAvatar;
        this.enemyFaction = (this.selectedAvatar === 1) ? 2 : 1;
        
        const avatarImg = document.getElementById('avatar-display');
        avatarImg.src = ASSETS.chars[this.selectedAvatar];
        avatarImg.style.display = 'block';

        document.getElementById('login-screen').style.display = 'none';
        document.getElementById('game-container').style.display = 'block';
        
        // åˆå§‹åŒ–æŒ‰éˆ•
        this.createUnitButtons();
        
        this.startLevel(0);
        this.gameLoop(0);
    }

    startLevel(lvl) {
        this.isLevelTransitioning = false;
        
        if (lvl > 0) {
            let prevTotal = 0;
            for(let i=0; i<lvl; i++) prevTotal += this.#levelScores[i];
            this.#levelScores[lvl-1] = this.#score - prevTotal;
        }

        const levels = SecureConfig.getLevels();
        if (lvl >= levels.length) { 
            let prevTotal = 0;
            for(let i=0; i<9; i++) prevTotal += this.#levelScores[i];
            this.#levelScores[9] = this.#score - prevTotal;
            AudioSys.sfx.win_level(); 
            return this.endGame(true, "å¤©ä¸‹çµ±ä¸€ï¼ä¸‰åœ‹æ­¸ä¸€ï¼"); 
        }
        
        this.level = lvl;
        this.camera.reset(); 
        
        const mapPoints = MAPS[lvl % MAPS.length];
        this.pathPixels = mapPoints.map(p => ({
            x: p.x * CONFIG.gridSize + CONFIG.gridSize/2,
            y: p.y * CONFIG.gridSize + CONFIG.gridSize/2
        }));

        const lvlConfig = levels[lvl];
        this.maxBaseHp = 1000 + (lvl * 1000); 
        this.#baseHpEnemy = this.maxBaseHp * lvlConfig.statsMultiplier; 
        this.#baseHpPlayer = 1000 + (lvl * 200);
        
        if (lvl === 0) {
            this.#gold = 1000;
            this.#updateChecksum();
        } else {
            const bonus = 1000 + (lvl * 500);
            this.addGold(bonus);
            this.showMessage(`ç²å¾—å‡±æ—‹çé‡‘ $${bonus}ï¼`, false);
        }

        this.units = []; this.projectiles = []; this.particles = []; this.enemySpawnTimer = 0;
        this.resetUnitCounts();
        
        this.updateUI();
        document.getElementById('enemy-stats-hint').innerText = `(å¼·åº¦: ${Math.round(lvlConfig.statsMultiplier * 100)}%)`;
        setTimeout(() => { AudioSys.sfx.win_level(); this.showMessage(`ç¬¬ ${lvl+1} é—œ - é€²æ”»ï¼`); }, 500);
    }

    spawnPlayerUnit(typeKey) {
        if (this.isLevelTransitioning || this.isGameOver) return;
        const types = SecureConfig.getUnitTypes();
        const data = types[typeKey];
        
        if (this.#gold < data.cost) return this.showMessage("è»è²»ä¸è¶³", true);
        if (this.cooldowns[typeKey] > 0) return;
        if (data.limit && this.getUnitCount(typeKey) >= data.limit) {
            return this.showMessage(`æˆ°å ´åªèƒ½æœ‰ä¸€ä½${data.name}ï¼`, true);
        }

        this.addGold(-data.cost); 
        this.cooldowns[typeKey] = data.cd; 
        this.incrementUnitCount(typeKey);
        
        AudioSys.sfx.spawn();
        
        // æ ¹æ“šé™£ç‡Ÿæ±ºå®šå‡ºç”Ÿé»
        // é¾(1): å³å´å‡ºç”Ÿ(æœ€å¾Œä¸€é»)
        // è™(2): å·¦å´å‡ºç”Ÿ(ç¬¬ä¸€é»)
        const spawnIdx = (this.playerFaction === 1) ? this.pathPixels.length - 1 : 0;
        const startNode = this.pathPixels[spawnIdx];
        
        this.units.push(new Unit(startNode.x, startNode.y, 'player', typeKey, spawnIdx, 1, 1, this.playerFaction));
        this.updateUI();
    }

    spawnEnemyUnit() {
        if (this.isLevelTransitioning) return;
        const levels = SecureConfig.getLevels();
        const lvlData = levels[this.level];
        const types = lvlData.enemyTypes;
        const randType = types[Math.floor(Math.random() * types.length)];
        
        // æ•µäººå‡ºç”Ÿé»èˆ‡ç©å®¶ç›¸å
        const spawnIdx = (this.playerFaction === 1) ? 0 : this.pathPixels.length - 1;
        const startNode = this.pathPixels[spawnIdx];
        
        this.units.push(new Unit(startNode.x, startNode.y, 'enemy', randType, spawnIdx, lvlData.statsMultiplier, lvlData.speedMultiplier, this.enemyFaction));
    }

    gameLoop(timestamp) {
        if (this.isGameOver) return;
        if (!this.lastTime) this.lastTime = timestamp;
        const dt = timestamp - this.lastTime;
        if (dt > 16) { this.update(); this.draw(); this.lastTime = timestamp; }
        requestAnimationFrame((t) => this.gameLoop(t));
    }

    update() {
        const levels = SecureConfig.getLevels();
        const lvlData = levels[this.level];
        
        if (!this.isLevelTransitioning) {
            this.addGold(lvlData.goldRate * 0.5); 
            if (this.#gold > 50000) { this.#gold = 50000; this.#updateChecksum(); }
        }

        this.enemySpawnTimer++;
        if (this.enemySpawnTimer > lvlData.enemySpawnRate) {
            this.spawnEnemyUnit();
            this.enemySpawnTimer = 0;
        }

        const unitTypes = SecureConfig.getUnitTypes();
        for (let key in this.cooldowns) {
            if (this.cooldowns[key] > 0) this.cooldowns[key]--;
            const btn = document.getElementById(`btn-${key}`);
            if(btn) {
                const overlay = btn.querySelector('.cooldown-overlay');
                const percent = (this.cooldowns[key] / unitTypes[key].cd) * 100;
                overlay.style.height = `${percent}%`;
                const data = unitTypes[key];
                const isLimited = data.limit && this.getUnitCount(key) >= data.limit;
                if((percent <= 0 && this.#gold < data.cost) || isLimited) btn.classList.add('disabled');
                else btn.classList.remove('disabled');
            }
        }

        this.units.sort((a, b) => a.y - b.y);
        for (let i = this.units.length - 1; i >= 0; i--) {
            const u = this.units[i];
            u.update(this);
            if (u.dead) {
                if (u.team === 'player') this.decrementUnitCount(u.typeKey);
                this.units.splice(i, 1);
                if (u.team === 'enemy') {
                    const bounty = unitTypes[u.typeKey].cost * 0.3 * lvlData.statsMultiplier;
                    this.addGold(bounty);
                    this.addScore(10 * (this.level + 1));
                }
            }
        }

        for (let i = this.projectiles.length - 1; i >= 0; i--) {
            const p = this.projectiles[i];
            p.update();
            if (p.hit) this.projectiles.splice(i, 1);
        }

        this.particles = this.particles.filter(p => p.life > 0);
        this.particles.forEach(p => p.update());
        this.updateUI();

        if (this.#baseHpPlayer <= 0 && !this.isGameOver) {
            AudioSys.sfx.game_over(); this.endGame(false, "åŸæ± é™·è½ï¼Œå‹æ•—ä¹ƒå…µå®¶å¸¸äº‹...");
        }
        if (this.#baseHpEnemy <= 0 && !this.isLevelTransitioning) {
            this.#baseHpEnemy = 0; this.isLevelTransitioning = true;
            AudioSys.sfx.win_level(); this.showMessage("æ•µç‡Ÿæ”»ç ´ï¼å…¨è»æ•´å‚™...", false);
            this.units.forEach(u => u.state = 'move');
            setTimeout(() => { this.startLevel(this.level + 1); }, 3000);
        }
    }

    draw() {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this.drawBackground(); 
        this.drawPath();
        
        // æ ¹æ“šé™£ç‡Ÿæ±ºå®šåŸå ¡ä½ç½®
        const start = this.pathPixels[0];
        const end = this.pathPixels[this.pathPixels.length-1];
        
        if (this.playerFaction === 1) {
            // é¾å°‡è»(1)ï¼šæˆ‘åœ¨å³(End)ï¼Œæ•µåœ¨å·¦(Start)
            this.drawCastle(start.x, start.y, 'enemy', `æ•µç‡Ÿ Lv.${this.level+1}`);
            this.drawCastle(end.x, end.y, 'player', "æˆ‘åŸ");
        } else {
            // è™å…ƒå¸¥(2)ï¼šæˆ‘åœ¨å·¦(Start)ï¼Œæ•µåœ¨å³(End)
            this.drawCastle(start.x, start.y, 'player', "æˆ‘åŸ");
            this.drawCastle(end.x, end.y, 'enemy', `æ•µç‡Ÿ Lv.${this.level+1}`);
        }

        this.units.forEach(u => u.draw(this.ctx, this.camera));
        this.projectiles.forEach(p => p.draw(this.ctx, this.camera));
        this.particles.forEach(p => p.draw(this.ctx, this.camera));
    }

    drawBackground() {
        this.ctx.save();
        this.ctx.translate(this.camera.width / 2, this.camera.height / 2);
        this.ctx.scale(this.camera.zoom, this.camera.zoom);
        this.ctx.rotate(this.camera.angle);
        this.ctx.translate(-this.camera.x, -this.camera.y);
        const bgImg = ASSETS.images[`bg_${this.level}`];
        if (bgImg) this.ctx.drawImage(bgImg, 0, 0, 1200, 800);
        else { this.ctx.fillStyle = "#a9dfbf"; this.ctx.fillRect(0, 0, 1200, 800); }
        this.ctx.strokeStyle = "rgba(0,0,0,0.5)"; this.ctx.lineWidth = 5; this.ctx.strokeRect(0, 0, 1200, 800);
        this.ctx.restore();
    }

    drawPath() {
        this.ctx.lineCap = 'round'; this.ctx.lineJoin = 'round';
        this.ctx.lineWidth = 70 * this.camera.zoom; this.ctx.strokeStyle = 'rgba(230, 208, 206, 0.7)'; 
        this.ctx.beginPath();
        if (this.pathPixels.length > 0) {
            const start = this.camera.toScreen(this.pathPixels[0].x, this.pathPixels[0].y);
            this.ctx.moveTo(start.x, start.y);
            for (let i = 1; i < this.pathPixels.length; i++) {
                const p = this.camera.toScreen(this.pathPixels[i].x, this.pathPixels[i].y);
                this.ctx.lineTo(p.x, p.y);
            }
        }
        this.ctx.stroke();
    }

    drawCastle(wx, wy, type, label) {
        const pos = this.camera.toScreen(wx, wy); const s = pos.scale;
        this.ctx.fillStyle = "rgba(0,0,0,0.3)";
        this.ctx.beginPath(); this.ctx.ellipse(pos.x, pos.y, 40 * s, 20 * s, 0, 0, Math.PI * 2); this.ctx.fill();
        
        // æ ¹æ“š type æ±ºå®šé™£ç‡Ÿåœ–ç‰‡
        // type: 'player' or 'enemy'
        let faction = 1;
        if (type === 'player') faction = this.playerFaction;
        else faction = this.enemyFaction;
        
        const imgKey = `f${faction}_castle`;
        const img = ASSETS.images[imgKey];
        if (img) {
            const size = 100 * s;
            this.ctx.drawImage(img, pos.x - size/2, pos.y - size, size, size);
        }
        this.drawText(pos.x, pos.y - 110 * s, label, `${20 * s}px Arial`, "#fff");
    }

    drawText(x, y, text, font, color) {
        this.ctx.font = font; this.ctx.fillStyle = color;
        this.ctx.textAlign = "center"; this.ctx.shadowColor = "rgba(0,0,0,0.8)";
        this.ctx.shadowBlur = 4; this.ctx.fillText(text, x, y); this.ctx.shadowBlur = 0;
    }

    updateUI() {
        document.getElementById('gold').innerText = Math.floor(this.#gold);
        document.getElementById('wave-info').innerText = `ç¬¬ ${this.level + 1} é—œ`;
        const pPct = Math.max(0, (this.#baseHpPlayer / (1000 + this.level * 200)) * 100);
        document.getElementById('player-hp-bar').style.width = `${pPct}%`;
        
        const levels = SecureConfig.getLevels();
        const enemyMaxHp = (1000 + (this.level * 1000)) * levels[this.level].statsMultiplier;
        const ePct = Math.max(0, (this.#baseHpEnemy / enemyMaxHp) * 100);
        document.getElementById('enemy-hp-bar').style.width = `${ePct}%`;
    }

    showMessage(msg, isWarning = false) {
        const el = document.getElementById('message-area'); el.innerText = msg;
        el.style.color = isWarning ? '#e74c3c' : '#fff'; el.style.borderColor = isWarning ? '#e74c3c' : 'gold';
        el.style.display = 'block'; el.style.opacity = 1;
        if(this.msgTimeout) clearTimeout(this.msgTimeout);
        this.msgTimeout = setTimeout(() => { el.style.display = 'none'; }, 1500);
    }

    createEffect(x, y, type) {
        let color = 'white'; if (type === 'hit') color = 'orange'; if (type === 'blood') color = 'red';
        for(let i=0; i<6; i++) this.particles.push(new Particle(x, y, color));
    }

    endGame(isWin, reason) {
        this.isGameOver = true;
        document.getElementById('result-screen').style.display = 'flex';
        document.getElementById('end-title').innerText = isWin ? "ğŸ† å¤§ç²å…¨å‹" : "ğŸ’€ æˆ°æ•—";
        document.getElementById('end-title').style.color = isWin ? "gold" : "#e74c3c";
        document.getElementById('end-reason').innerText = reason;
        const duration = Math.floor((Date.now() - this.player.startTime)/1000);
        document.getElementById('final-score').innerText = this.#score;
        document.getElementById('final-time').innerText = duration + "s";
        this.sendToGas(duration);
    }

    sendToGas(duration) {
        if(CONFIG.gasUrl.includes("exec")) {
            const data = { 
                name: this.player.name, 
                id: this.player.id, 
                totalScore: this.#score, 
                levelScores: this.#levelScores, 
                duration: duration, 
                date: new Date().toISOString() 
            };
            fetch(CONFIG.gasUrl, { method: 'POST', mode: 'no-cors', headers: {'Content-Type': 'application/json'}, body: JSON.stringify(data) }).catch(e => console.error(e));
        }
    }
}

class Unit {
    constructor(x, y, team, typeKey, pathIdx, statsMult = 1, speedMult = 1, faction = 1) {
        this.x = x; this.y = y; this.team = team; this.typeKey = typeKey;
        this.faction = faction;
        const types = SecureConfig.getUnitTypes();
        const data = types[typeKey];
        
        this.name = data.name; this.maxHp = data.hp * statsMult; this.hp = this.maxHp;
        this.atk = data.atk * statsMult; this.range = data.range; this.speed = data.speed * speedMult;
        this.attackType = data.type; this.cd = data.cd;
        this.pathIndex = pathIdx; this.state = 'move'; this.attackCooldown = 0; this.dead = false;
        this.bounce = 0;
        
        // ä½¿ç”¨é™£ç‡Ÿç·¨è™Ÿå–å¾—å°æ‡‰åœ–ç‰‡
        this.imgKey = `f${faction}_${typeKey}`;
    }
    update(game) {
        if (this.dead) return;
        if (this.attackCooldown > 0) this.attackCooldown--;
        let target = this.findTarget(game);
        if (target) {
            this.state = 'attack';
            if (this.attackCooldown <= 0) { this.attack(target, game); this.attackCooldown = 60; }
        } else {
            this.state = 'move'; this.move(game);
        }
        if (this.state === 'move') this.bounce = Math.abs(Math.sin(Date.now() / 150)) * 5; else this.bounce = 0;
    }
    findTarget(game) {
        for (let u of game.units) {
            if (u.team !== this.team && !u.dead) {
                const dist = Math.hypot(u.x - this.x, u.y - this.y);
                if (dist <= this.range) return u;
            }
        }
        let baseDist = 9999;
        
        // åˆ¤æ–·åŸºåœ°ä½ç½®
        let enemyBaseIdx = -1;
        if (this.team === 'player') {
            // å¦‚æœç©å®¶æ˜¯é™£ç‡Ÿ1(é¾)ï¼Œæ•µäººåŸºåœ°åœ¨ 0
            // å¦‚æœç©å®¶æ˜¯é™£ç‡Ÿ2(è™)ï¼Œæ•µäººåŸºåœ°åœ¨ End
            enemyBaseIdx = (game.playerFaction === 1) ? 0 : game.pathPixels.length - 1;
        } else {
            // æ•µäººç›®æ¨™æ˜¯ç©å®¶åŸºåœ°
            enemyBaseIdx = (game.playerFaction === 1) ? game.pathPixels.length - 1 : 0;
        }
        
        const base = game.pathPixels[enemyBaseIdx];
        baseDist = Math.hypot(base.x - this.x, base.y - this.y);
        if (baseDist <= this.range) return { type: 'base', team: (this.team === 'player' ? 'enemy' : 'player') };
        
        return null;
    }
    attack(target, game) {
        if (this.attackType === 'ranged' || this.attackType === 'magic') {
            game.projectiles.push(new Projectile(this.x, this.y - 30, target, this.atk, this.team, this.attackType));
            if(this.attackType === 'magic') AudioSys.sfx.spell(); else AudioSys.sfx.attack_range();
        } else {
            game.createEffect(target.x || this.x, target.y || this.y, 'hit');
            AudioSys.sfx.attack_melee();
            if (target.type === 'base') {
                game.modifyHp(target.team, -this.atk); 
                game.createEffect(this.x, this.y, 'hit'); 
            } else { target.takeDamage(this.atk, game); }
        }
    }
    move(game) {
        // ç§»å‹•é‚è¼¯ï¼š
        // é™£ç‡Ÿ1 (é¾) çš„æ•µäºº(è™) -> å¾€å³èµ° (Index++)
        // é™£ç‡Ÿ1 (é¾) çš„ç©å®¶(é¾) -> å¾€å·¦èµ° (Index--)
        // é™£ç‡Ÿ2 (è™) çš„æ•µäºº(é¾) -> å¾€å·¦èµ° (Index--)
        // é™£ç‡Ÿ2 (è™) çš„ç©å®¶(è™) -> å¾€å³èµ° (Index++)
        
        // ç°¡åŒ–ï¼šç›®æ¨™ Index æ˜¯æ•µæ–¹åŸºåœ°
        let targetIdx = -1;
        
        if (this.team === 'player') {
            // ç©å®¶ç›®æ¨™ï¼šæ•µæ–¹åŸºåœ°
            // è‹¥ç©å®¶æ˜¯é¾(1)ï¼Œæ•µæ–¹åœ¨0 -> å¾€å·¦èµ°
            // è‹¥ç©å®¶æ˜¯è™(2)ï¼Œæ•µæ–¹åœ¨End -> å¾€å³èµ°
            targetIdx = (game.playerFaction === 1) ? 0 : game.pathPixels.length - 1;
        } else {
            // æ•µäººç›®æ¨™ï¼šç©å®¶åŸºåœ°
            // è‹¥ç©å®¶æ˜¯é¾(1)ï¼Œç©å®¶åœ¨Endï¼Œæ•µäººè¦å¾€Endèµ°
            // è‹¥ç©å®¶æ˜¯è™(2)ï¼Œç©å®¶åœ¨0ï¼Œæ•µäººè¦å¾€0èµ°
            targetIdx = (game.playerFaction === 1) ? game.pathPixels.length - 1 : 0;
        }
        
        if (this.pathIndex === targetIdx) return; // åˆ°é”
        
        // æ±ºå®šä¸‹ä¸€æ­¥
        let nextIdx = this.pathIndex;
        if (this.pathIndex < targetIdx) nextIdx++;
        else nextIdx--;
        
        const targetNode = game.pathPixels[nextIdx];
        const dx = targetNode.x - this.x; const dy = targetNode.y - this.y;
        const dist = Math.hypot(dx, dy);
        if (dist <= this.speed) { this.x = targetNode.x; this.y = targetNode.y; this.pathIndex = nextIdx; }
        else { this.x += (dx / dist) * this.speed; this.y += (dy / dist) * this.speed; }
    }
    takeDamage(amount, game) {
        this.hp -= amount; game.createEffect(this.x, this.y - 30, 'blood');
        if (this.hp <= 0) { this.dead = true; AudioSys.sfx.hit(); }
    }
    draw(ctx, camera) {
        const pos = camera.toScreen(this.x, this.y); const s = pos.scale;
        const drawY = pos.y - (30 * s) - (this.bounce * s);
        ctx.fillStyle = "rgba(0,0,0,0.3)"; ctx.beginPath();
        ctx.ellipse(pos.x, pos.y, 15 * s, 8 * s, 0, 0, Math.PI*2); ctx.fill();
        const img = ASSETS.images[this.imgKey];
        if (img) {
            const size = 50 * s;
            ctx.drawImage(img, pos.x - size/2, pos.y - size - (this.bounce * s), size, size);
        } else {
            ctx.fillStyle = this.team === 'player' ? 'blue' : 'red';
            ctx.beginPath(); ctx.arc(pos.x, drawY, 10*s, 0, Math.PI*2); ctx.fill();
        }
        const hpPct = this.hp / this.maxHp; const barY = pos.y - (55 * s) - (this.bounce * s);
        ctx.fillStyle = "#555"; ctx.fillRect(pos.x - (15 * s), barY, 30 * s, 4 * s);
        ctx.fillStyle = hpPct > 0.5 ? "#2ecc71" : "#e74c3c";
        ctx.fillRect(pos.x - (15 * s), barY, (30 * s) * hpPct, 4 * s);
    }
}

class Projectile {
    constructor(x, y, target, dmg, team, type = 'ranged') {
        this.x = x; this.y = y; this.target = target;
        this.damage = dmg; this.team = team; this.speed = 12; this.hit = false;
        this.type = type;
        
        // å­å½ˆç›®æ¨™é æ¸¬
        // å¦‚æœæœ‰ target ç‰©ä»¶ï¼Œé–å®šå®ƒ
        // å¦å‰‡é–å®šåŸºåœ°
        if (target && target.type !== 'base') {
            this.tx = target.x;
            this.ty = target.y - 30;
        } else {
            // åŸºåœ°ä½ç½®åˆ¤æ–·
            // ç©å®¶æ”»æ“Šç›®æ¨™ -> æ•µæ–¹åŸºåœ°
            let targetBaseIdx = 0;
            if (team === 'player') {
                targetBaseIdx = (Game.playerFaction === 1) ? 0 : Game.pathPixels.length - 1;
            } else {
                targetBaseIdx = (Game.playerFaction === 1) ? Game.pathPixels.length - 1 : 0;
            }
            const base = Game.pathPixels[targetBaseIdx];
            this.tx = base.x;
            this.ty = base.y - 30;
        }
    }
    update() {
        if (this.target && !this.target.dead && this.target.type !== 'base') { 
            this.tx = this.target.x; this.ty = this.target.y - 30; 
        }
        const dx = this.tx - this.x; const dy = this.ty - this.y; const dist = Math.hypot(dx, dy);
        if (dist <= this.speed) {
            this.hit = true; Game.createEffect(this.tx, this.ty, 'hit'); AudioSys.sfx.hit();
            if (this.type === 'magic') {
                const splashRange = 100; Game.createEffect(this.tx, this.ty, 'hit');
                if (this.target.type !== 'base') {
                    Game.units.forEach(u => {
                        if (u.team !== this.team && !u.dead) {
                            if (Math.hypot(u.x - this.tx, u.y - 30 - this.ty) < splashRange) u.takeDamage(this.damage * 0.5, Game);
                        }
                    });
                }
            }
            if (this.target.type === 'base') {
                Game.modifyHp(this.target.team, -this.damage); 
            } else if (this.target.takeDamage) { this.target.takeDamage(this.damage, Game); }
        } else { this.x += (dx/dist) * this.speed; this.y += (dy/dist) * this.speed; }
    }
    draw(ctx, camera) {
        const pos = camera.toScreen(this.x, this.y); const s = pos.scale;
        ctx.fillStyle = this.team === 'player' ? '#3498db' : '#e74c3c';
        if (this.type === 'magic') ctx.fillStyle = '#9b59b6';
        ctx.beginPath(); ctx.arc(pos.x, pos.y, (this.type === 'magic' ? 8 : 5) * s, 0, Math.PI*2); ctx.fill();
    }
}

class Particle {
    constructor(x, y, color) {
        this.x = x; this.y = y; this.color = color;
        this.vx = (Math.random()-0.5)*6; this.vy = (Math.random()-0.5)*6;
        this.life = 1.0; this.gravity = 0.2;
    }
    update() { this.x += this.vx; this.y += this.vy; this.vy += this.gravity; this.life -= 0.05; }
    draw(ctx, camera) {
        const pos = camera.toScreen(this.x, this.y); const s = pos.scale;
        ctx.globalAlpha = Math.max(0, this.life); ctx.fillStyle = this.color;
        ctx.beginPath(); ctx.arc(pos.x, pos.y, 4 * s, 0, Math.PI*2); ctx.fill(); ctx.globalAlpha = 1;
    }
}

const Game = new GameEngine();

</script>
</body>
</html>
